(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["app-9ff03e93"],{"0276":function(e,t,r){"use strict";r("d9e2"),r("14d9"),r("13d5"),r("907a"),r("986a"),r("1d02"),r("3c5d"),r("6ce5"),r("2834"),r("4ea1"),r("669d"),r("109c"),r("b2c1"),r("0643"),r("76d6"),r("2382"),r("fffc"),r("4e3e"),r("a573"),r("9d4a"),r("9a9a"),r("88e6"),r("70cc"),r("eb03"),r("22e5"),r("c01e"),r("fa76"),r("8306");var n=r("1c35"),i=r("aecc"),s=r("399f"),o=r("8ab6"),a=r("d129"),c=r("fa13"),u=r("8df2"),l=r("9ea2"),d=r("d920"),h=r("502a"),b=r("e01f"),p=r("136e"),g=r("00e3"),y=r("fb4a");function m(e){return e&&"object"===typeof e&&"default"in e?e:{default:e}}function f(e){if(e&&"object"===typeof e&&"default"in e)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var k=m(s),w=m(o),S=f(u),I=m(h),v=m(b),A=m(p);const _=i.ed25519.utils.randomPrivateKey,E=()=>{const e=i.ed25519.utils.randomPrivateKey(),t=O(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),{publicKey:t,secretKey:r}},O=i.ed25519.getPublicKey;function T(e){try{return i.ed25519.ExtendedPoint.fromHex(e),!0}catch{return!1}}const j=(e,t)=>i.ed25519.sign(e,t.slice(0,32)),B=i.ed25519.verify,N=e=>n.Buffer.isBuffer(e)?e:e instanceof Uint8Array?n.Buffer.from(e.buffer,e.byteOffset,e.byteLength):n.Buffer.from(e);class M{constructor(e){Object.assign(this,e)}encode(){return n.Buffer.from(c.serialize(L,this))}static decode(e){return c.deserialize(L,this,e)}static decodeUnchecked(e){return c.deserializeUnchecked(L,this,e)}}class x extends M{constructor(e){if(super(e),this.enum="",1!==Object.keys(e).length)throw new Error("Enum can only take single value");Object.keys(e).map(e=>{this.enum=e})}}const L=new Map;var P;let R;const U=32,z=32;function W(e){return void 0!==e._bn}let C=1;R=Symbol.toStringTag;class D extends M{constructor(e){if(super({}),this._bn=void 0,W(e))this._bn=e._bn;else{if("string"===typeof e){const t=w.default.decode(e);if(t.length!=z)throw new Error("Invalid public key input");this._bn=new k.default(t)}else this._bn=new k.default(e);if(this._bn.byteLength()>z)throw new Error("Invalid public key input")}}static unique(){const e=new D(C);return C+=1,new D(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return w.default.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(n.Buffer);if(e.length===z)return e;const t=n.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[R](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const i=n.Buffer.concat([e.toBuffer(),n.Buffer.from(t),r.toBuffer()]),s=a.sha256(i);return new D(s)}static createProgramAddressSync(e,t){let r=n.Buffer.alloc(0);e.forEach((function(e){if(e.length>U)throw new TypeError("Max seed length exceeded");r=n.Buffer.concat([r,N(e)])})),r=n.Buffer.concat([r,t.toBuffer(),n.Buffer.from("ProgramDerivedAddress")]);const i=a.sha256(r);if(T(i))throw new Error("Invalid seeds, address must fall off the curve");return new D(i)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r,i=255;while(0!=i){try{const s=e.concat(n.Buffer.from([i]));r=this.createProgramAddressSync(s,t)}catch(s){if(s instanceof TypeError)throw s;i--;continue}return[r,i]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new D(e);return T(t.toBytes())}}P=D,D.default=new P("11111111111111111111111111111111"),L.set(D,{kind:"struct",fields:[["_bn","u256"]]});class F{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const t=N(e);if(64!==e.length)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=N(_()),this._publicKey=N(O(this._secretKey))}get publicKey(){return new D(this._publicKey)}get secretKey(){return n.Buffer.concat([this._secretKey,this._publicKey],64)}}const V=new D("BPFLoader1111111111111111111111111111111111"),K=1232,Q=127,H=64;class Z extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Z.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class q extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature `+e+" using the Solana Explorer or CLI tools."),this.signature=void 0,this.signature=e}}Object.defineProperty(q.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Y extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Y.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class G{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){const t=255;if(this.length>t+1)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((e,t)=>{r.set(e.toBase58(),t)});const n=e=>{const t=r.get(e.toBase58());if(void 0===t)throw new Error("Encountered an unknown instruction account key during compilation");return t};return e.map(e=>({programIdIndex:n(e.programId),accountKeyIndexes:e.keys.map(e=>n(e.pubkey)),data:e.data}))}}const J=(e="publicKey")=>S.blob(32,e),X=(e="signature")=>S.blob(64,e),$=(e="string")=>{const t=S.struct([S.u32("length"),S.u32("lengthPadding"),S.blob(S.offset(S.u32(),-8),"chars")],e),r=t.decode.bind(t),i=t.encode.bind(t),s=t;return s.decode=(e,t)=>{const n=r(e,t);return n["chars"].toString()},s.encode=(e,t,r)=>{const s={chars:n.Buffer.from(e,"utf8")};return i(s,t,r)},s.alloc=e=>S.u32().span+S.u32().span+n.Buffer.from(e,"utf8").length,s},ee=(e="authorized")=>S.struct([J("staker"),J("withdrawer")],e),te=(e="lockup")=>S.struct([S.ns64("unixTimestamp"),S.ns64("epoch"),J("custodian")],e),re=(e="voteInit")=>S.struct([J("nodePubkey"),J("authorizedVoter"),J("authorizedWithdrawer"),S.u8("commission")],e),ne=(e="voteAuthorizeWithSeedArgs")=>S.struct([S.u32("voteAuthorizationType"),J("currentAuthorityDerivedKeyOwnerPubkey"),$("currentAuthorityDerivedKeySeed"),J("newAuthorized")],e);function ie(e,t){const r=e=>{if(e.span>=0)return e.span;if("function"===typeof e.alloc)return e.alloc(t[e.property]);if("count"in e&&"elementLayout"in e){const n=t[e.property];if(Array.isArray(n))return n.length*r(e.elementLayout)}else if("fields"in e)return ie({layout:e},t[e.property]);return 0};let n=0;return e.layout.fields.forEach(e=>{n+=r(e)}),n}function se(e){let t=0,r=0;for(;;){let n=e.shift();if(t|=(127&n)<<7*r,r+=1,0===(128&n))break}return t}function oe(e,t){let r=t;for(;;){let t=127&r;if(r>>=7,0==r){e.push(t);break}t|=128,e.push(t)}}function ae(e,t){if(!e)throw new Error(t||"Assertion failed")}class ce{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,n=e=>{const t=e.toBase58();let n=r.get(t);return void 0===n&&(n={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(t,n)),n},i=n(t);i.isSigner=!0,i.isWritable=!0;for(const s of e){n(s.programId).isInvoked=!0;for(const e of s.keys){const t=n(e.pubkey);t.isSigner||(t.isSigner=e.isSigner),t.isWritable||(t.isWritable=e.isWritable)}}return new ce(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];ae(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,e])=>e.isSigner&&e.isWritable),r=e.filter(([,e])=>e.isSigner&&!e.isWritable),n=e.filter(([,e])=>!e.isSigner&&e.isWritable),i=e.filter(([,e])=>!e.isSigner&&!e.isWritable),s={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:i.length};{ae(t.length>0,"Expected at least one writable signer key");const[e]=t[0];ae(e===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const o=[...t.map(([e])=>new D(e)),...r.map(([e])=>new D(e)),...n.map(([e])=>new D(e)),...i.map(([e])=>new D(e))];return[s,o]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,e=>!e.isSigner&&!e.isInvoked&&e.isWritable),[n,i]=this.drainKeysFoundInLookupTable(e.state.addresses,e=>!e.isSigner&&!e.isInvoked&&!e.isWritable);if(0!==t.length||0!==n.length)return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:n},{writable:r,readonly:i}]}drainKeysFoundInLookupTable(e,t){const r=new Array,n=new Array;for(const[i,s]of this.keyMetaMap.entries())if(t(s)){const t=new D(i),s=e.findIndex(e=>e.equals(t));s>=0&&(ae(s<256,"Max lookup table index exceeded"),r.push(s),n.push(t),this.keyMetaMap.delete(i))}return[r,n]}}class ue{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(e=>new D(e)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:w.default.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new G(this.staticAccountKeys)}static compile(e){const t=ce.compile(e.instructions,e.payerKey),[r,n]=t.getMessageComponents(),i=new G(n),s=i.compileInstructions(e.instructions).map(e=>({programIdIndex:e.programIdIndex,accounts:e.accountKeyIndexes,data:w.default.encode(e.data)}));return new ue({header:r,accountKeys:n,recentBlockhash:e.recentBlockhash,instructions:s})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const r=e-t,n=this.accountKeys.length-t,i=n-this.header.numReadonlyUnsignedAccounts;return r<i}{const r=t-this.header.numReadonlySignedAccounts;return e<r}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];oe(t,e);const r=this.instructions.map(e=>{const{accounts:t,programIdIndex:r}=e,i=Array.from(w.default.decode(e.data));let s=[];oe(s,t.length);let o=[];return oe(o,i.length),{programIdIndex:r,keyIndicesCount:n.Buffer.from(s),keyIndices:t,dataLength:n.Buffer.from(o),data:i}});let i=[];oe(i,r.length);let s=n.Buffer.alloc(K);n.Buffer.from(i).copy(s);let o=i.length;r.forEach(e=>{const t=S.struct([S.u8("programIdIndex"),S.blob(e.keyIndicesCount.length,"keyIndicesCount"),S.seq(S.u8("keyIndex"),e.keyIndices.length,"keyIndices"),S.blob(e.dataLength.length,"dataLength"),S.seq(S.u8("userdatum"),e.data.length,"data")]),r=t.encode(e,s,o);o+=r}),s=s.slice(0,o);const a=S.struct([S.blob(1,"numRequiredSignatures"),S.blob(1,"numReadonlySignedAccounts"),S.blob(1,"numReadonlyUnsignedAccounts"),S.blob(t.length,"keyCount"),S.seq(J("key"),e,"keys"),J("recentBlockhash")]),c={numRequiredSignatures:n.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:n.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:n.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:n.Buffer.from(t),keys:this.accountKeys.map(e=>N(e.toBytes())),recentBlockhash:w.default.decode(this.recentBlockhash)};let u=n.Buffer.alloc(2048);const l=a.encode(c,u);return s.copy(u,l),u.slice(0,l+s.length)}static from(e){let t=[...e];const r=t.shift();if(r!==(r&Q))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const i=t.shift(),s=t.shift(),o=se(t);let a=[];for(let h=0;h<o;h++){const e=t.splice(0,z);a.push(new D(n.Buffer.from(e)))}const c=t.splice(0,z),u=se(t);let l=[];for(let h=0;h<u;h++){const e=t.shift(),r=se(t),i=t.splice(0,r),s=se(t),o=t.splice(0,s),a=w.default.encode(n.Buffer.from(o));l.push({programIdIndex:e,accounts:i,data:a})}const d={header:{numRequiredSignatures:r,numReadonlySignedAccounts:i,numReadonlyUnsignedAccounts:s},recentBlockhash:w.default.encode(n.Buffer.from(c)),accountKeys:a,instructions:l};return new ue(d)}}class le{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new G(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){const t=e-r,n=this.addressTableLookups.reduce((e,t)=>e+t.writableIndexes.length,0);return t<n}if(e>=this.header.numRequiredSignatures){const n=e-t,i=r-t,s=i-this.header.numReadonlyUnsignedAccounts;return n<s}{const r=t-this.header.numReadonlySignedAccounts;return e<r}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const n=e.find(e=>e.key.equals(r.accountKey));if(!n)throw new Error("Failed to find address lookup table account for table key "+r.accountKey.toBase58());for(const e of r.writableIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.writable.push(n.state.addresses[e])}for(const e of r.readonlyIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.readonly.push(n.state.addresses[e])}}return t}static compile(e){const t=ce.compile(e.instructions,e.payerKey),r=new Array,n={writable:new Array,readonly:new Array},i=e.addressLookupTableAccounts||[];for(const u of i){const e=t.extractTableLookup(u);if(void 0!==e){const[t,{writable:i,readonly:s}]=e;r.push(t),n.writable.push(...i),n.readonly.push(...s)}}const[s,o]=t.getMessageComponents(),a=new G(o,n),c=a.compileInstructions(e.instructions);return new le({header:s,staticAccountKeys:o,recentBlockhash:e.recentBlockhash,compiledInstructions:c,addressTableLookups:r})}serialize(){const e=Array();oe(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();oe(r,this.compiledInstructions.length);const n=this.serializeAddressTableLookups(),i=Array();oe(i,this.addressTableLookups.length);const s=S.struct([S.u8("prefix"),S.struct([S.u8("numRequiredSignatures"),S.u8("numReadonlySignedAccounts"),S.u8("numReadonlyUnsignedAccounts")],"header"),S.blob(e.length,"staticAccountKeysLength"),S.seq(J(),this.staticAccountKeys.length,"staticAccountKeys"),J("recentBlockhash"),S.blob(r.length,"instructionsLength"),S.blob(t.length,"serializedInstructions"),S.blob(i.length,"addressTableLookupsLength"),S.blob(n.length,"serializedAddressTableLookups")]),o=new Uint8Array(K),a=128,c=s.encode({prefix:a,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(e=>e.toBytes()),recentBlockhash:w.default.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(i),serializedAddressTableLookups:n},o);return o.slice(0,c)}serializeInstructions(){let e=0;const t=new Uint8Array(K);for(const r of this.compiledInstructions){const n=Array();oe(n,r.accountKeyIndexes.length);const i=Array();oe(i,r.data.length);const s=S.struct([S.u8("programIdIndex"),S.blob(n.length,"encodedAccountKeyIndexesLength"),S.seq(S.u8(),r.accountKeyIndexes.length,"accountKeyIndexes"),S.blob(i.length,"encodedDataLength"),S.blob(r.data.length,"data")]);e+=s.encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(n),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(i),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(K);for(const r of this.addressTableLookups){const n=Array();oe(n,r.writableIndexes.length);const i=Array();oe(i,r.readonlyIndexes.length);const s=S.struct([J("accountKey"),S.blob(n.length,"encodedWritableIndexesLength"),S.seq(S.u8(),r.writableIndexes.length,"writableIndexes"),S.blob(i.length,"encodedReadonlyIndexesLength"),S.seq(S.u8(),r.readonlyIndexes.length,"readonlyIndexes")]);e+=s.encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(n),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(i),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=t.shift(),n=r&Q;ae(r!==n,"Expected versioned message but received legacy message");const i=n;ae(0===i,"Expected versioned message with version 0 but found version "+i);const s={numRequiredSignatures:t.shift(),numReadonlySignedAccounts:t.shift(),numReadonlyUnsignedAccounts:t.shift()},o=[],a=se(t);for(let b=0;b<a;b++)o.push(new D(t.splice(0,z)));const c=w.default.encode(t.splice(0,z)),u=se(t),l=[];for(let b=0;b<u;b++){const e=t.shift(),r=se(t),n=t.splice(0,r),i=se(t),s=new Uint8Array(t.splice(0,i));l.push({programIdIndex:e,accountKeyIndexes:n,data:s})}const d=se(t),h=[];for(let b=0;b<d;b++){const e=new D(t.splice(0,z)),r=se(t),n=t.splice(0,r),i=se(t),s=t.splice(0,i);h.push({accountKey:e,writableIndexes:n,readonlyIndexes:s})}return new le({header:s,staticAccountKeys:o,recentBlockhash:c,compiledInstructions:l,addressTableLookups:h})}}const de={deserializeMessageVersion(e){const t=e[0],r=t&Q;return r===t?"legacy":r},deserialize:e=>{const t=de.deserializeMessageVersion(e);if("legacy"===t)return ue.from(e);if(0===t)return le.deserialize(e);throw new Error(`Transaction message version ${t} deserialization is not supported`)}};let he=function(e){return e[e["BLOCKHEIGHT_EXCEEDED"]=0]="BLOCKHEIGHT_EXCEEDED",e[e["PROCESSED"]=1]="PROCESSED",e[e["TIMED_OUT"]=2]="TIMED_OUT",e[e["NONCE_INVALID"]=3]="NONCE_INVALID",e}({});const be=n.Buffer.alloc(H).fill(0);class pe{constructor(e){this.keys=void 0,this.programId=void 0,this.data=n.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class ge{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(0===e.length)throw new Error("No instructions");return e.forEach(e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new pe(e))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t,r;if(this.nonceInfo?(e=this.nonceInfo.nonce,t=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");if(t.length,this.feePayer)r=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");r=this.signatures[0].publicKey}for(let p=0;p<t.length;p++)if(void 0===t[p].programId)throw new Error(`Transaction instruction index ${p} has undefined program id`);const n=[],i=[];t.forEach(e=>{e.keys.forEach(e=>{i.push({...e})});const t=e.programId.toString();n.includes(t)||n.push(t)}),n.forEach(e=>{i.push({pubkey:new D(e),isSigner:!1,isWritable:!1})});const s=[];i.forEach(e=>{const t=e.pubkey.toString(),r=s.findIndex(e=>e.pubkey.toString()===t);r>-1?(s[r].isWritable=s[r].isWritable||e.isWritable,s[r].isSigner=s[r].isSigner||e.isSigner):s.push(e)}),s.sort((function(e,t){if(e.isSigner!==t.isSigner)return e.isSigner?-1:1;if(e.isWritable!==t.isWritable)return e.isWritable?-1:1;const r={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return e.pubkey.toBase58().localeCompare(t.pubkey.toBase58(),"en",r)}));const o=s.findIndex(e=>e.pubkey.equals(r));if(o>-1){const[e]=s.splice(o,1);e.isSigner=!0,e.isWritable=!0,s.unshift(e)}else s.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const p of this.signatures){const e=s.findIndex(e=>e.pubkey.equals(p.publicKey));if(!(e>-1))throw new Error("unknown signer: "+p.publicKey.toString());s[e].isSigner||(s[e].isSigner=!0)}let a=0,c=0,u=0;const l=[],d=[];s.forEach(({pubkey:e,isSigner:t,isWritable:r})=>{t?(l.push(e.toString()),a+=1,r||(c+=1)):(d.push(e.toString()),r||(u+=1))});const h=l.concat(d),b=t.map(e=>{const{data:t,programId:r}=e;return{programIdIndex:h.indexOf(r.toString()),accounts:e.keys.map(e=>h.indexOf(e.pubkey.toString())),data:w.default.encode(t)}});return b.forEach(e=>{ae(e.programIdIndex>=0),e.accounts.forEach(e=>ae(e>=0))}),new ue({header:{numRequiredSignatures:a,numReadonlySignedAccounts:c,numReadonlyUnsignedAccounts:u},accountKeys:h,recentBlockhash:e,instructions:b})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);if(this.signatures.length===t.length){const r=this.signatures.every((e,r)=>t[r].equals(e.publicKey));if(r)return e}return this.signatures=t.map(e=>({signature:null,publicKey:e})),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(0===e.length)throw new Error("No signers");const t=new Set;this.signatures=e.filter(e=>{const r=e.toString();return!t.has(r)&&(t.add(r),!0)}).map(e=>({signature:null,publicKey:e}))}sign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const i of e){const e=i.publicKey.toString();t.has(e)||(t.add(e),r.push(i))}this.signatures=r.map(e=>({signature:null,publicKey:e.publicKey}));const n=this._compile();this._partialSign(n,...r)}partialSign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const i of e){const e=i.publicKey.toString();t.has(e)||(t.add(e),r.push(i))}const n=this._compile();this._partialSign(n,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach(e=>{const t=j(r,e.secretKey);this._addSignature(e.publicKey,N(t))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){ae(64===t.length);const r=this.signatures.findIndex(t=>e.equals(t.publicKey));if(r<0)throw new Error("unknown signer: "+e.toString());this.signatures[r].signature=n.Buffer.from(t)}verifySignatures(e=!0){const t=this._getMessageSignednessErrors(this.serializeMessage(),e);return!t}_getMessageSignednessErrors(e,t){const r={};for(const{signature:n,publicKey:i}of this.signatures)null===n?t&&(r.missing||(r.missing=[])).push(i):B(n,e,i.toBytes())||(r.invalid||(r.invalid=[])).push(i);return r.invalid||r.missing?r:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r){const e=this._getMessageSignednessErrors(n,t);if(e){let t="Signature verification failed.";throw e.invalid&&(t+=`\nInvalid signature for public key${1===e.invalid.length?"":"(s)"} [\`${e.invalid.map(e=>e.toBase58()).join("`, `")}\`].`),e.missing&&(t+=`\nMissing signature for public key${1===e.missing.length?"":"(s)"} [\`${e.missing.map(e=>e.toBase58()).join("`, `")}\`].`),new Error(t)}}return this._serialize(n)}_serialize(e){const{signatures:t}=this,r=[];oe(r,t.length);const i=r.length+64*t.length+e.length,s=n.Buffer.alloc(i);return ae(t.length<256),n.Buffer.from(r).copy(s,0),t.forEach(({signature:e},t)=>{null!==e&&(ae(64===e.length,"signature has invalid length"),n.Buffer.from(e).copy(s,r.length+64*t))}),e.copy(s,r.length+64*t.length),ae(s.length<=K,`Transaction too large: ${s.length} > ${K}`),s}get keys(){return ae(1===this.instructions.length),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return ae(1===this.instructions.length),this.instructions[0].programId}get data(){return ae(1===this.instructions.length),this.instructions[0].data}static from(e){let t=[...e];const r=se(t);let i=[];for(let s=0;s<r;s++){const e=t.splice(0,H);i.push(w.default.encode(n.Buffer.from(e)))}return ge.populate(ue.from(t),i)}static populate(e,t=[]){const r=new ge;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach((t,n)=>{const i={signature:t==w.default.encode(be)?null:w.default.decode(t),publicKey:e.accountKeys[n]};r.signatures.push(i)}),e.instructions.forEach(t=>{const n=t.accounts.map(t=>{const n=e.accountKeys[t];return{pubkey:n,isSigner:r.signatures.some(e=>e.publicKey.toString()===n.toString())||e.isAccountSigner(t),isWritable:e.isAccountWritable(t)}});r.instructions.push(new pe({keys:n,programId:e.accountKeys[t.programIdIndex],data:w.default.decode(t.data)}))}),r._message=e,r._json=r.toJSON(),r}}class ye{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:r,compiledInstructions:n,recentBlockhash:i}=e,{numRequiredSignatures:s,numReadonlySignedAccounts:o,numReadonlyUnsignedAccounts:a}=r,c=s-o;ae(c>0,"Message header is invalid");const u=e.staticAccountKeys.length-s-a;ae(u>=0,"Message header is invalid");const l=e.getAccountKeys(t),d=l.get(0);if(void 0===d)throw new Error("Failed to decompile message because no account keys were found");const h=[];for(const b of n){const e=[];for(const n of b.accountKeyIndexes){const t=l.get(n);if(void 0===t)throw new Error("Failed to find key for account key index "+n);const i=n<s;let o;o=i?n<c:n<l.staticAccountKeys.length?n-s<u:n-l.staticAccountKeys.length<l.accountKeysFromLookups.writable.length,e.push({pubkey:t,isSigner:n<r.numRequiredSignatures,isWritable:o})}const t=l.get(b.programIdIndex);if(void 0===t)throw new Error("Failed to find program id for program id index "+b.programIdIndex);h.push(new pe({programId:t,data:N(b.data),keys:e}))}return new ye({payerKey:d,instructions:h,recentBlockhash:i})}compileToLegacyMessage(){return ue.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return le.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class me{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,void 0!==t)ae(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const t=[];for(let r=0;r<e.header.numRequiredSignatures;r++)t.push(new Uint8Array(H));this.signatures=t}this.message=e}serialize(){const e=this.message.serialize(),t=Array();oe(t,this.signatures.length);const r=S.struct([S.blob(t.length,"encodedSignaturesLength"),S.seq(X(),this.signatures.length,"signatures"),S.blob(e.length,"serializedMessage")]),n=new Uint8Array(2048),i=r.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},n);return n.slice(0,i)}static deserialize(e){let t=[...e];const r=[],n=se(t);for(let s=0;s<n;s++)r.push(new Uint8Array(t.splice(0,H)));const i=de.deserialize(new Uint8Array(t));return new me(i,r)}sign(e){const t=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const n of e){const e=r.findIndex(e=>e.equals(n.publicKey));ae(e>=0,"Cannot sign with non signer key "+n.publicKey.toBase58()),this.signatures[e]=j(t,n.secretKey)}}addSignature(e,t){ae(64===t.byteLength,"Signature must be 64 bytes long");const r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures),n=r.findIndex(t=>t.equals(e));ae(n>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[n]=t}}const fe=160,ke=64,we=fe/ke,Se=1e3/we,Ie=new D("SysvarC1ock11111111111111111111111111111111"),ve=new D("SysvarEpochSchedu1e111111111111111111111111"),Ae=new D("Sysvar1nstructions1111111111111111111111111"),_e=new D("SysvarRecentB1ockHashes11111111111111111111"),Ee=new D("SysvarRent111111111111111111111111111111111"),Oe=new D("SysvarRewards111111111111111111111111111111"),Te=new D("SysvarS1otHashes111111111111111111111111111"),je=new D("SysvarS1otHistory11111111111111111111111111"),Be=new D("SysvarStakeHistory1111111111111111111111111");async function Ne(e,t,r,n){const i=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},s=await e.sendTransaction(t,r,i);let o;if(null!=t.recentBlockhash&&null!=t.lastValidBlockHeight)o=(await e.confirmTransaction({abortSignal:null===n||void 0===n?void 0:n.abortSignal,signature:s,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},n&&n.commitment)).value;else if(null!=t.minNonceContextSlot&&null!=t.nonceInfo){const{nonceInstruction:r}=t.nonceInfo,i=r.keys[0].pubkey;o=(await e.confirmTransaction({abortSignal:null===n||void 0===n?void 0:n.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:i,nonceValue:t.nonceInfo.nonce,signature:s},n&&n.commitment)).value}else null===n||void 0===n||n.abortSignal,o=(await e.confirmTransaction(s,n&&n.commitment)).value;if(o.err)throw new Error(`Transaction ${s} failed (${JSON.stringify(o)})`);return s}function Me(e){return new Promise(t=>setTimeout(t,e))}function xe(e,t){const r=e.layout.span>=0?e.layout.span:ie(e,t),i=n.Buffer.alloc(r),s=Object.assign({instruction:e.index},t);return e.layout.encode(s,i),i}function Le(e,t){let r;try{r=e.layout.decode(t)}catch(n){throw new Error("invalid instruction; "+n)}if(r.instruction!==e.index)throw new Error(`invalid instruction; instruction index mismatch ${r.instruction} != ${e.index}`);return r}const Pe=S.nu64("lamportsPerSignature"),Re=S.struct([S.u32("version"),S.u32("state"),J("authorizedPubkey"),J("nonce"),S.struct([Pe],"feeCalculator")]),Ue=Re.span;class ze{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Re.decode(N(e),0);return new ze({authorizedPubkey:new D(t.authorizedPubkey),nonce:new D(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const We=e=>{const t=e.decode.bind(e),r=e.encode.bind(e);return{decode:t,encode:r}},Ce=e=>t=>{const r=u.blob(e,t),{encode:i,decode:s}=We(r),o=r;return o.decode=(e,t)=>{const r=s(e,t);return l.toBigIntLE(n.Buffer.from(r))},o.encode=(t,r,n)=>{const s=l.toBufferLE(t,e);return i(s,r,n)},o},De=Ce(8);class Fe{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=S.u32("instruction"),r=t.decode(e.data);let n;for(const[i,s]of Object.entries(Ve))if(s.index==r){n=i;break}if(!n)throw new Error("Instruction type incorrect; not a SystemInstruction");return n}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:r,programId:n}=Le(Ve.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:r,programId:new D(n)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=Le(Ve.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:r,programId:n}=Le(Ve.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:r,programId:new D(n)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=Le(Ve.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,space:n,programId:i}=Le(Ve.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new D(t),seed:r,space:n,programId:new D(i)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=Le(Ve.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new D(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,programId:n}=Le(Ve.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new D(t),seed:r,programId:new D(n)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:r,lamports:n,space:i,programId:s}=Le(Ve.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new D(t),seed:r,lamports:n,space:i,programId:new D(s)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=Le(Ve.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new D(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),Le(Ve.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=Le(Ve.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=Le(Ve.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new D(t)}}static checkProgramId(e){if(!e.equals(Ke.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const Ve=Object.freeze({Create:{index:0,layout:S.struct([S.u32("instruction"),S.ns64("lamports"),S.ns64("space"),J("programId")])},Assign:{index:1,layout:S.struct([S.u32("instruction"),J("programId")])},Transfer:{index:2,layout:S.struct([S.u32("instruction"),De("lamports")])},CreateWithSeed:{index:3,layout:S.struct([S.u32("instruction"),J("base"),$("seed"),S.ns64("lamports"),S.ns64("space"),J("programId")])},AdvanceNonceAccount:{index:4,layout:S.struct([S.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:S.struct([S.u32("instruction"),S.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:S.struct([S.u32("instruction"),J("authorized")])},AuthorizeNonceAccount:{index:7,layout:S.struct([S.u32("instruction"),J("authorized")])},Allocate:{index:8,layout:S.struct([S.u32("instruction"),S.ns64("space")])},AllocateWithSeed:{index:9,layout:S.struct([S.u32("instruction"),J("base"),$("seed"),S.ns64("space"),J("programId")])},AssignWithSeed:{index:10,layout:S.struct([S.u32("instruction"),J("base"),$("seed"),J("programId")])},TransferWithSeed:{index:11,layout:S.struct([S.u32("instruction"),De("lamports"),$("seed"),J("programId")])},UpgradeNonceAccount:{index:12,layout:S.struct([S.u32("instruction")])}});class Ke{constructor(){}static createAccount(e){const t=Ve.Create,r=xe(t,{lamports:e.lamports,space:e.space,programId:N(e.programId.toBuffer())});return new pe({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(e){let t,r;if("basePubkey"in e){const n=Ve.TransferWithSeed;t=xe(n,{lamports:BigInt(e.lamports),seed:e.seed,programId:N(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const n=Ve.Transfer;t=xe(n,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new pe({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){const n=Ve.AssignWithSeed;t=xe(n,{base:N(e.basePubkey.toBuffer()),seed:e.seed,programId:N(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const n=Ve.Assign;t=xe(n,{programId:N(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new pe({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=Ve.CreateWithSeed,r=xe(t,{base:N(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:N(e.programId.toBuffer())});let n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&n.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new pe({keys:n,programId:this.programId,data:r})}static createNonceAccount(e){const t=new ge;"basePubkey"in e&&"seed"in e?t.add(Ke.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Ue,programId:this.programId})):t.add(Ke.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Ue,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=Ve.InitializeNonceAccount,r=xe(t,{authorized:N(e.authorizedPubkey.toBuffer())}),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:Ee,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new pe(n)}static nonceAdvance(e){const t=Ve.AdvanceNonceAccount,r=xe(t),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new pe(n)}static nonceWithdraw(e){const t=Ve.WithdrawNonceAccount,r=xe(t,{lamports:e.lamports});return new pe({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:Ee,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(e){const t=Ve.AuthorizeNonceAccount,r=xe(t,{authorized:N(e.newAuthorizedPubkey.toBuffer())});return new pe({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(e){let t,r;if("basePubkey"in e){const n=Ve.AllocateWithSeed;t=xe(n,{base:N(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:N(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const n=Ve.Allocate;t=xe(n,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new pe({keys:r,programId:this.programId,data:t})}}Ke.programId=new D("11111111111111111111111111111111");const Qe=K-300;class He{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/He.chunkSize)+1+1)}static async load(e,t,r,i,s){{const n=await e.getMinimumBalanceForRentExemption(s.length),o=await e.getAccountInfo(r.publicKey,"confirmed");let a=null;if(null!==o){if(o.executable)return!1;o.data.length!==s.length&&(a=a||new ge,a.add(Ke.allocate({accountPubkey:r.publicKey,space:s.length}))),o.owner.equals(i)||(a=a||new ge,a.add(Ke.assign({accountPubkey:r.publicKey,programId:i}))),o.lamports<n&&(a=a||new ge,a.add(Ke.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:n-o.lamports})))}else a=(new ge).add(Ke.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:n>0?n:1,space:s.length,programId:i}));null!==a&&await Ne(e,a,[t,r],{commitment:"confirmed"})}const o=S.struct([S.u32("instruction"),S.u32("offset"),S.u32("bytesLength"),S.u32("bytesLengthPadding"),S.seq(S.u8("byte"),S.offset(S.u32(),-8),"bytes")]),a=He.chunkSize;let c=0,u=s,l=[];while(u.length>0){const s=u.slice(0,a),d=n.Buffer.alloc(a+16);o.encode({instruction:0,offset:c,bytes:s,bytesLength:0,bytesLengthPadding:0},d);const h=(new ge).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:i,data:d});if(l.push(Ne(e,h,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")){const e=4;await Me(1e3/e)}c+=a,u=u.slice(a)}await Promise.all(l);{const s=S.struct([S.u32("instruction")]),o=n.Buffer.alloc(s.span);s.encode({instruction:1},o);const a=(new ge).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:Ee,isSigner:!1,isWritable:!1}],programId:i,data:o}),c="processed",u=await e.sendTransaction(a,[t,r],{preflightCommitment:c}),{context:l,value:d}=await e.confirmTransaction({signature:u,lastValidBlockHeight:a.lastValidBlockHeight,blockhash:a.recentBlockhash},c);if(d.err)throw new Error(`Transaction ${u} failed (${JSON.stringify(d)})`);while(1){try{const t=await e.getSlot({commitment:c});if(t>l.slot)break}catch{}await new Promise(e=>setTimeout(e,Math.round(Se/2)))}}return!0}}He.chunkSize=Qe;const Ze=new D("BPFLoader2111111111111111111111111111111111");class qe{static getMinNumSignatures(e){return He.getMinNumSignatures(e)}static load(e,t,r,n,i){return He.load(e,t,r,i,n)}}function Ye(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e["default"]:e}var Ge=Object.prototype.toString,Je=Object.keys||function(e){var t=[];for(var r in e)t.push(r);return t};function Xe(e,t){var r,n,i,s,o,a,c;if(!0===e)return"true";if(!1===e)return"false";switch(typeof e){case"object":if(null===e)return null;if(e.toJSON&&"function"===typeof e.toJSON)return Xe(e.toJSON(),t);if(c=Ge.call(e),"[object Array]"===c){for(i="[",n=e.length-1,r=0;r<n;r++)i+=Xe(e[r],!0)+",";return n>-1&&(i+=Xe(e[r],!0)),i+"]"}if("[object Object]"===c){s=Je(e).sort(),n=s.length,i="",r=0;while(r<n)o=s[r],a=Xe(e[o],!1),void 0!==a&&(i&&(i+=","),i+=JSON.stringify(o)+":"+a),r++;return"{"+i+"}"}return JSON.stringify(e);case"function":case"undefined":return t?null:void 0;case"string":return JSON.stringify(e);default:return isFinite(e)?e:null}}var $e=function(e){var t=Xe(e,!1);if(void 0!==t)return""+t},et=Ye($e);const tt=32;function rt(e){let t=0;while(e>1)e/=2,t++;return t}function nt(e){return 0===e?1:(e--,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,e|=e>>32,e+1)}class it{constructor(e,t,r,n,i){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=r,this.firstNormalEpoch=n,this.firstNormalSlot=i}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=rt(nt(e+tt+1))-rt(tt)-1,r=this.getSlotsInEpoch(t),n=e-(r-tt);return[t,n]}{const t=e-this.firstNormalSlot,r=Math.floor(t/this.slotsPerEpoch),n=this.firstNormalEpoch+r,i=t%this.slotsPerEpoch;return[n,i]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*tt:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+rt(tt)):this.slotsPerEpoch}}class st extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}const ot={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class at extends Error{constructor({code:e,message:t,data:r},n){super(null!=n?`${n}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=r,this.name="SolanaJSONRPCError"}}var ct=globalThis.fetch;class ut extends v.default{constructor(e,t,r){const n=e=>{const r=A.default(e,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return this.underlyingSocket="socket"in r?r.socket:r,r};super(n,e,t,r),this.underlyingSocket=void 0}call(...e){var t;const r=null===(t=this.underlyingSocket)||void 0===t?void 0:t.readyState;return 1===r?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}notify(...e){var t;const r=null===(t=this.underlyingSocket)||void 0===t?void 0:t.readyState;return 1===r?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}}function lt(e,t){let r;try{r=e.layout.decode(t)}catch(n){throw new Error("invalid instruction; "+n)}if(r.typeIndex!==e.index)throw new Error(`invalid account data; account type mismatch ${r.typeIndex} != ${e.index}`);return r}const dt=56;class ht{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=lt(bt,e),r=e.length-dt;ae(r>=0,"lookup table is invalid"),ae(r%32===0,"lookup table is invalid");const n=r/32,{addresses:i}=S.struct([S.seq(J(),n,"addresses")]).decode(e.slice(dt));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:0!==t.authority.length?new D(t.authority[0]):void 0,addresses:i.map(e=>new D(e))}}}const bt={index:1,layout:S.struct([S.u32("typeIndex"),De("deactivationSlot"),S.nu64("lastExtendedSlot"),S.u8("lastExtendedStartIndex"),S.u8(),S.seq(J(),S.offset(S.u8(),-1),"authority")])},pt=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function gt(e){const t=e.match(pt);if(null==t)throw TypeError(`Failed to validate endpoint URL \`${e}\``);const[r,n,i,s]=t,o=e.startsWith("https:")?"wss:":"ws:",a=null==i?null:parseInt(i.slice(1),10),c=null==a?"":":"+(a+1);return`${o}//${n}${c}${s}`}const yt=d.coerce(d.instance(D),d.string(),e=>new D(e)),mt=d.tuple([d.string(),d.literal("base64")]),ft=d.coerce(d.instance(n.Buffer),mt,e=>n.Buffer.from(e[0],"base64")),kt=3e4;function wt(e){if(!1===/^https?:/.test(e))throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return e}function St(e){let t,r;if("string"===typeof e)t=e;else if(e){const{commitment:n,...i}=e;t=n,r=i}return{commitment:t,config:r}}function It(e){return d.union([d.type({jsonrpc:d.literal("2.0"),id:d.string(),result:e}),d.type({jsonrpc:d.literal("2.0"),id:d.string(),error:d.type({code:d.unknown(),message:d.string(),data:d.optional(d.any())})})])}const vt=It(d.unknown());function At(e){return d.coerce(It(e),vt,t=>"error"in t?t:{...t,result:d.create(t.result,e)})}function _t(e){return At(d.type({context:d.type({slot:d.number()}),value:e}))}function Et(e){return d.type({context:d.type({slot:d.number()}),value:e})}function Ot(e,t){return 0===e?new le({header:t.header,staticAccountKeys:t.accountKeys.map(e=>new D(e)),recentBlockhash:t.recentBlockhash,compiledInstructions:t.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:w.default.decode(e.data)})),addressTableLookups:t.addressTableLookups}):new ue(t)}const Tt=d.type({foundation:d.number(),foundationTerm:d.number(),initial:d.number(),taper:d.number(),terminal:d.number()}),jt=At(d.array(d.nullable(d.type({epoch:d.number(),effectiveSlot:d.number(),amount:d.number(),postBalance:d.number(),commission:d.optional(d.nullable(d.number()))})))),Bt=d.array(d.type({slot:d.number(),prioritizationFee:d.number()})),Nt=d.type({total:d.number(),validator:d.number(),foundation:d.number(),epoch:d.number()}),Mt=d.type({epoch:d.number(),slotIndex:d.number(),slotsInEpoch:d.number(),absoluteSlot:d.number(),blockHeight:d.optional(d.number()),transactionCount:d.optional(d.number())}),xt=d.type({slotsPerEpoch:d.number(),leaderScheduleSlotOffset:d.number(),warmup:d.boolean(),firstNormalEpoch:d.number(),firstNormalSlot:d.number()}),Lt=d.record(d.string(),d.array(d.number())),Pt=d.nullable(d.union([d.type({}),d.string()])),Rt=d.type({err:Pt}),Ut=d.literal("receivedSignature"),zt=d.type({"solana-core":d.string(),"feature-set":d.optional(d.number())}),Wt=_t(d.type({err:d.nullable(d.union([d.type({}),d.string()])),logs:d.nullable(d.array(d.string())),accounts:d.optional(d.nullable(d.array(d.nullable(d.type({executable:d.boolean(),owner:d.string(),lamports:d.number(),data:d.array(d.string()),rentEpoch:d.optional(d.number())}))))),unitsConsumed:d.optional(d.number()),returnData:d.optional(d.nullable(d.type({programId:d.string(),data:d.tuple([d.string(),d.literal("base64")])})))})),Ct=_t(d.type({byIdentity:d.record(d.string(),d.array(d.number())),range:d.type({firstSlot:d.number(),lastSlot:d.number()})}));function Dt(e,t,r,n,i,s){const o=r||ct;let a,c;n&&(c=async(e,t)=>{const r=await new Promise((r,i)=>{try{n(e,t,(e,t)=>r([e,t]))}catch(s){i(s)}});return await o(...r)});const u=new I.default(async(r,n)=>{const s={method:"POST",body:r,agent:a,headers:Object.assign({"Content-Type":"application/json"},t||{},dn)};try{let t,r=5,a=500;for(;;){if(t=c?await c(e,s):await o(e,s),429!==t.status)break;if(!0===i)break;if(r-=1,0===r)break;await Me(a),a*=2}const u=await t.text();t.ok?n(null,u):n(new Error(`${t.status} ${t.statusText}: ${u}`))}catch(u){u instanceof Error&&n(u)}},{});return u}function Ft(e){return(t,r)=>new Promise((n,i)=>{e.request(t,r,(e,t)=>{e?i(e):n(t)})})}function Vt(e){return t=>new Promise((r,n)=>{0===t.length&&r([]);const i=t.map(t=>e.request(t.methodName,t.args));e.request(i,(e,t)=>{e?n(e):r(t)})})}const Kt=At(Tt),Qt=At(Nt),Ht=At(Bt),Zt=At(Mt),qt=At(xt),Yt=At(Lt),Gt=At(d.number()),Jt=_t(d.type({total:d.number(),circulating:d.number(),nonCirculating:d.number(),nonCirculatingAccounts:d.array(yt)})),Xt=d.type({amount:d.string(),uiAmount:d.nullable(d.number()),decimals:d.number(),uiAmountString:d.optional(d.string())}),$t=_t(d.array(d.type({address:yt,amount:d.string(),uiAmount:d.nullable(d.number()),decimals:d.number(),uiAmountString:d.optional(d.string())}))),er=_t(d.array(d.type({pubkey:yt,account:d.type({executable:d.boolean(),owner:yt,lamports:d.number(),data:ft,rentEpoch:d.number()})}))),tr=d.type({program:d.string(),parsed:d.unknown(),space:d.number()}),rr=_t(d.array(d.type({pubkey:yt,account:d.type({executable:d.boolean(),owner:yt,lamports:d.number(),data:tr,rentEpoch:d.number()})}))),nr=_t(d.array(d.type({lamports:d.number(),address:yt}))),ir=d.type({executable:d.boolean(),owner:yt,lamports:d.number(),data:ft,rentEpoch:d.number()}),sr=d.type({pubkey:yt,account:ir}),or=d.coerce(d.union([d.instance(n.Buffer),tr]),d.union([mt,tr]),e=>Array.isArray(e)?d.create(e,ft):e),ar=d.type({executable:d.boolean(),owner:yt,lamports:d.number(),data:or,rentEpoch:d.number()}),cr=d.type({pubkey:yt,account:ar}),ur=d.type({state:d.union([d.literal("active"),d.literal("inactive"),d.literal("activating"),d.literal("deactivating")]),active:d.number(),inactive:d.number()}),lr=At(d.array(d.type({signature:d.string(),slot:d.number(),err:Pt,memo:d.nullable(d.string()),blockTime:d.optional(d.nullable(d.number()))}))),dr=At(d.array(d.type({signature:d.string(),slot:d.number(),err:Pt,memo:d.nullable(d.string()),blockTime:d.optional(d.nullable(d.number()))}))),hr=d.type({subscription:d.number(),result:Et(ir)}),br=d.type({pubkey:yt,account:ir}),pr=d.type({subscription:d.number(),result:Et(br)}),gr=d.type({parent:d.number(),slot:d.number(),root:d.number()}),yr=d.type({subscription:d.number(),result:gr}),mr=d.union([d.type({type:d.union([d.literal("firstShredReceived"),d.literal("completed"),d.literal("optimisticConfirmation"),d.literal("root")]),slot:d.number(),timestamp:d.number()}),d.type({type:d.literal("createdBank"),parent:d.number(),slot:d.number(),timestamp:d.number()}),d.type({type:d.literal("frozen"),slot:d.number(),timestamp:d.number(),stats:d.type({numTransactionEntries:d.number(),numSuccessfulTransactions:d.number(),numFailedTransactions:d.number(),maxTransactionsPerEntry:d.number()})}),d.type({type:d.literal("dead"),slot:d.number(),timestamp:d.number(),err:d.string()})]),fr=d.type({subscription:d.number(),result:mr}),kr=d.type({subscription:d.number(),result:Et(d.union([Rt,Ut]))}),wr=d.type({subscription:d.number(),result:d.number()}),Sr=d.type({pubkey:d.string(),gossip:d.nullable(d.string()),tpu:d.nullable(d.string()),rpc:d.nullable(d.string()),version:d.nullable(d.string())}),Ir=d.type({votePubkey:d.string(),nodePubkey:d.string(),activatedStake:d.number(),epochVoteAccount:d.boolean(),epochCredits:d.array(d.tuple([d.number(),d.number(),d.number()])),commission:d.number(),lastVote:d.number(),rootSlot:d.nullable(d.number())}),vr=At(d.type({current:d.array(Ir),delinquent:d.array(Ir)})),Ar=d.union([d.literal("processed"),d.literal("confirmed"),d.literal("finalized")]),_r=d.type({slot:d.number(),confirmations:d.nullable(d.number()),err:Pt,confirmationStatus:d.optional(Ar)}),Er=_t(d.array(d.nullable(_r))),Or=At(d.number()),Tr=d.type({accountKey:yt,writableIndexes:d.array(d.number()),readonlyIndexes:d.array(d.number())}),jr=d.type({signatures:d.array(d.string()),message:d.type({accountKeys:d.array(d.string()),header:d.type({numRequiredSignatures:d.number(),numReadonlySignedAccounts:d.number(),numReadonlyUnsignedAccounts:d.number()}),instructions:d.array(d.type({accounts:d.array(d.number()),data:d.string(),programIdIndex:d.number()})),recentBlockhash:d.string(),addressTableLookups:d.optional(d.array(Tr))})}),Br=d.type({pubkey:yt,signer:d.boolean(),writable:d.boolean(),source:d.optional(d.union([d.literal("transaction"),d.literal("lookupTable")]))}),Nr=d.type({accountKeys:d.array(Br),signatures:d.array(d.string())}),Mr=d.type({parsed:d.unknown(),program:d.string(),programId:yt}),xr=d.type({accounts:d.array(yt),data:d.string(),programId:yt}),Lr=d.union([xr,Mr]),Pr=d.union([d.type({parsed:d.unknown(),program:d.string(),programId:d.string()}),d.type({accounts:d.array(d.string()),data:d.string(),programId:d.string()})]),Rr=d.coerce(Lr,Pr,e=>"accounts"in e?d.create(e,xr):d.create(e,Mr)),Ur=d.type({signatures:d.array(d.string()),message:d.type({accountKeys:d.array(Br),instructions:d.array(Rr),recentBlockhash:d.string(),addressTableLookups:d.optional(d.nullable(d.array(Tr)))})}),zr=d.type({accountIndex:d.number(),mint:d.string(),owner:d.optional(d.string()),uiTokenAmount:Xt}),Wr=d.type({writable:d.array(yt),readonly:d.array(yt)}),Cr=d.type({err:Pt,fee:d.number(),innerInstructions:d.optional(d.nullable(d.array(d.type({index:d.number(),instructions:d.array(d.type({accounts:d.array(d.number()),data:d.string(),programIdIndex:d.number()}))})))),preBalances:d.array(d.number()),postBalances:d.array(d.number()),logMessages:d.optional(d.nullable(d.array(d.string()))),preTokenBalances:d.optional(d.nullable(d.array(zr))),postTokenBalances:d.optional(d.nullable(d.array(zr))),loadedAddresses:d.optional(Wr),computeUnitsConsumed:d.optional(d.number())}),Dr=d.type({err:Pt,fee:d.number(),innerInstructions:d.optional(d.nullable(d.array(d.type({index:d.number(),instructions:d.array(Rr)})))),preBalances:d.array(d.number()),postBalances:d.array(d.number()),logMessages:d.optional(d.nullable(d.array(d.string()))),preTokenBalances:d.optional(d.nullable(d.array(zr))),postTokenBalances:d.optional(d.nullable(d.array(zr))),loadedAddresses:d.optional(Wr),computeUnitsConsumed:d.optional(d.number())}),Fr=d.union([d.literal(0),d.literal("legacy")]),Vr=d.type({pubkey:d.string(),lamports:d.number(),postBalance:d.nullable(d.number()),rewardType:d.nullable(d.string()),commission:d.optional(d.nullable(d.number()))}),Kr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:jr,meta:d.nullable(Cr),version:d.optional(Fr)})),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Qr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Hr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:Nr,meta:d.nullable(Cr),version:d.optional(Fr)})),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Zr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:Ur,meta:d.nullable(Dr),version:d.optional(Fr)})),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),qr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:Nr,meta:d.nullable(Dr),version:d.optional(Fr)})),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Yr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Gr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:jr,meta:d.nullable(Cr)})),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number())}))),Jr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),signatures:d.array(d.string()),blockTime:d.nullable(d.number())}))),Xr=At(d.nullable(d.type({slot:d.number(),meta:d.nullable(Cr),blockTime:d.optional(d.nullable(d.number())),transaction:jr,version:d.optional(Fr)}))),$r=At(d.nullable(d.type({slot:d.number(),transaction:Ur,meta:d.nullable(Dr),blockTime:d.optional(d.nullable(d.number())),version:d.optional(Fr)}))),en=_t(d.type({blockhash:d.string(),feeCalculator:d.type({lamportsPerSignature:d.number()})})),tn=_t(d.type({blockhash:d.string(),lastValidBlockHeight:d.number()})),rn=_t(d.boolean()),nn=d.type({slot:d.number(),numTransactions:d.number(),numSlots:d.number(),samplePeriodSecs:d.number()}),sn=At(d.array(nn)),on=_t(d.nullable(d.type({feeCalculator:d.type({lamportsPerSignature:d.number()})}))),an=At(d.string()),cn=At(d.string()),un=d.type({err:Pt,logs:d.array(d.string()),signature:d.string()}),ln=d.type({result:Et(un),subscription:d.number()}),dn={"solana-client":"js/0.0.0-development"};class hn{constructor(e,t){let r,n,i,s,o,a;this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const e={};return async t=>{var r;const{commitment:n,config:i}=St(t),s=this._buildArgs([],n,void 0,i),o=et(s);return e[o]=null!==(r=e[o])&&void 0!==r?r:(async()=>{try{const t=await this._rpcRequest("getBlockHeight",s),r=d.create(t,At(d.number()));if("error"in r)throw new at(r.error,"failed to get block height information");return r.result}finally{delete e[o]}})(),await e[o]}})(),t&&"string"===typeof t?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,r=t.wsEndpoint,n=t.httpHeaders,i=t.fetch,s=t.fetchMiddleware,o=t.disableRetryOnRateLimit,a=t.httpAgent),this._rpcEndpoint=wt(e),this._rpcWsEndpoint=r||gt(e),this._rpcClient=Dt(e,n,i,s,o,a),this._rpcRequest=Ft(this._rpcClient),this._rpcBatchRequest=Vt(this._rpcClient),this._rpcWebSocket=new ut(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgs([e.toBase58()],r,void 0,n),s=await this._rpcRequest("getBalance",i),o=d.create(s,_t(d.number()));if("error"in o)throw new at(o.error,"failed to get balance for "+e.toBase58());return o.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(e=>e.value).catch(t=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+t)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),r=d.create(t,At(d.nullable(d.number())));if("error"in r)throw new at(r.error,"failed to get block time for slot "+e);return r.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=d.create(e,At(d.number()));if("error"in t)throw new at(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=d.create(e,Gt);if("error"in t)throw new at(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};t="string"===typeof e?{commitment:e}:e?{...e,commitment:e&&e.commitment||this.commitment}:{commitment:this.commitment};const r=await this._rpcRequest("getSupply",[t]),n=d.create(r,Jt);if("error"in n)throw new at(n.error,"failed to get supply");return n.result}async getTokenSupply(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenSupply",r),i=d.create(n,_t(Xt));if("error"in i)throw new at(i.error,"failed to get token supply");return i.result}async getTokenAccountBalance(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenAccountBalance",r),i=d.create(n,_t(Xt));if("error"in i)throw new at(i.error,"failed to get token account balance");return i.result}async getTokenAccountsByOwner(e,t,r){const{commitment:n,config:i}=St(r);let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,n,"base64",i),a=await this._rpcRequest("getTokenAccountsByOwner",o),c=d.create(a,er);if("error"in c)throw new at(c.error,"failed to get token accounts owned by account "+e.toBase58());return c.result}async getParsedTokenAccountsByOwner(e,t,r){let n=[e.toBase58()];"mint"in t?n.push({mint:t.mint.toBase58()}):n.push({programId:t.programId.toBase58()});const i=this._buildArgs(n,r,"jsonParsed"),s=await this._rpcRequest("getTokenAccountsByOwner",i),o=d.create(s,rr);if("error"in o)throw new at(o.error,"failed to get token accounts owned by account "+e.toBase58());return o.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},r=t.filter||t.commitment?[t]:[],n=await this._rpcRequest("getLargestAccounts",r),i=d.create(n,nr);if("error"in i)throw new at(i.error,"failed to get largest accounts");return i.result}async getTokenLargestAccounts(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenLargestAccounts",r),i=d.create(n,$t);if("error"in i)throw new at(i.error,"failed to get token largest accounts");return i.result}async getAccountInfoAndContext(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgs([e.toBase58()],r,"base64",n),s=await this._rpcRequest("getAccountInfo",i),o=d.create(s,_t(d.nullable(ir)));if("error"in o)throw new at(o.error,"failed to get info about account "+e.toBase58());return o.result}async getParsedAccountInfo(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgs([e.toBase58()],r,"jsonParsed",n),s=await this._rpcRequest("getAccountInfo",i),o=d.create(s,_t(d.nullable(ar)));if("error"in o)throw new at(o.error,"failed to get info about account "+e.toBase58());return o.result}async getAccountInfo(e,t){try{const r=await this.getAccountInfoAndContext(e,t);return r.value}catch(r){throw new Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleParsedAccounts(e,t){const{commitment:r,config:n}=St(t),i=e.map(e=>e.toBase58()),s=this._buildArgs([i],r,"jsonParsed",n),o=await this._rpcRequest("getMultipleAccounts",s),a=d.create(o,_t(d.array(d.nullable(ar))));if("error"in a)throw new at(a.error,"failed to get info for accounts "+i);return a.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:r,config:n}=St(t),i=e.map(e=>e.toBase58()),s=this._buildArgs([i],r,"base64",n),o=await this._rpcRequest("getMultipleAccounts",s),a=d.create(o,_t(d.array(d.nullable(ir))));if("error"in a)throw new at(a.error,"failed to get info for accounts "+i);return a.result}async getMultipleAccountsInfo(e,t){const r=await this.getMultipleAccountsInfoAndContext(e,t);return r.value}async getStakeActivation(e,t,r){const{commitment:n,config:i}=St(t),s=this._buildArgs([e.toBase58()],n,void 0,{...i,epoch:null!=r?r:null===i||void 0===i?void 0:i.epoch}),o=await this._rpcRequest("getStakeActivation",s),a=d.create(o,At(ur));if("error"in a)throw new at(a.error,"failed to get Stake Activation "+e.toBase58());return a.result}async getProgramAccounts(e,t){const{commitment:r,config:n}=St(t),{encoding:i,...s}=n||{},o=this._buildArgs([e.toBase58()],r,i||"base64",s),a=await this._rpcRequest("getProgramAccounts",o),c=d.array(sr),u=!0===s.withContext?d.create(a,_t(c)):d.create(a,At(c));if("error"in u)throw new at(u.error,"failed to get accounts owned by program "+e.toBase58());return u.result}async getParsedProgramAccounts(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgs([e.toBase58()],r,"jsonParsed",n),s=await this._rpcRequest("getProgramAccounts",i),o=d.create(s,At(d.array(cr)));if("error"in o)throw new at(o.error,"failed to get accounts owned by program "+e.toBase58());return o.result}async confirmTransaction(e,t){let r,n;if("string"==typeof e)r=e;else{var i;const t=e;if(null!==(i=t.abortSignal)&&void 0!==i&&i.aborted)return Promise.reject(t.abortSignal.reason);r=t.signature}try{n=w.default.decode(r)}catch(s){throw new Error("signature must be base58 encoded: "+r)}return ae(64===n.length,"signature has invalid length"),"string"===typeof e?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:r}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,r)=>{null!=e&&(e.aborted?r(e.reason):e.addEventListener("abort",()=>{r(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let r,n,i=!1;const s=new Promise((s,o)=>{try{r=this.onSignature(t,(e,t)=>{r=void 0;const n={context:t,value:e};s({__type:he.PROCESSED,response:n})},e);const a=new Promise(e=>{null==r?e():n=this._onSubscriptionStateChange(r,t=>{"subscribed"===t&&e()})});(async()=>{if(await a,i)return;const r=await this.getSignatureStatus(t);if(i)return;if(null==r)return;const{context:n,value:c}=r;if(null!=c)if(null!==c&&void 0!==c&&c.err)o(c.err);else{switch(e){case"confirmed":case"single":case"singleGossip":if("processed"===c.confirmationStatus)return;break;case"finalized":case"max":case"root":if("processed"===c.confirmationStatus||"confirmed"===c.confirmationStatus)return;break;case"processed":case"recent":}i=!0,s({__type:he.PROCESSED,response:{context:n,value:c}})}})()}catch(a){o(a)}}),o=()=>{n&&(n(),n=void 0),null!=r&&(this.removeSignatureListener(r),r=void 0)};return{abortConfirmation:o,confirmationPromise:s}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:r,signature:n}}){let i=!1;const s=new Promise(t=>{const n=async()=>{try{const t=await this.getBlockHeight(e);return t}catch(t){return-1}};(async()=>{let e=await n();if(!i){while(e<=r){if(await Me(1e3),i)return;if(e=await n(),i)return}t({__type:he.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:o,confirmationPromise:a}=this.getTransactionConfirmationPromise({commitment:e,signature:n}),c=this.getCancellationPromise(t);let u;try{const e=await Promise.race([c,a,s]);if(e.__type!==he.PROCESSED)throw new Z(n);u=e.response}finally{i=!0,o()}return u}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:r,nonceAccountPubkey:n,nonceValue:i,signature:s}}){let o=!1;const a=new Promise(t=>{let s=i,a=null;const c=async()=>{try{const{context:t,value:i}=await this.getNonceAndContext(n,{commitment:e,minContextSlot:r});return a=t.slot,null===i||void 0===i?void 0:i.nonce}catch(t){return s}};(async()=>{if(s=await c(),!o)while(1){if(i!==s)return void t({__type:he.NONCE_INVALID,slotInWhichNonceDidAdvance:a});if(await Me(2e3),o)return;if(s=await c(),o)return}})()}),{abortConfirmation:c,confirmationPromise:u}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),l=this.getCancellationPromise(t);let d;try{const t=await Promise.race([l,u,a]);if(t.__type===he.PROCESSED)d=t.response;else{var h;let n;while(1){var b;const e=await this.getSignatureStatus(s);if(null==e)break;if(!(e.context.slot<(null!==(b=t.slotInWhichNonceDidAdvance)&&void 0!==b?b:r))){n=e;break}await Me(400)}if(null===(h=n)||void 0===h||!h.value)throw new Y(s);{const t=e||"finalized",{confirmationStatus:r}=n.value;switch(t){case"processed":case"recent":if("processed"!==r&&"confirmed"!==r&&"finalized"!==r)throw new Y(s);break;case"confirmed":case"single":case"singleGossip":if("confirmed"!==r&&"finalized"!==r)throw new Y(s);break;case"finalized":case"max":case"root":if("finalized"!==r)throw new Y(s);break;default:}d={context:n.context,value:{err:n.value.err}}}}}finally{o=!0,c()}return d}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let r;const n=new Promise(t=>{let n=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":n=this._confirmTransactionInitialTimeout||3e4;break}r=setTimeout(()=>t({__type:he.TIMED_OUT,timeoutMs:n}),n)}),{abortConfirmation:i,confirmationPromise:s}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let o;try{const e=await Promise.race([s,n]);if(e.__type!==he.PROCESSED)throw new q(t,e.timeoutMs/1e3);o=e.response}finally{clearTimeout(r),i()}return o}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=d.create(e,At(d.array(Sr)));if("error"in t)throw new at(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getVoteAccounts",t),n=d.create(r,vr);if("error"in n)throw new at(n.error,"failed to get vote accounts");return n.result}async getSlot(e){const{commitment:t,config:r}=St(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getSlot",n),s=d.create(i,At(d.number()));if("error"in s)throw new at(s.error,"failed to get slot");return s.result}async getSlotLeader(e){const{commitment:t,config:r}=St(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getSlotLeader",n),s=d.create(i,At(d.string()));if("error"in s)throw new at(s.error,"failed to get slot leader");return s.result}async getSlotLeaders(e,t){const r=[e,t],n=await this._rpcRequest("getSlotLeaders",r),i=d.create(n,At(d.array(yt)));if("error"in i)throw new at(i.error,"failed to get slot leaders");return i.result}async getSignatureStatus(e,t){const{context:r,value:n}=await this.getSignatureStatuses([e],t);ae(1===n.length);const i=n[0];return{context:r,value:i}}async getSignatureStatuses(e,t){const r=[e];t&&r.push(t);const n=await this._rpcRequest("getSignatureStatuses",r),i=d.create(n,Er);if("error"in i)throw new at(i.error,"failed to get signature status");return i.result}async getTransactionCount(e){const{commitment:t,config:r}=St(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getTransactionCount",n),s=d.create(i,At(d.number()));if("error"in s)throw new at(s.error,"failed to get transaction count");return s.result}async getTotalSupply(e){const t=await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0});return t.value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getInflationGovernor",t),n=d.create(r,Kt);if("error"in n)throw new at(n.error,"failed to get inflation");return n.result}async getInflationReward(e,t,r){const{commitment:n,config:i}=St(r),s=this._buildArgs([e.map(e=>e.toBase58())],n,void 0,{...i,epoch:null!=t?t:null===i||void 0===i?void 0:i.epoch}),o=await this._rpcRequest("getInflationReward",s),a=d.create(o,jt);if("error"in a)throw new at(a.error,"failed to get inflation reward");return a.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=d.create(e,Qt);if("error"in t)throw new at(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:r}=St(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getEpochInfo",n),s=d.create(i,Zt);if("error"in s)throw new at(s.error,"failed to get epoch info");return s.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=d.create(e,qt);if("error"in t)throw new at(t.error,"failed to get epoch schedule");const r=t.result;return new it(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=d.create(e,Yt);if("error"in t)throw new at(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getMinimumBalanceForRentExemption",r),i=d.create(n,Or);return"error"in i?0:i.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getRecentBlockhash",t),n=d.create(r,en);if("error"in n)throw new at(n.error,"failed to get recent blockhash");return n.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),r=d.create(t,sn);if("error"in r)throw new at(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getFeeCalculatorForBlockhash",r),i=d.create(n,on);if("error"in i)throw new at(i.error,"failed to get fee calculator");const{context:s,value:o}=i.result;return{context:s,value:null!==o?o.feeCalculator:null}}async getFeeForMessage(e,t){const r=N(e.serialize()).toString("base64"),n=this._buildArgs([r],t),i=await this._rpcRequest("getFeeForMessage",n),s=d.create(i,_t(d.nullable(d.number())));if("error"in s)throw new at(s.error,"failed to get fee for message");if(null===s.result)throw new Error("invalid blockhash");return s.result}async getRecentPrioritizationFees(e){var t;const r=null===e||void 0===e||null===(t=e.lockedWritableAccounts)||void 0===t?void 0:t.map(e=>e.toBase58()),n=null!==r&&void 0!==r&&r.length?[r]:[],i=await this._rpcRequest("getRecentPrioritizationFees",n),s=d.create(i,Ht);if("error"in s)throw new at(s.error,"failed to get recent prioritization fees");return s.result}async getRecentBlockhash(e){try{const t=await this.getRecentBlockhashAndContext(e);return t.value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{const t=await this.getLatestBlockhashAndContext(e);return t.value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:r}=St(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getLatestBlockhash",n),s=d.create(i,tn);if("error"in s)throw new at(s.error,"failed to get latest blockhash");return s.result}async isBlockhashValid(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgs([e],r,void 0,n),s=await this._rpcRequest("isBlockhashValid",i),o=d.create(s,rn);if("error"in o)throw new at(o.error,"failed to determine if the blockhash `"+e+"`is valid");return o.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=d.create(e,At(zt));if("error"in t)throw new at(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=d.create(e,At(d.string()));if("error"in t)throw new at(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgsAtLeastConfirmed([e],r,void 0,n),s=await this._rpcRequest("getBlock",i);try{switch(null===n||void 0===n?void 0:n.transactionDetails){case"accounts":{const e=d.create(s,Hr);if("error"in e)throw e.error;return e.result}case"none":{const e=d.create(s,Qr);if("error"in e)throw e.error;return e.result}default:{const e=d.create(s,Kr);if("error"in e)throw e.error;const{result:t}=e;return t?{...t,transactions:t.transactions.map(({transaction:e,meta:t,version:r})=>({meta:t,transaction:{...e,message:Ot(r,e.message)},version:r}))}:null}}}catch(o){throw new at(o,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),s=await this._rpcRequest("getBlock",i);try{switch(null===n||void 0===n?void 0:n.transactionDetails){case"accounts":{const e=d.create(s,qr);if("error"in e)throw e.error;return e.result}case"none":{const e=d.create(s,Yr);if("error"in e)throw e.error;return e.result}default:{const e=d.create(s,Zr);if("error"in e)throw e.error;return e.result}}}catch(o){throw new at(o,"failed to get block")}}async getBlockProduction(e){let t,r;if("string"===typeof e)r=e;else if(e){const{commitment:n,...i}=e;r=n,t=i}const n=this._buildArgs([],r,"base64",t),i=await this._rpcRequest("getBlockProduction",n),s=d.create(i,Ct);if("error"in s)throw new at(s.error,"failed to get block production information");return s.result}async getTransaction(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgsAtLeastConfirmed([e],r,void 0,n),s=await this._rpcRequest("getTransaction",i),o=d.create(s,Xr);if("error"in o)throw new at(o.error,"failed to get transaction");const a=o.result;return a?{...a,transaction:{...a.transaction,message:Ot(a.version,a.transaction.message)}}:a}async getParsedTransaction(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),s=await this._rpcRequest("getTransaction",i),o=d.create(s,$r);if("error"in o)throw new at(o.error,"failed to get transaction");return o.result}async getParsedTransactions(e,t){const{commitment:r,config:n}=St(t),i=e.map(e=>{const t=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n);return{methodName:"getTransaction",args:t}}),s=await this._rpcBatchRequest(i),o=s.map(e=>{const t=d.create(e,$r);if("error"in t)throw new at(t.error,"failed to get transactions");return t.result});return o}async getTransactions(e,t){const{commitment:r,config:n}=St(t),i=e.map(e=>{const t=this._buildArgsAtLeastConfirmed([e],r,void 0,n);return{methodName:"getTransaction",args:t}}),s=await this._rpcBatchRequest(i),o=s.map(e=>{const t=d.create(e,Xr);if("error"in t)throw new at(t.error,"failed to get transactions");const r=t.result;return r?{...r,transaction:{...r.transaction,message:Ot(r.version,r.transaction.message)}}:r});return o}async getConfirmedBlock(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedBlock",r),i=d.create(n,Gr);if("error"in i)throw new at(i.error,"failed to get confirmed block");const s=i.result;if(!s)throw new Error("Confirmed block "+e+" not found");const o={...s,transactions:s.transactions.map(({transaction:e,meta:t})=>{const r=new ue(e.message);return{meta:t,transaction:{...e,message:r}}})};return{...o,transactions:o.transactions.map(({transaction:e,meta:t})=>({meta:t,transaction:ge.populate(e.message,e.signatures)}))}}async getBlocks(e,t,r){const n=this._buildArgsAtLeastConfirmed(void 0!==t?[e,t]:[e],r),i=await this._rpcRequest("getBlocks",n),s=d.create(i,At(d.array(d.number())));if("error"in s)throw new at(s.error,"failed to get blocks");return s.result}async getBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getBlock",r),i=d.create(n,Jr);if("error"in i)throw new at(i.error,"failed to get block");const s=i.result;if(!s)throw new Error("Block "+e+" not found");return s}async getConfirmedBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getConfirmedBlock",r),i=d.create(n,Jr);if("error"in i)throw new at(i.error,"failed to get confirmed block");const s=i.result;if(!s)throw new Error("Confirmed block "+e+" not found");return s}async getConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedTransaction",r),i=d.create(n,Xr);if("error"in i)throw new at(i.error,"failed to get transaction");const s=i.result;if(!s)return s;const o=new ue(s.transaction.message),a=s.transaction.signatures;return{...s,transaction:ge.populate(o,a)}}async getParsedConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),n=await this._rpcRequest("getConfirmedTransaction",r),i=d.create(n,$r);if("error"in i)throw new at(i.error,"failed to get confirmed transaction");return i.result}async getParsedConfirmedTransactions(e,t){const r=e.map(e=>{const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed");return{methodName:"getConfirmedTransaction",args:r}}),n=await this._rpcBatchRequest(r),i=n.map(e=>{const t=d.create(e,$r);if("error"in t)throw new at(t.error,"failed to get confirmed transactions");return t.result});return i}async getConfirmedSignaturesForAddress(e,t,r){let n={},i=await this.getFirstAvailableBlock();while(!("until"in n)){if(t--,t<=0||t<i)break;try{const e=await this.getConfirmedBlockSignatures(t,"finalized");e.signatures.length>0&&(n.until=e.signatures[e.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}}let s=await this.getSlot("finalized");while(!("before"in n)){if(r++,r>s)break;try{const e=await this.getConfirmedBlockSignatures(r);e.signatures.length>0&&(n.before=e.signatures[e.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}}const o=await this.getConfirmedSignaturesForAddress2(e,n);return o.map(e=>e.signature)}async getConfirmedSignaturesForAddress2(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),i=await this._rpcRequest("getConfirmedSignaturesForAddress2",n),s=d.create(i,lr);if("error"in s)throw new at(s.error,"failed to get confirmed signatures for address");return s.result}async getSignaturesForAddress(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),i=await this._rpcRequest("getSignaturesForAddress",n),s=d.create(i,dr);if("error"in s)throw new at(s.error,"failed to get signatures for address");return s.result}async getAddressLookupTable(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let i=null;return null!==n&&(i=new ht({key:e,state:ht.deserialize(n.data)})),{context:r,value:i}}async getNonceAndContext(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let i=null;return null!==n&&(i=ze.fromAccountData(n.data)),{context:r,value:i}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(e=>e.value).catch(t=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+t)})}async requestAirdrop(e,t){const r=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),n=d.create(r,an);if("error"in n)throw new at(n.error,`airdrop to ${e.toBase58()} failed`);return n.result}async _blockhashWithExpiryBlockHeight(e){if(!e){while(this._pollingBlockhash)await Me(100);const e=Date.now()-this._blockhashInfo.lastFetch,t=e>=kt;if(null!==this._blockhashInfo.latestBlockhash&&!t)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,r=t?t.blockhash:null;for(let n=0;n<50;n++){const e=await this.getLatestBlockhash("finalized");if(r!==e.blockhash)return this._blockhashInfo={latestBlockhash:e,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},e;await Me(Se/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:r}=St(e),n=this._buildArgs([],t,"base64",r),i=await this._rpcRequest("getStakeMinimumDelegation",n),s=d.create(i,_t(d.number()));if("error"in s)throw new at(s.error,"failed to get stake minimum delegation");return s.result}async simulateTransaction(e,t,r){if("message"in e){const i=e,s=i.serialize(),o=n.Buffer.from(s).toString("base64");if(Array.isArray(t)||void 0!==r)throw new Error("Invalid arguments");const a=t||{};a.encoding="base64","commitment"in a||(a.commitment=this.commitment);const c=[o,a],u=await this._rpcRequest("simulateTransaction",c),l=d.create(u,Wt);if("error"in l)throw new Error("failed to simulate transaction: "+l.error.message);return l.result}let i;if(e instanceof ge){let t=e;i=new ge,i.feePayer=t.feePayer,i.instructions=e.instructions,i.nonceInfo=t.nonceInfo,i.signatures=t.signatures}else i=ge.populate(e),i._message=i._json=void 0;if(void 0!==t&&!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(i.nonceInfo&&s)i.sign(...s);else{let e=this._disableBlockhashCaching;for(;;){const t=await this._blockhashWithExpiryBlockHeight(e);if(i.lastValidBlockHeight=t.lastValidBlockHeight,i.recentBlockhash=t.blockhash,!s)break;if(i.sign(...s),!i.signature)throw new Error("!signature");const r=i.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(r)&&!this._blockhashInfo.transactionSignatures.includes(r)){this._blockhashInfo.simulatedSignatures.push(r);break}e=!0}}const o=i._compile(),a=o.serialize(),c=i._serialize(a),u=c.toString("base64"),l={encoding:"base64",commitment:this.commitment};if(r){const e=(Array.isArray(r)?r:o.nonProgramIds()).map(e=>e.toBase58());l["accounts"]={encoding:"base64",addresses:e}}s&&(l.sigVerify=!0);const h=[u,l],b=await this._rpcRequest("simulateTransaction",h),p=d.create(b,Wt);if("error"in p){let e;if("data"in p.error&&(e=p.error.data.logs,e&&Array.isArray(e))){const t="\n    ";e.join(t)}throw new st("failed to simulate transaction: "+p.error.message,e)}return p.result}async sendTransaction(e,t,r){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const r=e.serialize();return await this.sendRawTransaction(r,t)}if(void 0===t||!Array.isArray(t))throw new Error("Invalid arguments");const n=t;if(e.nonceInfo)e.sign(...n);else{let t=this._disableBlockhashCaching;for(;;){const r=await this._blockhashWithExpiryBlockHeight(t);if(e.lastValidBlockHeight=r.lastValidBlockHeight,e.recentBlockhash=r.blockhash,e.sign(...n),!e.signature)throw new Error("!signature");const i=e.signature.toString("base64");if(!this._blockhashInfo.transactionSignatures.includes(i)){this._blockhashInfo.transactionSignatures.push(i);break}t=!0}}const i=e.serialize();return await this.sendRawTransaction(i,r)}async sendRawTransaction(e,t){const r=N(e).toString("base64"),n=await this.sendEncodedTransaction(r,t);return n}async sendEncodedTransaction(e,t){const r={encoding:"base64"},n=t&&t.skipPreflight,i=t&&t.preflightCommitment||this.commitment;t&&null!=t.maxRetries&&(r.maxRetries=t.maxRetries),t&&null!=t.minContextSlot&&(r.minContextSlot=t.minContextSlot),n&&(r.skipPreflight=n),i&&(r.preflightCommitment=i);const s=[e,r],o=await this._rpcRequest("sendTransaction",s),a=d.create(o,cn);if("error"in a){let e;throw"data"in a.error&&(e=a.error.data.logs),new st("failed to send transaction: "+a.error.message,e)}return a.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1}_wsOnClose(e){this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),1e3!==e?(this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([e,t])=>{this._setSubscription(e,{...t,state:"pending"})})):this._updateSubscriptions()}_setSubscription(e,t){var r;const n=null===(r=this._subscriptionsByHash[e])||void 0===r?void 0:r.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const r=this._subscriptionStateChangeCallbacksByHash[e];r&&r.forEach(e=>{try{e(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var r;const n=this._subscriptionHashByClientSubscriptionId[e];if(null==n)return()=>{};const i=(r=this._subscriptionStateChangeCallbacksByHash)[n]||(r[n]=new Set);return i.add(t),()=>{i.delete(t),0===i.size&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(0===Object.keys(this._subscriptionsByHash).length)return void(this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(e){Error}},500)));if(null!==this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected)return void this._rpcWebSocket.connect();const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async e=>{const r=this._subscriptionsByHash[e];if(void 0!==r)switch(r.state){case"pending":case"unsubscribed":if(0===r.callbacks.size)return delete this._subscriptionsByHash[e],"unsubscribed"===r.state&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],void await this._updateSubscriptions();await(async()=>{const{args:n,method:i}=r;try{this._setSubscription(e,{...r,state:"subscribing"});const t=await this._rpcWebSocket.call(i,n);this._setSubscription(e,{...r,serverSubscriptionId:t,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[t]=r.callbacks,await this._updateSubscriptions()}catch(s){if(Error,!t())return;this._setSubscription(e,{...r,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":0===r.callbacks.size&&await(async()=>{const{serverSubscriptionId:n,unsubscribeMethod:i}=r;if(this._subscriptionsAutoDisposedByRpc.has(n))this._subscriptionsAutoDisposedByRpc.delete(n);else{this._setSubscription(e,{...r,state:"unsubscribing"}),this._setSubscription(e,{...r,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[n])}catch(s){if(Error,!t())return;return this._setSubscription(e,{...r,state:"subscribed"}),void await this._updateSubscriptions()}}this._setSubscription(e,{...r,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const r=this._subscriptionCallbacksByServerSubscriptionId[e];void 0!==r&&r.forEach(e=>{try{e(...t)}catch(r){}})}_wsOnAccountNotification(e){const{result:t,subscription:r}=d.create(e,hr);this._handleServerNotification(r,[t.value,t.context])}_makeSubscription(e,t){const r=this._nextClientSubscriptionId++,n=et([e.method,t],!0),i=this._subscriptionsByHash[n];return void 0===i?this._subscriptionsByHash[n]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:i.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[r]=n,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const t=this._subscriptionsByHash[n];ae(void 0!==t,"Could not find a `Subscription` when tearing down client subscription #"+r),t.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(e,t,r){const n=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},n)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:r}=d.create(e,pr);this._handleServerNotification(r,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,r,n){const i=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",n?{filters:n}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},i)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,r){const n=this._buildArgs(["object"===typeof e?{mentions:[e.toString()]}:e],r||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},n)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:r}=d.create(e,ln);this._handleServerNotification(r,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:r}=d.create(e,yr);this._handleServerNotification(r,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:r}=d.create(e,fr);this._handleServerNotification(r,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];r&&await r()}_buildArgs(e,t,r,n){const i=t||this._commitment;if(i||r||n){let t={};r&&(t.encoding=r),i&&(t.commitment=i),n&&(t=Object.assign(t,n)),e.push(t)}return e}_buildArgsAtLeastConfirmed(e,t,r,n){const i=t||this._commitment;if(i&&!["confirmed","finalized"].includes(i))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,r,n)}_wsOnSignatureNotification(e){const{result:t,subscription:r}=d.create(e,kr);"receivedSignature"!==t.value&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,"receivedSignature"===t.value?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,r){const n=this._buildArgs([e],r||this._commitment||"finalized"),i=this._makeSubscription({callback:(e,r)=>{if("status"===e.type){t(e.result,r);try{this.removeSignatureListener(i)}catch(n){}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},n);return i}onSignatureWithOptions(e,t,r){const{commitment:n,...i}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},s=this._buildArgs([e],n,void 0,i),o=this._makeSubscription({callback:(e,r)=>{t(e,r);try{this.removeSignatureListener(o)}catch(n){}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:r}=d.create(e,wr);this._handleServerNotification(r,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class bn{constructor(e){this._keypair=void 0,this._keypair=null!==e&&void 0!==e?e:E()}static generate(){return new bn(E())}static fromSecretKey(e,t){if(64!==e.byteLength)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const t=e.slice(0,32),n=O(t);for(let e=0;e<32;e++)if(r[e]!==n[e])throw new Error("provided secretKey is invalid")}return new bn({publicKey:r,secretKey:e})}static fromSeed(e){const t=O(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new bn({publicKey:t,secretKey:r})}get publicKey(){return new D(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const pn=Object.freeze({CreateLookupTable:{index:0,layout:S.struct([S.u32("instruction"),De("recentSlot"),S.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:S.struct([S.u32("instruction")])},ExtendLookupTable:{index:2,layout:S.struct([S.u32("instruction"),De(),S.seq(J(),S.offset(S.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:S.struct([S.u32("instruction")])},CloseLookupTable:{index:4,layout:S.struct([S.u32("instruction")])}});class gn{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=S.u32("instruction"),r=t.decode(e.data);let n;for(const[i,s]of Object.entries(pn))if(s.index==r){n=i;break}if(!n)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return n}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:t}=Le(pn.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:t}=Le(pn.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(e=>new D(e))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(yn.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}class yn{constructor(){}static createLookupTable(e){const[t,r]=D.findProgramAddressSync([e.authority.toBuffer(),l.toBufferLE(BigInt(e.recentSlot),8)],this.programId),n=pn.CreateLookupTable,i=xe(n,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),s=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Ke.programId,isSigner:!1,isWritable:!1}];return[new pe({programId:this.programId,keys:s,data:i}),t]}static freezeLookupTable(e){const t=pn.FreezeLookupTable,r=xe(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new pe({programId:this.programId,keys:n,data:r})}static extendLookupTable(e){const t=pn.ExtendLookupTable,r=xe(t,{addresses:e.addresses.map(e=>e.toBytes())}),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&n.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Ke.programId,isSigner:!1,isWritable:!1}),new pe({programId:this.programId,keys:n,data:r})}static deactivateLookupTable(e){const t=pn.DeactivateLookupTable,r=xe(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new pe({programId:this.programId,keys:n,data:r})}static closeLookupTable(e){const t=pn.CloseLookupTable,r=xe(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new pe({programId:this.programId,keys:n,data:r})}}yn.programId=new D("AddressLookupTab1e1111111111111111111111111");class mn{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=S.u8("instruction"),r=t.decode(e.data);let n;for(const[i,s]of Object.entries(fn))if(s.index==r){n=i;break}if(!n)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return n}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:r}=Le(fn.RequestUnits,e.data);return{units:t,additionalFee:r}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=Le(fn.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=Le(fn.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=Le(fn.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(kn.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const fn=Object.freeze({RequestUnits:{index:0,layout:S.struct([S.u8("instruction"),S.u32("units"),S.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:S.struct([S.u8("instruction"),S.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:S.struct([S.u8("instruction"),S.u32("units")])},SetComputeUnitPrice:{index:3,layout:S.struct([S.u8("instruction"),De("microLamports")])}});class kn{constructor(){}static requestUnits(e){const t=fn.RequestUnits,r=xe(t,e);return new pe({keys:[],programId:this.programId,data:r})}static requestHeapFrame(e){const t=fn.RequestHeapFrame,r=xe(t,e);return new pe({keys:[],programId:this.programId,data:r})}static setComputeUnitLimit(e){const t=fn.SetComputeUnitLimit,r=xe(t,e);return new pe({keys:[],programId:this.programId,data:r})}static setComputeUnitPrice(e){const t=fn.SetComputeUnitPrice,r=xe(t,{microLamports:BigInt(e.microLamports)});return new pe({keys:[],programId:this.programId,data:r})}}kn.programId=new D("ComputeBudget111111111111111111111111111111");const wn=64,Sn=32,In=64,vn=S.struct([S.u8("numSignatures"),S.u8("padding"),S.u16("signatureOffset"),S.u16("signatureInstructionIndex"),S.u16("publicKeyOffset"),S.u16("publicKeyInstructionIndex"),S.u16("messageDataOffset"),S.u16("messageDataSize"),S.u16("messageInstructionIndex")]);class An{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:i,instructionIndex:s}=e;ae(t.length===Sn,`Public Key must be ${Sn} bytes but received ${t.length} bytes`),ae(i.length===In,`Signature must be ${In} bytes but received ${i.length} bytes`);const o=vn.span,a=o+t.length,c=a+i.length,u=1,l=n.Buffer.alloc(c+r.length),d=null==s?65535:s;return vn.encode({numSignatures:u,padding:0,signatureOffset:a,signatureInstructionIndex:d,publicKeyOffset:o,publicKeyInstructionIndex:d,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:d},l),l.fill(t,o),l.fill(i,a),l.fill(r,c),new pe({keys:[],programId:An.programId,data:l})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;ae(t.length===wn,`Private key must be ${wn} bytes but received ${t.length} bytes`);try{const e=bn.fromSecretKey(t),i=e.publicKey.toBytes(),s=j(r,e.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:s,instructionIndex:n})}catch(i){throw new Error("Error creating instruction; "+i)}}}An.programId=new D("Ed25519SigVerify111111111111111111111111111");const _n=(e,t)=>{const r=y.secp256k1.sign(e,t);return[r.toCompactRawBytes(),r.recovery]};y.secp256k1.utils.isValidPrivateKey;const En=y.secp256k1.getPublicKey,On=32,Tn=20,jn=64,Bn=11,Nn=S.struct([S.u8("numSignatures"),S.u16("signatureOffset"),S.u8("signatureInstructionIndex"),S.u16("ethAddressOffset"),S.u8("ethAddressInstructionIndex"),S.u16("messageDataOffset"),S.u16("messageDataSize"),S.u8("messageInstructionIndex"),S.blob(20,"ethAddress"),S.blob(64,"signature"),S.u8("recoveryId")]);class Mn{constructor(){}static publicKeyToEthAddress(e){ae(e.length===jn,`Public key must be ${jn} bytes but received ${e.length} bytes`);try{return n.Buffer.from(g.keccak_256(N(e))).slice(-Tn)}catch(t){throw new Error("Error constructing Ethereum address: "+t)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,recoveryId:i,instructionIndex:s}=e;return Mn.createInstructionWithEthAddress({ethAddress:Mn.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:i,instructionIndex:s})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:i,recoveryId:s,instructionIndex:o=0}=e;let a;a="string"===typeof t?t.startsWith("0x")?n.Buffer.from(t.substr(2),"hex"):n.Buffer.from(t,"hex"):t,ae(a.length===Tn,`Address must be ${Tn} bytes but received ${a.length} bytes`);const c=1+Bn,u=c,l=c+a.length,d=l+i.length+1,h=1,b=n.Buffer.alloc(Nn.span+r.length);return Nn.encode({numSignatures:h,signatureOffset:l,signatureInstructionIndex:o,ethAddressOffset:u,ethAddressInstructionIndex:o,messageDataOffset:d,messageDataSize:r.length,messageInstructionIndex:o,signature:N(i),ethAddress:N(a),recoveryId:s},b),b.fill(N(r),Nn.span),new pe({keys:[],programId:Mn.programId,data:b})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:i}=e;ae(t.length===On,`Private key must be ${On} bytes but received ${t.length} bytes`);try{const e=N(t),s=En(e,!1).slice(1),o=n.Buffer.from(g.keccak_256(N(r))),[a,c]=_n(o,e);return this.createInstructionWithPublicKey({publicKey:s,message:r,signature:a,recoveryId:c,instructionIndex:i})}catch(s){throw new Error("Error creating instruction; "+s)}}}var xn;Mn.programId=new D("KeccakSecp256k11111111111111111111111111111");const Ln=new D("StakeConfig11111111111111111111111111111111");class Pn{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class Rn{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}xn=Rn,Rn.default=new xn(0,0,D.default);class Un{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=S.u32("instruction"),r=t.decode(e.data);let n;for(const[i,s]of Object.entries(zn))if(s.index==r){n=i;break}if(!n)throw new Error("Instruction type incorrect; not a StakeInstruction");return n}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:r}=Le(zn.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new Pn(new D(t.staker),new D(t.withdrawer)),lockup:new Rn(r.unixTimestamp,r.epoch,new D(r.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),Le(zn.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:r}=Le(zn.Authorize,e.data),n={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new D(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(n.custodianPubkey=e.keys[3].pubkey),n}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:r,authoritySeed:n,authorityOwner:i}=Le(zn.AuthorizeWithSeed,e.data),s={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:n,authorityOwner:new D(i),newAuthorizedPubkey:new D(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(s.custodianPubkey=e.keys[3].pubkey),s}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=Le(zn.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),Le(zn.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=Le(zn.Withdraw,e.data),r={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(r.custodianPubkey=e.keys[5].pubkey),r}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),Le(zn.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(Cn.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const zn=Object.freeze({Initialize:{index:0,layout:S.struct([S.u32("instruction"),ee(),te()])},Authorize:{index:1,layout:S.struct([S.u32("instruction"),J("newAuthorized"),S.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:S.struct([S.u32("instruction")])},Split:{index:3,layout:S.struct([S.u32("instruction"),S.ns64("lamports")])},Withdraw:{index:4,layout:S.struct([S.u32("instruction"),S.ns64("lamports")])},Deactivate:{index:5,layout:S.struct([S.u32("instruction")])},Merge:{index:7,layout:S.struct([S.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:S.struct([S.u32("instruction"),J("newAuthorized"),S.u32("stakeAuthorizationType"),$("authoritySeed"),J("authorityOwner")])}}),Wn=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class Cn{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:n}=e,i=n||Rn.default,s=zn.Initialize,o=xe(s,{authorized:{staker:N(r.staker.toBuffer()),withdrawer:N(r.withdrawer.toBuffer())},lockup:{unixTimestamp:i.unixTimestamp,epoch:i.epoch,custodian:N(i.custodian.toBuffer())}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ee,isSigner:!1,isWritable:!1}],programId:this.programId,data:o};return new pe(a)}static createAccountWithSeed(e){const t=new ge;t.add(Ke.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:i}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:i}))}static createAccount(e){const t=new ge;t.add(Ke.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:i}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:i}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,i=zn.Delegate,s=xe(i);return(new ge).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:Be,isSigner:!1,isWritable:!1},{pubkey:Ln,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:i,custodianPubkey:s}=e,o=zn.Authorize,a=xe(o,{newAuthorized:N(n.toBuffer()),stakeAuthorizationType:i.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ie,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return s&&c.push({pubkey:s,isSigner:!0,isWritable:!1}),(new ge).add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:i,newAuthorizedPubkey:s,stakeAuthorizationType:o,custodianPubkey:a}=e,c=zn.AuthorizeWithSeed,u=xe(c,{newAuthorized:N(s.toBuffer()),stakeAuthorizationType:o.index,authoritySeed:n,authorityOwner:N(i.toBuffer())}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:Ie,isSigner:!1,isWritable:!1}];return a&&l.push({pubkey:a,isSigner:!0,isWritable:!1}),(new ge).add({keys:l,programId:this.programId,data:u})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:i}=e,s=zn.Split,o=xe(s,{lamports:i});return new pe({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static split(e,t){const r=new ge;return r.add(Ke.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),r.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:i,basePubkey:s,seed:o,lamports:a}=e,c=new ge;return c.add(Ke.allocate({accountPubkey:i,basePubkey:s,seed:o,space:this.space,programId:this.programId})),t&&t>0&&c.add(Ke.transfer({fromPubkey:e.authorizedPubkey,toPubkey:i,lamports:t})),c.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:n,splitStakePubkey:i,lamports:a}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,i=zn.Merge,s=xe(i);return(new ge).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:Be,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:i,custodianPubkey:s}=e,o=zn.Withdraw,a=xe(o,{lamports:i}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:Be,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return s&&c.push({pubkey:s,isSigner:!0,isWritable:!1}),(new ge).add({keys:c,programId:this.programId,data:a})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,n=zn.Deactivate,i=xe(n);return(new ge).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}}Cn.programId=new D("Stake11111111111111111111111111111111111111"),Cn.space=200;class Dn{constructor(e,t,r,n){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=r,this.commission=n}}class Fn{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=S.u32("instruction"),r=t.decode(e.data);let n;for(const[i,s]of Object.entries(Vn))if(s.index==r){n=i;break}if(!n)throw new Error("Instruction type incorrect; not a VoteInstruction");return n}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=Le(Vn.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new Dn(new D(t.nodePubkey),new D(t.authorizedVoter),new D(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:r}=Le(Vn.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new D(t),voteAuthorizationType:{index:r}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:r,newAuthorized:n,voteAuthorizationType:i}}=Le(Vn.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new D(t),currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:new D(n),voteAuthorizationType:{index:i},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=Le(Vn.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Qn.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const Vn=Object.freeze({InitializeAccount:{index:0,layout:S.struct([S.u32("instruction"),re()])},Authorize:{index:1,layout:S.struct([S.u32("instruction"),J("newAuthorized"),S.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:S.struct([S.u32("instruction"),S.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:S.struct([S.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:S.struct([S.u32("instruction"),ne()])}}),Kn=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class Qn{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:n}=e,i=Vn.InitializeAccount,s=xe(i,{voteInit:{nodePubkey:N(n.nodePubkey.toBuffer()),authorizedVoter:N(n.authorizedVoter.toBuffer()),authorizedWithdrawer:N(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),o={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ee,isSigner:!1,isWritable:!1},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s};return new pe(o)}static createAccount(e){const t=new ge;return t.add(Ke.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:i}=e,s=Vn.Authorize,o=xe(s,{newAuthorized:N(n.toBuffer()),voteAuthorizationType:i.index}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ge).add({keys:a,programId:this.programId,data:o})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:i,voteAuthorizationType:s,votePubkey:o}=e,a=Vn.AuthorizeWithSeed,c=xe(a,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:N(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:N(i.toBuffer()),voteAuthorizationType:s.index}}),u=[{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return(new ge).add({keys:u,programId:this.programId,data:c})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:i}=e,s=Vn.Withdraw,o=xe(s,{lamports:n}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ge).add({keys:a,programId:this.programId,data:o})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return Qn.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,nodePubkey:n}=e,i=Vn.UpdateValidatorIdentity,s=xe(i),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ge).add({keys:o,programId:this.programId,data:s})}}Qn.programId=new D("Vote111111111111111111111111111111111111111"),Qn.space=3762;const Hn=new D("Va1idator1nfo111111111111111111111111111111"),Zn=d.type({name:d.string(),website:d.optional(d.string()),details:d.optional(d.string()),keybaseUsername:d.optional(d.string())});class qn{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];const r=se(t);if(2!==r)return null;const i=[];for(let n=0;n<2;n++){const e=new D(t.splice(0,z)),r=1===t.splice(0,1)[0];i.push({publicKey:e,isSigner:r})}if(i[0].publicKey.equals(Hn)&&i[1].isSigner){const e=$().decode(n.Buffer.from(t)),r=JSON.parse(e);return d.assert(r,Zn),new qn(i[1].publicKey,r)}return null}}const Yn=new D("Vote111111111111111111111111111111111111111"),Gn=S.struct([J("nodePubkey"),J("authorizedWithdrawer"),S.u8("commission"),S.nu64(),S.seq(S.struct([S.nu64("slot"),S.u32("confirmationCount")]),S.offset(S.u32(),-8),"votes"),S.u8("rootSlotValid"),S.nu64("rootSlot"),S.nu64(),S.seq(S.struct([S.nu64("epoch"),J("authorizedVoter")]),S.offset(S.u32(),-8),"authorizedVoters"),S.struct([S.seq(S.struct([J("authorizedPubkey"),S.nu64("epochOfLastAuthorizedSwitch"),S.nu64("targetEpoch")]),32,"buf"),S.nu64("idx"),S.u8("isEmpty")],"priorVoters"),S.nu64(),S.seq(S.struct([S.nu64("epoch"),S.nu64("credits"),S.nu64("prevCredits")]),S.offset(S.u32(),-8),"epochCredits"),S.struct([S.nu64("slot"),S.nu64("timestamp")],"lastTimestamp")]);class Jn{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const t=4,r=Gn.decode(N(e),t);let n=r.rootSlot;return r.rootSlotValid||(n=null),new Jn({nodePubkey:new D(r.nodePubkey),authorizedWithdrawer:new D(r.authorizedWithdrawer),commission:r.commission,votes:r.votes,rootSlot:n,authorizedVoters:r.authorizedVoters.map(Xn),priorVoters:ei(r.priorVoters),epochCredits:r.epochCredits,lastTimestamp:r.lastTimestamp})}}function Xn({authorizedVoter:e,epoch:t}){return{epoch:t,authorizedVoter:new D(e)}}function $n({authorizedPubkey:e,epochOfLastAuthorizedSwitch:t,targetEpoch:r}){return{authorizedPubkey:new D(e),epochOfLastAuthorizedSwitch:t,targetEpoch:r}}function ei({buf:e,idx:t,isEmpty:r}){return r?[]:[...e.slice(t+1).map($n),...e.slice(0,t).map($n)]}const ti={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function ri(e,t){const r=!1===t?"http":"https";if(!e)return ti[r]["devnet"];const n=ti[r][e];if(!n)throw new Error(`Unknown ${r} cluster: ${e}`);return n}async function ni(e,t,r,n){let i,s;r&&Object.prototype.hasOwnProperty.call(r,"lastValidBlockHeight")||r&&Object.prototype.hasOwnProperty.call(r,"nonceValue")?(i=r,s=n):s=r;const o=s&&{skipPreflight:s.skipPreflight,preflightCommitment:s.preflightCommitment||s.commitment,minContextSlot:s.minContextSlot},a=await e.sendRawTransaction(t,o),c=s&&s.commitment,u=i?e.confirmTransaction(i,c):e.confirmTransaction(a,c),l=(await u).value;if(l.err)throw new Error(`Raw transaction ${a} failed (${JSON.stringify(l)})`);return a}const ii=1e9;t.Account=F,t.AddressLookupTableAccount=ht,t.AddressLookupTableInstruction=gn,t.AddressLookupTableProgram=yn,t.Authorized=Pn,t.BLOCKHASH_CACHE_TIMEOUT_MS=kt,t.BPF_LOADER_DEPRECATED_PROGRAM_ID=V,t.BPF_LOADER_PROGRAM_ID=Ze,t.BpfLoader=qe,t.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS=fn,t.ComputeBudgetInstruction=mn,t.ComputeBudgetProgram=kn,t.Connection=hn,t.Ed25519Program=An,t.Enum=x,t.EpochSchedule=it,t.FeeCalculatorLayout=Pe,t.Keypair=bn,t.LAMPORTS_PER_SOL=ii,t.LOOKUP_TABLE_INSTRUCTION_LAYOUTS=pn,t.Loader=He,t.Lockup=Rn,t.MAX_SEED_LENGTH=U,t.Message=ue,t.MessageAccountKeys=G,t.MessageV0=le,t.NONCE_ACCOUNT_LENGTH=Ue,t.NonceAccount=ze,t.PACKET_DATA_SIZE=K,t.PUBLIC_KEY_LENGTH=z,t.PublicKey=D,t.SIGNATURE_LENGTH_IN_BYTES=H,t.SOLANA_SCHEMA=L,t.STAKE_CONFIG_ID=Ln,t.STAKE_INSTRUCTION_LAYOUTS=zn,t.SYSTEM_INSTRUCTION_LAYOUTS=Ve,t.SYSVAR_CLOCK_PUBKEY=Ie,t.SYSVAR_EPOCH_SCHEDULE_PUBKEY=ve,t.SYSVAR_INSTRUCTIONS_PUBKEY=Ae,t.SYSVAR_RECENT_BLOCKHASHES_PUBKEY=_e,t.SYSVAR_RENT_PUBKEY=Ee,t.SYSVAR_REWARDS_PUBKEY=Oe,t.SYSVAR_SLOT_HASHES_PUBKEY=Te,t.SYSVAR_SLOT_HISTORY_PUBKEY=je,t.SYSVAR_STAKE_HISTORY_PUBKEY=Be,t.Secp256k1Program=Mn,t.SendTransactionError=st,t.SolanaJSONRPCError=at,t.SolanaJSONRPCErrorCode=ot,t.StakeAuthorizationLayout=Wn,t.StakeInstruction=Un,t.StakeProgram=Cn,t.Struct=M,t.SystemInstruction=Fe,t.SystemProgram=Ke,t.Transaction=ge,t.TransactionExpiredBlockheightExceededError=Z,t.TransactionExpiredNonceInvalidError=Y,t.TransactionExpiredTimeoutError=q,t.TransactionInstruction=pe,t.TransactionMessage=ye,t.TransactionStatus=he,t.VALIDATOR_INFO_KEY=Hn,t.VERSION_PREFIX_MASK=Q,t.VOTE_PROGRAM_ID=Yn,t.ValidatorInfo=qn,t.VersionedMessage=de,t.VersionedTransaction=me,t.VoteAccount=Jn,t.VoteAuthorizationLayout=Kn,t.VoteInit=Dn,t.VoteInstruction=Fn,t.VoteProgram=Qn,t.clusterApiUrl=ri,t.sendAndConfirmRawTransaction=ni,t.sendAndConfirmTransaction=Ne},"0f06":function(e,t,r){"use strict";(function(e){r.d(t,"a",(function(){return d})),r.d(t,"b",(function(){return h}));r("a573");var n,i=r("8df2"),s=r("633a"),o=r("d6e3"),a=r("753b"),c=r("d99e"),u=(r("7f6a"),r("f7f2"));(function(e){e[e["Uninitialized"]=0]="Uninitialized",e[e["Initialized"]=1]="Initialized",e[e["Frozen"]=2]="Frozen"})(n||(n={}));const l=Object(i["struct"])([Object(s["b"])("mint"),Object(s["b"])("owner"),Object(s["c"])("amount"),Object(i["u32"])("delegateOption"),Object(s["b"])("delegate"),Object(i["u8"])("state"),Object(i["u32"])("isNativeOption"),Object(s["c"])("isNative"),Object(s["c"])("delegatedAmount"),Object(i["u32"])("closeAuthorityOption"),Object(s["b"])("closeAuthority")]),d=l.span;async function h(e,t,r,n=o["c"]){const i=await e.getAccountInfo(t,r);return b(t,i,n)}function b(t,r,i=o["c"]){if(!r)throw new a["a"];if(!r.owner.equals(i))throw new a["c"];if(r.data.length<d)throw new a["d"];const s=l.decode(r.data.slice(0,d));let h=e.alloc(0);if(r.data.length>d){if(r.data.length===u["a"])throw new a["d"];if(r.data[d]!=c["b"].Account)throw new a["b"];h=r.data.slice(d+c["a"])}return{address:t,mint:s.mint,owner:s.owner,amount:s.amount,delegate:s.delegateOption?s.delegate:null,delegatedAmount:s.delegatedAmount,isInitialized:s.state!==n.Uninitialized,isFrozen:s.state===n.Frozen,isNative:!!s.isNativeOption,rentExemptReserve:s.isNativeOption?s.isNative:null,closeAuthority:s.closeAuthorityOption?s.closeAuthority:null,tlvData:h}}}).call(this,r("1c35").Buffer)},"0fa3":function(e,t,r){"use strict";r("14d9");var n=this&&this.__awaiter||function(e,t,r,n){function i(e){return e instanceof r?e:new r((function(t){t(e)}))}return new(r||(r=Promise))((function(r,s){function o(e){try{c(n.next(e))}catch(t){s(t)}}function a(e){try{c(n["throw"](e))}catch(t){s(t)}}function c(e){e.done?r(e.value):i(e.value).then(o,a)}c((n=n.apply(e,t||[])).next())}))},i=this&&this.__rest||function(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var i=0;for(n=Object.getOwnPropertySymbols(e);i<n.length;i++)t.indexOf(n[i])<0&&Object.prototype.propertyIsEnumerable.call(e,n[i])&&(r[n[i]]=e[n[i]])}return r};Object.defineProperty(t,"__esModule",{value:!0}),t.BaseSignInMessageSignerWalletAdapter=t.BaseMessageSignerWalletAdapter=t.BaseSignerWalletAdapter=void 0;const s=r("834f"),o=r("8217"),a=r("e1c8");class c extends s.BaseWalletAdapter{sendTransaction(e,t,r={}){return n(this,void 0,void 0,(function*(){let n=!0;try{if((0,a.isVersionedTransaction)(e)){if(!this.supportedTransactionVersions)throw new o.WalletSendTransactionError("Sending versioned transactions isn't supported by this wallet");if(!this.supportedTransactionVersions.has(e.version))throw new o.WalletSendTransactionError(`Sending transaction version ${e.version} isn't supported by this wallet`);try{e=yield this.signTransaction(e);const n=e.serialize();return yield t.sendRawTransaction(n,r)}catch(s){if(s instanceof o.WalletSignTransactionError)throw n=!1,s;throw new o.WalletSendTransactionError(null===s||void 0===s?void 0:s.message,s)}}else try{const{signers:n}=r,s=i(r,["signers"]);e=yield this.prepareTransaction(e,t,s),(null===n||void 0===n?void 0:n.length)&&e.partialSign(...n),e=yield this.signTransaction(e);const o=e.serialize();return yield t.sendRawTransaction(o,s)}catch(s){if(s instanceof o.WalletSignTransactionError)throw n=!1,s;throw new o.WalletSendTransactionError(null===s||void 0===s?void 0:s.message,s)}}catch(s){throw n&&this.emit("error",s),s}}))}signAllTransactions(e){return n(this,void 0,void 0,(function*(){for(const r of e)if((0,a.isVersionedTransaction)(r)){if(!this.supportedTransactionVersions)throw new o.WalletSignTransactionError("Signing versioned transactions isn't supported by this wallet");if(!this.supportedTransactionVersions.has(r.version))throw new o.WalletSignTransactionError(`Signing transaction version ${r.version} isn't supported by this wallet`)}const t=[];for(const r of e)t.push(yield this.signTransaction(r));return t}))}}t.BaseSignerWalletAdapter=c;class u extends c{}t.BaseMessageSignerWalletAdapter=u;class l extends u{}t.BaseSignInMessageSignerWalletAdapter=l},"17fd":function(e,t,r){"use strict";(function(e){r.d(t,"b",(function(){return o})),r.d(t,"a",(function(){return c}));var n=r("8df2"),i=(r("7f6a"),r("64b9"),r("633a"));r("753b"),r("7b05");const s=Object(n["struct"])([Object(i["b"])("authority"),Object(i["b"])("programId")]),o=s.span;const a=Object(n["struct"])([Object(i["a"])("transferring")]),c=a.span;const u=Object(n["struct"])([Object(n["u8"])("discriminator"),Object(n["blob"])(32,"addressConfig"),Object(i["a"])("isSigner"),Object(i["a"])("isWritable")]),l=Object(n["struct"])([Object(n["u32"])("count"),Object(n["seq"])(u,Object(n["greedy"])(u.span),"extraAccounts")]);Object(n["struct"])([Object(i["c"])("instructionDiscriminator"),Object(n["u32"])("length"),l.replicate("extraAccountsList")])}).call(this,r("1c35").Buffer)},"1b1b":function(e,t,r){"use strict";r.d(t,"a",(function(){return n}));const n="solana:signTransaction"},"1bd0":function(e,t,r){"use strict";(function(e){r.d(t,"a",(function(){return l}));var n=r("8df2"),i=r("633a"),s=r("64b9"),o=r("d6e3"),a=(r("753b"),r("abed")),c=r("fbe3");const u=Object(n["struct"])([Object(n["u8"])("instruction"),Object(i["c"])("amount")]);function l(t,r,n,i,l=[],d=o["c"]){const h=Object(a["a"])([{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0}],n,l),b=e.alloc(u.span);return u.encode({instruction:c["a"].Transfer,amount:BigInt(i)},b),new s["j"]({keys:h,programId:d,data:b})}}).call(this,r("1c35").Buffer)},"290c":function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r("ed96");function i(e,t){return void 0===t&&(t=0),(e[t+0]<<8|e[t+1])<<16>>16}function s(e,t){return void 0===t&&(t=0),(e[t+0]<<8|e[t+1])>>>0}function o(e,t){return void 0===t&&(t=0),(e[t+1]<<8|e[t])<<16>>16}function a(e,t){return void 0===t&&(t=0),(e[t+1]<<8|e[t])>>>0}function c(e,t,r){return void 0===t&&(t=new Uint8Array(2)),void 0===r&&(r=0),t[r+0]=e>>>8,t[r+1]=e>>>0,t}function u(e,t,r){return void 0===t&&(t=new Uint8Array(2)),void 0===r&&(r=0),t[r+0]=e>>>0,t[r+1]=e>>>8,t}function l(e,t){return void 0===t&&(t=0),e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3]}function d(e,t){return void 0===t&&(t=0),(e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3])>>>0}function h(e,t){return void 0===t&&(t=0),e[t+3]<<24|e[t+2]<<16|e[t+1]<<8|e[t]}function b(e,t){return void 0===t&&(t=0),(e[t+3]<<24|e[t+2]<<16|e[t+1]<<8|e[t])>>>0}function p(e,t,r){return void 0===t&&(t=new Uint8Array(4)),void 0===r&&(r=0),t[r+0]=e>>>24,t[r+1]=e>>>16,t[r+2]=e>>>8,t[r+3]=e>>>0,t}function g(e,t,r){return void 0===t&&(t=new Uint8Array(4)),void 0===r&&(r=0),t[r+0]=e>>>0,t[r+1]=e>>>8,t[r+2]=e>>>16,t[r+3]=e>>>24,t}function y(e,t){void 0===t&&(t=0);var r=l(e,t),n=l(e,t+4);return 4294967296*r+n-4294967296*(n>>31)}function m(e,t){void 0===t&&(t=0);var r=d(e,t),n=d(e,t+4);return 4294967296*r+n}function f(e,t){void 0===t&&(t=0);var r=h(e,t),n=h(e,t+4);return 4294967296*n+r-4294967296*(r>>31)}function k(e,t){void 0===t&&(t=0);var r=b(e,t),n=b(e,t+4);return 4294967296*n+r}function w(e,t,r){return void 0===t&&(t=new Uint8Array(8)),void 0===r&&(r=0),p(e/4294967296>>>0,t,r),p(e>>>0,t,r+4),t}function S(e,t,r){return void 0===t&&(t=new Uint8Array(8)),void 0===r&&(r=0),g(e>>>0,t,r),g(e/4294967296>>>0,t,r+4),t}function I(e,t,r){if(void 0===r&&(r=0),e%8!==0)throw new Error("readUintBE supports only bitLengths divisible by 8");if(e/8>t.length-r)throw new Error("readUintBE: array is too short for the given bitLength");for(var n=0,i=1,s=e/8+r-1;s>=r;s--)n+=t[s]*i,i*=256;return n}function v(e,t,r){if(void 0===r&&(r=0),e%8!==0)throw new Error("readUintLE supports only bitLengths divisible by 8");if(e/8>t.length-r)throw new Error("readUintLE: array is too short for the given bitLength");for(var n=0,i=1,s=r;s<r+e/8;s++)n+=t[s]*i,i*=256;return n}function A(e,t,r,i){if(void 0===r&&(r=new Uint8Array(e/8)),void 0===i&&(i=0),e%8!==0)throw new Error("writeUintBE supports only bitLengths divisible by 8");if(!n.isSafeInteger(t))throw new Error("writeUintBE value must be an integer");for(var s=1,o=e/8+i-1;o>=i;o--)r[o]=t/s&255,s*=256;return r}function _(e,t,r,i){if(void 0===r&&(r=new Uint8Array(e/8)),void 0===i&&(i=0),e%8!==0)throw new Error("writeUintLE supports only bitLengths divisible by 8");if(!n.isSafeInteger(t))throw new Error("writeUintLE value must be an integer");for(var s=1,o=i;o<i+e/8;o++)r[o]=t/s&255,s*=256;return r}function E(e,t){void 0===t&&(t=0);var r=new DataView(e.buffer,e.byteOffset,e.byteLength);return r.getFloat32(t)}function O(e,t){void 0===t&&(t=0);var r=new DataView(e.buffer,e.byteOffset,e.byteLength);return r.getFloat32(t,!0)}function T(e,t){void 0===t&&(t=0);var r=new DataView(e.buffer,e.byteOffset,e.byteLength);return r.getFloat64(t)}function j(e,t){void 0===t&&(t=0);var r=new DataView(e.buffer,e.byteOffset,e.byteLength);return r.getFloat64(t,!0)}function B(e,t,r){void 0===t&&(t=new Uint8Array(4)),void 0===r&&(r=0);var n=new DataView(t.buffer,t.byteOffset,t.byteLength);return n.setFloat32(r,e),t}function N(e,t,r){void 0===t&&(t=new Uint8Array(4)),void 0===r&&(r=0);var n=new DataView(t.buffer,t.byteOffset,t.byteLength);return n.setFloat32(r,e,!0),t}function M(e,t,r){void 0===t&&(t=new Uint8Array(8)),void 0===r&&(r=0);var n=new DataView(t.buffer,t.byteOffset,t.byteLength);return n.setFloat64(r,e),t}function x(e,t,r){void 0===t&&(t=new Uint8Array(8)),void 0===r&&(r=0);var n=new DataView(t.buffer,t.byteOffset,t.byteLength);return n.setFloat64(r,e,!0),t}t.readInt16BE=i,t.readUint16BE=s,t.readInt16LE=o,t.readUint16LE=a,t.writeUint16BE=c,t.writeInt16BE=c,t.writeUint16LE=u,t.writeInt16LE=u,t.readInt32BE=l,t.readUint32BE=d,t.readInt32LE=h,t.readUint32LE=b,t.writeUint32BE=p,t.writeInt32BE=p,t.writeUint32LE=g,t.writeInt32LE=g,t.readInt64BE=y,t.readUint64BE=m,t.readInt64LE=f,t.readUint64LE=k,t.writeUint64BE=w,t.writeInt64BE=w,t.writeUint64LE=S,t.writeInt64LE=S,t.readUintBE=I,t.readUintLE=v,t.writeUintBE=A,t.writeUintLE=_,t.readFloat32BE=E,t.readFloat32LE=O,t.readFloat64BE=T,t.readFloat64LE=j,t.writeFloat32BE=B,t.writeFloat32LE=N,t.writeFloat64BE=M,t.writeFloat64LE=x},2923:function(e,t,r){"use strict";r("d9e2"),r("14d9"),r("13d5"),r("907a"),r("986a"),r("1d02"),r("3c5d"),r("6ce5"),r("2834"),r("4ea1"),r("669d"),r("109c"),r("b2c1"),r("0643"),r("76d6"),r("2382"),r("fffc"),r("4e3e"),r("a573"),r("9d4a"),r("9a9a"),r("88e6"),r("70cc"),r("eb03"),r("22e5"),r("c01e"),r("fa76"),r("8306");var n=r("1c35"),i=r("aecc"),s=r("399f"),o=r("405f"),a=r("d129"),c=r("fa13"),u=r("8df2"),l=r("9ea2"),d=r("d920"),h=r("502a"),b=r("e01f"),p=r("136e"),g=r("00e3"),y=r("fb4a");function m(e){return e&&"object"===typeof e&&"default"in e?e:{default:e}}function f(e){if(e&&"object"===typeof e&&"default"in e)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var k=m(s),w=m(o),S=f(u),I=m(h),v=m(b),A=m(p);const _=i.ed25519.utils.randomPrivateKey,E=()=>{const e=i.ed25519.utils.randomPrivateKey(),t=O(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),{publicKey:t,secretKey:r}},O=i.ed25519.getPublicKey;function T(e){try{return i.ed25519.ExtendedPoint.fromHex(e),!0}catch{return!1}}const j=(e,t)=>i.ed25519.sign(e,t.slice(0,32)),B=i.ed25519.verify,N=e=>n.Buffer.isBuffer(e)?e:e instanceof Uint8Array?n.Buffer.from(e.buffer,e.byteOffset,e.byteLength):n.Buffer.from(e);class M{constructor(e){Object.assign(this,e)}encode(){return n.Buffer.from(c.serialize(L,this))}static decode(e){return c.deserialize(L,this,e)}static decodeUnchecked(e){return c.deserializeUnchecked(L,this,e)}}class x extends M{constructor(e){if(super(e),this.enum="",1!==Object.keys(e).length)throw new Error("Enum can only take single value");Object.keys(e).map(e=>{this.enum=e})}}const L=new Map;var P;let R;const U=32,z=32;function W(e){return void 0!==e._bn}let C=1;R=Symbol.toStringTag;class D extends M{constructor(e){if(super({}),this._bn=void 0,W(e))this._bn=e._bn;else{if("string"===typeof e){const t=w.default.decode(e);if(t.length!=z)throw new Error("Invalid public key input");this._bn=new k.default(t)}else this._bn=new k.default(e);if(this._bn.byteLength()>z)throw new Error("Invalid public key input")}}static unique(){const e=new D(C);return C+=1,new D(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return w.default.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(n.Buffer);if(e.length===z)return e;const t=n.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[R](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const i=n.Buffer.concat([e.toBuffer(),n.Buffer.from(t),r.toBuffer()]),s=a.sha256(i);return new D(s)}static createProgramAddressSync(e,t){let r=n.Buffer.alloc(0);e.forEach((function(e){if(e.length>U)throw new TypeError("Max seed length exceeded");r=n.Buffer.concat([r,N(e)])})),r=n.Buffer.concat([r,t.toBuffer(),n.Buffer.from("ProgramDerivedAddress")]);const i=a.sha256(r);if(T(i))throw new Error("Invalid seeds, address must fall off the curve");return new D(i)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r,i=255;while(0!=i){try{const s=e.concat(n.Buffer.from([i]));r=this.createProgramAddressSync(s,t)}catch(s){if(s instanceof TypeError)throw s;i--;continue}return[r,i]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new D(e);return T(t.toBytes())}}P=D,D.default=new P("11111111111111111111111111111111"),L.set(D,{kind:"struct",fields:[["_bn","u256"]]});class F{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const t=N(e);if(64!==e.length)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=N(_()),this._publicKey=N(O(this._secretKey))}get publicKey(){return new D(this._publicKey)}get secretKey(){return n.Buffer.concat([this._secretKey,this._publicKey],64)}}const V=new D("BPFLoader1111111111111111111111111111111111"),K=1232,Q=127,H=64;class Z extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Z.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class q extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature `+e+" using the Solana Explorer or CLI tools."),this.signature=void 0,this.signature=e}}Object.defineProperty(q.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Y extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Y.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class G{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){const t=255;if(this.length>t+1)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((e,t)=>{r.set(e.toBase58(),t)});const n=e=>{const t=r.get(e.toBase58());if(void 0===t)throw new Error("Encountered an unknown instruction account key during compilation");return t};return e.map(e=>({programIdIndex:n(e.programId),accountKeyIndexes:e.keys.map(e=>n(e.pubkey)),data:e.data}))}}const J=(e="publicKey")=>S.blob(32,e),X=(e="signature")=>S.blob(64,e),$=(e="string")=>{const t=S.struct([S.u32("length"),S.u32("lengthPadding"),S.blob(S.offset(S.u32(),-8),"chars")],e),r=t.decode.bind(t),i=t.encode.bind(t),s=t;return s.decode=(e,t)=>{const n=r(e,t);return n["chars"].toString()},s.encode=(e,t,r)=>{const s={chars:n.Buffer.from(e,"utf8")};return i(s,t,r)},s.alloc=e=>S.u32().span+S.u32().span+n.Buffer.from(e,"utf8").length,s},ee=(e="authorized")=>S.struct([J("staker"),J("withdrawer")],e),te=(e="lockup")=>S.struct([S.ns64("unixTimestamp"),S.ns64("epoch"),J("custodian")],e),re=(e="voteInit")=>S.struct([J("nodePubkey"),J("authorizedVoter"),J("authorizedWithdrawer"),S.u8("commission")],e),ne=(e="voteAuthorizeWithSeedArgs")=>S.struct([S.u32("voteAuthorizationType"),J("currentAuthorityDerivedKeyOwnerPubkey"),$("currentAuthorityDerivedKeySeed"),J("newAuthorized")],e);function ie(e,t){const r=e=>{if(e.span>=0)return e.span;if("function"===typeof e.alloc)return e.alloc(t[e.property]);if("count"in e&&"elementLayout"in e){const n=t[e.property];if(Array.isArray(n))return n.length*r(e.elementLayout)}else if("fields"in e)return ie({layout:e},t[e.property]);return 0};let n=0;return e.layout.fields.forEach(e=>{n+=r(e)}),n}function se(e){let t=0,r=0;for(;;){let n=e.shift();if(t|=(127&n)<<7*r,r+=1,0===(128&n))break}return t}function oe(e,t){let r=t;for(;;){let t=127&r;if(r>>=7,0==r){e.push(t);break}t|=128,e.push(t)}}function ae(e,t){if(!e)throw new Error(t||"Assertion failed")}class ce{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,n=e=>{const t=e.toBase58();let n=r.get(t);return void 0===n&&(n={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(t,n)),n},i=n(t);i.isSigner=!0,i.isWritable=!0;for(const s of e){n(s.programId).isInvoked=!0;for(const e of s.keys){const t=n(e.pubkey);t.isSigner||(t.isSigner=e.isSigner),t.isWritable||(t.isWritable=e.isWritable)}}return new ce(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];ae(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,e])=>e.isSigner&&e.isWritable),r=e.filter(([,e])=>e.isSigner&&!e.isWritable),n=e.filter(([,e])=>!e.isSigner&&e.isWritable),i=e.filter(([,e])=>!e.isSigner&&!e.isWritable),s={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:i.length};{ae(t.length>0,"Expected at least one writable signer key");const[e]=t[0];ae(e===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const o=[...t.map(([e])=>new D(e)),...r.map(([e])=>new D(e)),...n.map(([e])=>new D(e)),...i.map(([e])=>new D(e))];return[s,o]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,e=>!e.isSigner&&!e.isInvoked&&e.isWritable),[n,i]=this.drainKeysFoundInLookupTable(e.state.addresses,e=>!e.isSigner&&!e.isInvoked&&!e.isWritable);if(0!==t.length||0!==n.length)return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:n},{writable:r,readonly:i}]}drainKeysFoundInLookupTable(e,t){const r=new Array,n=new Array;for(const[i,s]of this.keyMetaMap.entries())if(t(s)){const t=new D(i),s=e.findIndex(e=>e.equals(t));s>=0&&(ae(s<256,"Max lookup table index exceeded"),r.push(s),n.push(t),this.keyMetaMap.delete(i))}return[r,n]}}class ue{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(e=>new D(e)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:w.default.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new G(this.staticAccountKeys)}static compile(e){const t=ce.compile(e.instructions,e.payerKey),[r,n]=t.getMessageComponents(),i=new G(n),s=i.compileInstructions(e.instructions).map(e=>({programIdIndex:e.programIdIndex,accounts:e.accountKeyIndexes,data:w.default.encode(e.data)}));return new ue({header:r,accountKeys:n,recentBlockhash:e.recentBlockhash,instructions:s})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const r=e-t,n=this.accountKeys.length-t,i=n-this.header.numReadonlyUnsignedAccounts;return r<i}{const r=t-this.header.numReadonlySignedAccounts;return e<r}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];oe(t,e);const r=this.instructions.map(e=>{const{accounts:t,programIdIndex:r}=e,i=Array.from(w.default.decode(e.data));let s=[];oe(s,t.length);let o=[];return oe(o,i.length),{programIdIndex:r,keyIndicesCount:n.Buffer.from(s),keyIndices:t,dataLength:n.Buffer.from(o),data:i}});let i=[];oe(i,r.length);let s=n.Buffer.alloc(K);n.Buffer.from(i).copy(s);let o=i.length;r.forEach(e=>{const t=S.struct([S.u8("programIdIndex"),S.blob(e.keyIndicesCount.length,"keyIndicesCount"),S.seq(S.u8("keyIndex"),e.keyIndices.length,"keyIndices"),S.blob(e.dataLength.length,"dataLength"),S.seq(S.u8("userdatum"),e.data.length,"data")]),r=t.encode(e,s,o);o+=r}),s=s.slice(0,o);const a=S.struct([S.blob(1,"numRequiredSignatures"),S.blob(1,"numReadonlySignedAccounts"),S.blob(1,"numReadonlyUnsignedAccounts"),S.blob(t.length,"keyCount"),S.seq(J("key"),e,"keys"),J("recentBlockhash")]),c={numRequiredSignatures:n.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:n.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:n.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:n.Buffer.from(t),keys:this.accountKeys.map(e=>N(e.toBytes())),recentBlockhash:w.default.decode(this.recentBlockhash)};let u=n.Buffer.alloc(2048);const l=a.encode(c,u);return s.copy(u,l),u.slice(0,l+s.length)}static from(e){let t=[...e];const r=t.shift();if(r!==(r&Q))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const i=t.shift(),s=t.shift(),o=se(t);let a=[];for(let h=0;h<o;h++){const e=t.slice(0,z);t=t.slice(z),a.push(new D(n.Buffer.from(e)))}const c=t.slice(0,z);t=t.slice(z);const u=se(t);let l=[];for(let h=0;h<u;h++){const e=t.shift(),r=se(t),i=t.slice(0,r);t=t.slice(r);const s=se(t),o=t.slice(0,s),a=w.default.encode(n.Buffer.from(o));t=t.slice(s),l.push({programIdIndex:e,accounts:i,data:a})}const d={header:{numRequiredSignatures:r,numReadonlySignedAccounts:i,numReadonlyUnsignedAccounts:s},recentBlockhash:w.default.encode(n.Buffer.from(c)),accountKeys:a,instructions:l};return new ue(d)}}class le{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new G(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){const t=e-r,n=this.addressTableLookups.reduce((e,t)=>e+t.writableIndexes.length,0);return t<n}if(e>=this.header.numRequiredSignatures){const n=e-t,i=r-t,s=i-this.header.numReadonlyUnsignedAccounts;return n<s}{const r=t-this.header.numReadonlySignedAccounts;return e<r}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const n=e.find(e=>e.key.equals(r.accountKey));if(!n)throw new Error("Failed to find address lookup table account for table key "+r.accountKey.toBase58());for(const e of r.writableIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.writable.push(n.state.addresses[e])}for(const e of r.readonlyIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.readonly.push(n.state.addresses[e])}}return t}static compile(e){const t=ce.compile(e.instructions,e.payerKey),r=new Array,n={writable:new Array,readonly:new Array},i=e.addressLookupTableAccounts||[];for(const u of i){const e=t.extractTableLookup(u);if(void 0!==e){const[t,{writable:i,readonly:s}]=e;r.push(t),n.writable.push(...i),n.readonly.push(...s)}}const[s,o]=t.getMessageComponents(),a=new G(o,n),c=a.compileInstructions(e.instructions);return new le({header:s,staticAccountKeys:o,recentBlockhash:e.recentBlockhash,compiledInstructions:c,addressTableLookups:r})}serialize(){const e=Array();oe(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();oe(r,this.compiledInstructions.length);const n=this.serializeAddressTableLookups(),i=Array();oe(i,this.addressTableLookups.length);const s=S.struct([S.u8("prefix"),S.struct([S.u8("numRequiredSignatures"),S.u8("numReadonlySignedAccounts"),S.u8("numReadonlyUnsignedAccounts")],"header"),S.blob(e.length,"staticAccountKeysLength"),S.seq(J(),this.staticAccountKeys.length,"staticAccountKeys"),J("recentBlockhash"),S.blob(r.length,"instructionsLength"),S.blob(t.length,"serializedInstructions"),S.blob(i.length,"addressTableLookupsLength"),S.blob(n.length,"serializedAddressTableLookups")]),o=new Uint8Array(K),a=128,c=s.encode({prefix:a,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(e=>e.toBytes()),recentBlockhash:w.default.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(i),serializedAddressTableLookups:n},o);return o.slice(0,c)}serializeInstructions(){let e=0;const t=new Uint8Array(K);for(const r of this.compiledInstructions){const n=Array();oe(n,r.accountKeyIndexes.length);const i=Array();oe(i,r.data.length);const s=S.struct([S.u8("programIdIndex"),S.blob(n.length,"encodedAccountKeyIndexesLength"),S.seq(S.u8(),r.accountKeyIndexes.length,"accountKeyIndexes"),S.blob(i.length,"encodedDataLength"),S.blob(r.data.length,"data")]);e+=s.encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(n),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(i),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(K);for(const r of this.addressTableLookups){const n=Array();oe(n,r.writableIndexes.length);const i=Array();oe(i,r.readonlyIndexes.length);const s=S.struct([J("accountKey"),S.blob(n.length,"encodedWritableIndexesLength"),S.seq(S.u8(),r.writableIndexes.length,"writableIndexes"),S.blob(i.length,"encodedReadonlyIndexesLength"),S.seq(S.u8(),r.readonlyIndexes.length,"readonlyIndexes")]);e+=s.encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(n),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(i),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=t.shift(),n=r&Q;ae(r!==n,"Expected versioned message but received legacy message");const i=n;ae(0===i,"Expected versioned message with version 0 but found version "+i);const s={numRequiredSignatures:t.shift(),numReadonlySignedAccounts:t.shift(),numReadonlyUnsignedAccounts:t.shift()},o=[],a=se(t);for(let b=0;b<a;b++)o.push(new D(t.splice(0,z)));const c=w.default.encode(t.splice(0,z)),u=se(t),l=[];for(let b=0;b<u;b++){const e=t.shift(),r=se(t),n=t.splice(0,r),i=se(t),s=new Uint8Array(t.splice(0,i));l.push({programIdIndex:e,accountKeyIndexes:n,data:s})}const d=se(t),h=[];for(let b=0;b<d;b++){const e=new D(t.splice(0,z)),r=se(t),n=t.splice(0,r),i=se(t),s=t.splice(0,i);h.push({accountKey:e,writableIndexes:n,readonlyIndexes:s})}return new le({header:s,staticAccountKeys:o,recentBlockhash:c,compiledInstructions:l,addressTableLookups:h})}}const de={deserializeMessageVersion(e){const t=e[0],r=t&Q;return r===t?"legacy":r},deserialize:e=>{const t=de.deserializeMessageVersion(e);if("legacy"===t)return ue.from(e);if(0===t)return le.deserialize(e);throw new Error(`Transaction message version ${t} deserialization is not supported`)}};let he=function(e){return e[e["BLOCKHEIGHT_EXCEEDED"]=0]="BLOCKHEIGHT_EXCEEDED",e[e["PROCESSED"]=1]="PROCESSED",e[e["TIMED_OUT"]=2]="TIMED_OUT",e[e["NONCE_INVALID"]=3]="NONCE_INVALID",e}({});const be=n.Buffer.alloc(H).fill(0);class pe{constructor(e){this.keys=void 0,this.programId=void 0,this.data=n.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class ge{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(0===e.length)throw new Error("No instructions");return e.forEach(e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new pe(e))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t,r;if(this.nonceInfo?(e=this.nonceInfo.nonce,t=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");if(t.length,this.feePayer)r=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");r=this.signatures[0].publicKey}for(let p=0;p<t.length;p++)if(void 0===t[p].programId)throw new Error(`Transaction instruction index ${p} has undefined program id`);const n=[],i=[];t.forEach(e=>{e.keys.forEach(e=>{i.push({...e})});const t=e.programId.toString();n.includes(t)||n.push(t)}),n.forEach(e=>{i.push({pubkey:new D(e),isSigner:!1,isWritable:!1})});const s=[];i.forEach(e=>{const t=e.pubkey.toString(),r=s.findIndex(e=>e.pubkey.toString()===t);r>-1?(s[r].isWritable=s[r].isWritable||e.isWritable,s[r].isSigner=s[r].isSigner||e.isSigner):s.push(e)}),s.sort((function(e,t){if(e.isSigner!==t.isSigner)return e.isSigner?-1:1;if(e.isWritable!==t.isWritable)return e.isWritable?-1:1;const r={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return e.pubkey.toBase58().localeCompare(t.pubkey.toBase58(),"en",r)}));const o=s.findIndex(e=>e.pubkey.equals(r));if(o>-1){const[e]=s.splice(o,1);e.isSigner=!0,e.isWritable=!0,s.unshift(e)}else s.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const p of this.signatures){const e=s.findIndex(e=>e.pubkey.equals(p.publicKey));if(!(e>-1))throw new Error("unknown signer: "+p.publicKey.toString());s[e].isSigner||(s[e].isSigner=!0)}let a=0,c=0,u=0;const l=[],d=[];s.forEach(({pubkey:e,isSigner:t,isWritable:r})=>{t?(l.push(e.toString()),a+=1,r||(c+=1)):(d.push(e.toString()),r||(u+=1))});const h=l.concat(d),b=t.map(e=>{const{data:t,programId:r}=e;return{programIdIndex:h.indexOf(r.toString()),accounts:e.keys.map(e=>h.indexOf(e.pubkey.toString())),data:w.default.encode(t)}});return b.forEach(e=>{ae(e.programIdIndex>=0),e.accounts.forEach(e=>ae(e>=0))}),new ue({header:{numRequiredSignatures:a,numReadonlySignedAccounts:c,numReadonlyUnsignedAccounts:u},accountKeys:h,recentBlockhash:e,instructions:b})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);if(this.signatures.length===t.length){const r=this.signatures.every((e,r)=>t[r].equals(e.publicKey));if(r)return e}return this.signatures=t.map(e=>({signature:null,publicKey:e})),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(0===e.length)throw new Error("No signers");const t=new Set;this.signatures=e.filter(e=>{const r=e.toString();return!t.has(r)&&(t.add(r),!0)}).map(e=>({signature:null,publicKey:e}))}sign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const i of e){const e=i.publicKey.toString();t.has(e)||(t.add(e),r.push(i))}this.signatures=r.map(e=>({signature:null,publicKey:e.publicKey}));const n=this._compile();this._partialSign(n,...r)}partialSign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const i of e){const e=i.publicKey.toString();t.has(e)||(t.add(e),r.push(i))}const n=this._compile();this._partialSign(n,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach(e=>{const t=j(r,e.secretKey);this._addSignature(e.publicKey,N(t))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){ae(64===t.length);const r=this.signatures.findIndex(t=>e.equals(t.publicKey));if(r<0)throw new Error("unknown signer: "+e.toString());this.signatures[r].signature=n.Buffer.from(t)}verifySignatures(e=!0){const t=this._getMessageSignednessErrors(this.serializeMessage(),e);return!t}_getMessageSignednessErrors(e,t){const r={};for(const{signature:n,publicKey:i}of this.signatures)null===n?t&&(r.missing||(r.missing=[])).push(i):B(n,e,i.toBytes())||(r.invalid||(r.invalid=[])).push(i);return r.invalid||r.missing?r:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r){const e=this._getMessageSignednessErrors(n,t);if(e){let t="Signature verification failed.";throw e.invalid&&(t+=`\nInvalid signature for public key${1===e.invalid.length?"":"(s)"} [\`${e.invalid.map(e=>e.toBase58()).join("`, `")}\`].`),e.missing&&(t+=`\nMissing signature for public key${1===e.missing.length?"":"(s)"} [\`${e.missing.map(e=>e.toBase58()).join("`, `")}\`].`),new Error(t)}}return this._serialize(n)}_serialize(e){const{signatures:t}=this,r=[];oe(r,t.length);const i=r.length+64*t.length+e.length,s=n.Buffer.alloc(i);return ae(t.length<256),n.Buffer.from(r).copy(s,0),t.forEach(({signature:e},t)=>{null!==e&&(ae(64===e.length,"signature has invalid length"),n.Buffer.from(e).copy(s,r.length+64*t))}),e.copy(s,r.length+64*t.length),ae(s.length<=K,`Transaction too large: ${s.length} > ${K}`),s}get keys(){return ae(1===this.instructions.length),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return ae(1===this.instructions.length),this.instructions[0].programId}get data(){return ae(1===this.instructions.length),this.instructions[0].data}static from(e){let t=[...e];const r=se(t);let i=[];for(let s=0;s<r;s++){const e=t.slice(0,H);t=t.slice(H),i.push(w.default.encode(n.Buffer.from(e)))}return ge.populate(ue.from(t),i)}static populate(e,t=[]){const r=new ge;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach((t,n)=>{const i={signature:t==w.default.encode(be)?null:w.default.decode(t),publicKey:e.accountKeys[n]};r.signatures.push(i)}),e.instructions.forEach(t=>{const n=t.accounts.map(t=>{const n=e.accountKeys[t];return{pubkey:n,isSigner:r.signatures.some(e=>e.publicKey.toString()===n.toString())||e.isAccountSigner(t),isWritable:e.isAccountWritable(t)}});r.instructions.push(new pe({keys:n,programId:e.accountKeys[t.programIdIndex],data:w.default.decode(t.data)}))}),r._message=e,r._json=r.toJSON(),r}}class ye{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:r,compiledInstructions:n,recentBlockhash:i}=e,{numRequiredSignatures:s,numReadonlySignedAccounts:o,numReadonlyUnsignedAccounts:a}=r,c=s-o;ae(c>0,"Message header is invalid");const u=e.staticAccountKeys.length-s-a;ae(u>=0,"Message header is invalid");const l=e.getAccountKeys(t),d=l.get(0);if(void 0===d)throw new Error("Failed to decompile message because no account keys were found");const h=[];for(const b of n){const e=[];for(const n of b.accountKeyIndexes){const t=l.get(n);if(void 0===t)throw new Error("Failed to find key for account key index "+n);const i=n<s;let o;o=i?n<c:n<l.staticAccountKeys.length?n-s<u:n-l.staticAccountKeys.length<l.accountKeysFromLookups.writable.length,e.push({pubkey:t,isSigner:n<r.numRequiredSignatures,isWritable:o})}const t=l.get(b.programIdIndex);if(void 0===t)throw new Error("Failed to find program id for program id index "+b.programIdIndex);h.push(new pe({programId:t,data:N(b.data),keys:e}))}return new ye({payerKey:d,instructions:h,recentBlockhash:i})}compileToLegacyMessage(){return ue.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return le.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class me{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,void 0!==t)ae(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const t=[];for(let r=0;r<e.header.numRequiredSignatures;r++)t.push(new Uint8Array(H));this.signatures=t}this.message=e}serialize(){const e=this.message.serialize(),t=Array();oe(t,this.signatures.length);const r=S.struct([S.blob(t.length,"encodedSignaturesLength"),S.seq(X(),this.signatures.length,"signatures"),S.blob(e.length,"serializedMessage")]),n=new Uint8Array(2048),i=r.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},n);return n.slice(0,i)}static deserialize(e){let t=[...e];const r=[],n=se(t);for(let s=0;s<n;s++)r.push(new Uint8Array(t.splice(0,H)));const i=de.deserialize(new Uint8Array(t));return new me(i,r)}sign(e){const t=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const n of e){const e=r.findIndex(e=>e.equals(n.publicKey));ae(e>=0,"Cannot sign with non signer key "+n.publicKey.toBase58()),this.signatures[e]=j(t,n.secretKey)}}addSignature(e,t){ae(64===t.byteLength,"Signature must be 64 bytes long");const r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures),n=r.findIndex(t=>t.equals(e));ae(n>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[n]=t}}const fe=160,ke=64,we=fe/ke,Se=1e3/we,Ie=new D("SysvarC1ock11111111111111111111111111111111"),ve=new D("SysvarEpochSchedu1e111111111111111111111111"),Ae=new D("Sysvar1nstructions1111111111111111111111111"),_e=new D("SysvarRecentB1ockHashes11111111111111111111"),Ee=new D("SysvarRent111111111111111111111111111111111"),Oe=new D("SysvarRewards111111111111111111111111111111"),Te=new D("SysvarS1otHashes111111111111111111111111111"),je=new D("SysvarS1otHistory11111111111111111111111111"),Be=new D("SysvarStakeHistory1111111111111111111111111");async function Ne(e,t,r,n){const i=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},s=await e.sendTransaction(t,r,i);let o;if(null!=t.recentBlockhash&&null!=t.lastValidBlockHeight)o=(await e.confirmTransaction({abortSignal:null===n||void 0===n?void 0:n.abortSignal,signature:s,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},n&&n.commitment)).value;else if(null!=t.minNonceContextSlot&&null!=t.nonceInfo){const{nonceInstruction:r}=t.nonceInfo,i=r.keys[0].pubkey;o=(await e.confirmTransaction({abortSignal:null===n||void 0===n?void 0:n.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:i,nonceValue:t.nonceInfo.nonce,signature:s},n&&n.commitment)).value}else null===n||void 0===n||n.abortSignal,o=(await e.confirmTransaction(s,n&&n.commitment)).value;if(o.err)throw new Error(`Transaction ${s} failed (${JSON.stringify(o)})`);return s}function Me(e){return new Promise(t=>setTimeout(t,e))}function xe(e,t){const r=e.layout.span>=0?e.layout.span:ie(e,t),i=n.Buffer.alloc(r),s=Object.assign({instruction:e.index},t);return e.layout.encode(s,i),i}function Le(e,t){let r;try{r=e.layout.decode(t)}catch(n){throw new Error("invalid instruction; "+n)}if(r.instruction!==e.index)throw new Error(`invalid instruction; instruction index mismatch ${r.instruction} != ${e.index}`);return r}const Pe=S.nu64("lamportsPerSignature"),Re=S.struct([S.u32("version"),S.u32("state"),J("authorizedPubkey"),J("nonce"),S.struct([Pe],"feeCalculator")]),Ue=Re.span;class ze{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Re.decode(N(e),0);return new ze({authorizedPubkey:new D(t.authorizedPubkey),nonce:new D(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const We=e=>{const t=e.decode.bind(e),r=e.encode.bind(e);return{decode:t,encode:r}},Ce=e=>t=>{const r=u.blob(e,t),{encode:i,decode:s}=We(r),o=r;return o.decode=(e,t)=>{const r=s(e,t);return l.toBigIntLE(n.Buffer.from(r))},o.encode=(t,r,n)=>{const s=l.toBufferLE(t,e);return i(s,r,n)},o},De=Ce(8);class Fe{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=S.u32("instruction"),r=t.decode(e.data);let n;for(const[i,s]of Object.entries(Ve))if(s.index==r){n=i;break}if(!n)throw new Error("Instruction type incorrect; not a SystemInstruction");return n}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:r,programId:n}=Le(Ve.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:r,programId:new D(n)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=Le(Ve.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:r,programId:n}=Le(Ve.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:r,programId:new D(n)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=Le(Ve.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,space:n,programId:i}=Le(Ve.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new D(t),seed:r,space:n,programId:new D(i)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=Le(Ve.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new D(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,programId:n}=Le(Ve.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new D(t),seed:r,programId:new D(n)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:r,lamports:n,space:i,programId:s}=Le(Ve.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new D(t),seed:r,lamports:n,space:i,programId:new D(s)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=Le(Ve.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new D(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),Le(Ve.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=Le(Ve.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=Le(Ve.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new D(t)}}static checkProgramId(e){if(!e.equals(Ke.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const Ve=Object.freeze({Create:{index:0,layout:S.struct([S.u32("instruction"),S.ns64("lamports"),S.ns64("space"),J("programId")])},Assign:{index:1,layout:S.struct([S.u32("instruction"),J("programId")])},Transfer:{index:2,layout:S.struct([S.u32("instruction"),De("lamports")])},CreateWithSeed:{index:3,layout:S.struct([S.u32("instruction"),J("base"),$("seed"),S.ns64("lamports"),S.ns64("space"),J("programId")])},AdvanceNonceAccount:{index:4,layout:S.struct([S.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:S.struct([S.u32("instruction"),S.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:S.struct([S.u32("instruction"),J("authorized")])},AuthorizeNonceAccount:{index:7,layout:S.struct([S.u32("instruction"),J("authorized")])},Allocate:{index:8,layout:S.struct([S.u32("instruction"),S.ns64("space")])},AllocateWithSeed:{index:9,layout:S.struct([S.u32("instruction"),J("base"),$("seed"),S.ns64("space"),J("programId")])},AssignWithSeed:{index:10,layout:S.struct([S.u32("instruction"),J("base"),$("seed"),J("programId")])},TransferWithSeed:{index:11,layout:S.struct([S.u32("instruction"),De("lamports"),$("seed"),J("programId")])},UpgradeNonceAccount:{index:12,layout:S.struct([S.u32("instruction")])}});class Ke{constructor(){}static createAccount(e){const t=Ve.Create,r=xe(t,{lamports:e.lamports,space:e.space,programId:N(e.programId.toBuffer())});return new pe({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(e){let t,r;if("basePubkey"in e){const n=Ve.TransferWithSeed;t=xe(n,{lamports:BigInt(e.lamports),seed:e.seed,programId:N(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const n=Ve.Transfer;t=xe(n,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new pe({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){const n=Ve.AssignWithSeed;t=xe(n,{base:N(e.basePubkey.toBuffer()),seed:e.seed,programId:N(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const n=Ve.Assign;t=xe(n,{programId:N(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new pe({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=Ve.CreateWithSeed,r=xe(t,{base:N(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:N(e.programId.toBuffer())});let n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&n.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new pe({keys:n,programId:this.programId,data:r})}static createNonceAccount(e){const t=new ge;"basePubkey"in e&&"seed"in e?t.add(Ke.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Ue,programId:this.programId})):t.add(Ke.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Ue,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=Ve.InitializeNonceAccount,r=xe(t,{authorized:N(e.authorizedPubkey.toBuffer())}),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:Ee,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new pe(n)}static nonceAdvance(e){const t=Ve.AdvanceNonceAccount,r=xe(t),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new pe(n)}static nonceWithdraw(e){const t=Ve.WithdrawNonceAccount,r=xe(t,{lamports:e.lamports});return new pe({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:Ee,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(e){const t=Ve.AuthorizeNonceAccount,r=xe(t,{authorized:N(e.newAuthorizedPubkey.toBuffer())});return new pe({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(e){let t,r;if("basePubkey"in e){const n=Ve.AllocateWithSeed;t=xe(n,{base:N(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:N(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const n=Ve.Allocate;t=xe(n,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new pe({keys:r,programId:this.programId,data:t})}}Ke.programId=new D("11111111111111111111111111111111");const Qe=K-300;class He{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/He.chunkSize)+1+1)}static async load(e,t,r,i,s){{const n=await e.getMinimumBalanceForRentExemption(s.length),o=await e.getAccountInfo(r.publicKey,"confirmed");let a=null;if(null!==o){if(o.executable)return!1;o.data.length!==s.length&&(a=a||new ge,a.add(Ke.allocate({accountPubkey:r.publicKey,space:s.length}))),o.owner.equals(i)||(a=a||new ge,a.add(Ke.assign({accountPubkey:r.publicKey,programId:i}))),o.lamports<n&&(a=a||new ge,a.add(Ke.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:n-o.lamports})))}else a=(new ge).add(Ke.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:n>0?n:1,space:s.length,programId:i}));null!==a&&await Ne(e,a,[t,r],{commitment:"confirmed"})}const o=S.struct([S.u32("instruction"),S.u32("offset"),S.u32("bytesLength"),S.u32("bytesLengthPadding"),S.seq(S.u8("byte"),S.offset(S.u32(),-8),"bytes")]),a=He.chunkSize;let c=0,u=s,l=[];while(u.length>0){const s=u.slice(0,a),d=n.Buffer.alloc(a+16);o.encode({instruction:0,offset:c,bytes:s,bytesLength:0,bytesLengthPadding:0},d);const h=(new ge).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:i,data:d});if(l.push(Ne(e,h,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")){const e=4;await Me(1e3/e)}c+=a,u=u.slice(a)}await Promise.all(l);{const s=S.struct([S.u32("instruction")]),o=n.Buffer.alloc(s.span);s.encode({instruction:1},o);const a=(new ge).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:Ee,isSigner:!1,isWritable:!1}],programId:i,data:o}),c="processed",u=await e.sendTransaction(a,[t,r],{preflightCommitment:c}),{context:l,value:d}=await e.confirmTransaction({signature:u,lastValidBlockHeight:a.lastValidBlockHeight,blockhash:a.recentBlockhash},c);if(d.err)throw new Error(`Transaction ${u} failed (${JSON.stringify(d)})`);while(1){try{const t=await e.getSlot({commitment:c});if(t>l.slot)break}catch{}await new Promise(e=>setTimeout(e,Math.round(Se/2)))}}return!0}}He.chunkSize=Qe;const Ze=new D("BPFLoader2111111111111111111111111111111111");class qe{static getMinNumSignatures(e){return He.getMinNumSignatures(e)}static load(e,t,r,n,i){return He.load(e,t,r,i,n)}}function Ye(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e["default"]:e}var Ge=Object.prototype.toString,Je=Object.keys||function(e){var t=[];for(var r in e)t.push(r);return t};function Xe(e,t){var r,n,i,s,o,a,c;if(!0===e)return"true";if(!1===e)return"false";switch(typeof e){case"object":if(null===e)return null;if(e.toJSON&&"function"===typeof e.toJSON)return Xe(e.toJSON(),t);if(c=Ge.call(e),"[object Array]"===c){for(i="[",n=e.length-1,r=0;r<n;r++)i+=Xe(e[r],!0)+",";return n>-1&&(i+=Xe(e[r],!0)),i+"]"}if("[object Object]"===c){s=Je(e).sort(),n=s.length,i="",r=0;while(r<n)o=s[r],a=Xe(e[o],!1),void 0!==a&&(i&&(i+=","),i+=JSON.stringify(o)+":"+a),r++;return"{"+i+"}"}return JSON.stringify(e);case"function":case"undefined":return t?null:void 0;case"string":return JSON.stringify(e);default:return isFinite(e)?e:null}}var $e=function(e){var t=Xe(e,!1);if(void 0!==t)return""+t},et=Ye($e);const tt=32;function rt(e){let t=0;while(e>1)e/=2,t++;return t}function nt(e){return 0===e?1:(e--,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,e|=e>>32,e+1)}class it{constructor(e,t,r,n,i){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=r,this.firstNormalEpoch=n,this.firstNormalSlot=i}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=rt(nt(e+tt+1))-rt(tt)-1,r=this.getSlotsInEpoch(t),n=e-(r-tt);return[t,n]}{const t=e-this.firstNormalSlot,r=Math.floor(t/this.slotsPerEpoch),n=this.firstNormalEpoch+r,i=t%this.slotsPerEpoch;return[n,i]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*tt:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+rt(tt)):this.slotsPerEpoch}}class st extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}const ot={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class at extends Error{constructor({code:e,message:t,data:r},n){super(null!=n?`${n}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=r,this.name="SolanaJSONRPCError"}}var ct=globalThis.fetch;class ut extends v.default{constructor(e,t,r){const n=e=>{const r=A.default(e,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return this.underlyingSocket="socket"in r?r.socket:r,r};super(n,e,t,r),this.underlyingSocket=void 0}call(...e){var t;const r=null===(t=this.underlyingSocket)||void 0===t?void 0:t.readyState;return 1===r?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}notify(...e){var t;const r=null===(t=this.underlyingSocket)||void 0===t?void 0:t.readyState;return 1===r?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}}function lt(e,t){let r;try{r=e.layout.decode(t)}catch(n){throw new Error("invalid instruction; "+n)}if(r.typeIndex!==e.index)throw new Error(`invalid account data; account type mismatch ${r.typeIndex} != ${e.index}`);return r}const dt=56;class ht{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=lt(bt,e),r=e.length-dt;ae(r>=0,"lookup table is invalid"),ae(r%32===0,"lookup table is invalid");const n=r/32,{addresses:i}=S.struct([S.seq(J(),n,"addresses")]).decode(e.slice(dt));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:0!==t.authority.length?new D(t.authority[0]):void 0,addresses:i.map(e=>new D(e))}}}const bt={index:1,layout:S.struct([S.u32("typeIndex"),De("deactivationSlot"),S.nu64("lastExtendedSlot"),S.u8("lastExtendedStartIndex"),S.u8(),S.seq(J(),S.offset(S.u8(),-1),"authority")])},pt=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function gt(e){const t=e.match(pt);if(null==t)throw TypeError(`Failed to validate endpoint URL \`${e}\``);const[r,n,i,s]=t,o=e.startsWith("https:")?"wss:":"ws:",a=null==i?null:parseInt(i.slice(1),10),c=null==a?"":":"+(a+1);return`${o}//${n}${c}${s}`}const yt=d.coerce(d.instance(D),d.string(),e=>new D(e)),mt=d.tuple([d.string(),d.literal("base64")]),ft=d.coerce(d.instance(n.Buffer),mt,e=>n.Buffer.from(e[0],"base64")),kt=3e4;function wt(e){if(!1===/^https?:/.test(e))throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return e}function St(e){let t,r;if("string"===typeof e)t=e;else if(e){const{commitment:n,...i}=e;t=n,r=i}return{commitment:t,config:r}}function It(e){return d.union([d.type({jsonrpc:d.literal("2.0"),id:d.string(),result:e}),d.type({jsonrpc:d.literal("2.0"),id:d.string(),error:d.type({code:d.unknown(),message:d.string(),data:d.optional(d.any())})})])}const vt=It(d.unknown());function At(e){return d.coerce(It(e),vt,t=>"error"in t?t:{...t,result:d.create(t.result,e)})}function _t(e){return At(d.type({context:d.type({slot:d.number()}),value:e}))}function Et(e){return d.type({context:d.type({slot:d.number()}),value:e})}function Ot(e,t){return 0===e?new le({header:t.header,staticAccountKeys:t.accountKeys.map(e=>new D(e)),recentBlockhash:t.recentBlockhash,compiledInstructions:t.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:w.default.decode(e.data)})),addressTableLookups:t.addressTableLookups}):new ue(t)}const Tt=d.type({foundation:d.number(),foundationTerm:d.number(),initial:d.number(),taper:d.number(),terminal:d.number()}),jt=At(d.array(d.nullable(d.type({epoch:d.number(),effectiveSlot:d.number(),amount:d.number(),postBalance:d.number(),commission:d.optional(d.nullable(d.number()))})))),Bt=d.array(d.type({slot:d.number(),prioritizationFee:d.number()})),Nt=d.type({total:d.number(),validator:d.number(),foundation:d.number(),epoch:d.number()}),Mt=d.type({epoch:d.number(),slotIndex:d.number(),slotsInEpoch:d.number(),absoluteSlot:d.number(),blockHeight:d.optional(d.number()),transactionCount:d.optional(d.number())}),xt=d.type({slotsPerEpoch:d.number(),leaderScheduleSlotOffset:d.number(),warmup:d.boolean(),firstNormalEpoch:d.number(),firstNormalSlot:d.number()}),Lt=d.record(d.string(),d.array(d.number())),Pt=d.nullable(d.union([d.type({}),d.string()])),Rt=d.type({err:Pt}),Ut=d.literal("receivedSignature"),zt=d.type({"solana-core":d.string(),"feature-set":d.optional(d.number())}),Wt=_t(d.type({err:d.nullable(d.union([d.type({}),d.string()])),logs:d.nullable(d.array(d.string())),accounts:d.optional(d.nullable(d.array(d.nullable(d.type({executable:d.boolean(),owner:d.string(),lamports:d.number(),data:d.array(d.string()),rentEpoch:d.optional(d.number())}))))),unitsConsumed:d.optional(d.number()),returnData:d.optional(d.nullable(d.type({programId:d.string(),data:d.tuple([d.string(),d.literal("base64")])})))})),Ct=_t(d.type({byIdentity:d.record(d.string(),d.array(d.number())),range:d.type({firstSlot:d.number(),lastSlot:d.number()})}));function Dt(e,t,r,n,i,s){const o=r||ct;let a,c;n&&(c=async(e,t)=>{const r=await new Promise((r,i)=>{try{n(e,t,(e,t)=>r([e,t]))}catch(s){i(s)}});return await o(...r)});const u=new I.default(async(r,n)=>{const s={method:"POST",body:r,agent:a,headers:Object.assign({"Content-Type":"application/json"},t||{},dn)};try{let t,r=5,a=500;for(;;){if(t=c?await c(e,s):await o(e,s),429!==t.status)break;if(!0===i)break;if(r-=1,0===r)break;await Me(a),a*=2}const u=await t.text();t.ok?n(null,u):n(new Error(`${t.status} ${t.statusText}: ${u}`))}catch(u){u instanceof Error&&n(u)}},{});return u}function Ft(e){return(t,r)=>new Promise((n,i)=>{e.request(t,r,(e,t)=>{e?i(e):n(t)})})}function Vt(e){return t=>new Promise((r,n)=>{0===t.length&&r([]);const i=t.map(t=>e.request(t.methodName,t.args));e.request(i,(e,t)=>{e?n(e):r(t)})})}const Kt=At(Tt),Qt=At(Nt),Ht=At(Bt),Zt=At(Mt),qt=At(xt),Yt=At(Lt),Gt=At(d.number()),Jt=_t(d.type({total:d.number(),circulating:d.number(),nonCirculating:d.number(),nonCirculatingAccounts:d.array(yt)})),Xt=d.type({amount:d.string(),uiAmount:d.nullable(d.number()),decimals:d.number(),uiAmountString:d.optional(d.string())}),$t=_t(d.array(d.type({address:yt,amount:d.string(),uiAmount:d.nullable(d.number()),decimals:d.number(),uiAmountString:d.optional(d.string())}))),er=_t(d.array(d.type({pubkey:yt,account:d.type({executable:d.boolean(),owner:yt,lamports:d.number(),data:ft,rentEpoch:d.number()})}))),tr=d.type({program:d.string(),parsed:d.unknown(),space:d.number()}),rr=_t(d.array(d.type({pubkey:yt,account:d.type({executable:d.boolean(),owner:yt,lamports:d.number(),data:tr,rentEpoch:d.number()})}))),nr=_t(d.array(d.type({lamports:d.number(),address:yt}))),ir=d.type({executable:d.boolean(),owner:yt,lamports:d.number(),data:ft,rentEpoch:d.number()}),sr=d.type({pubkey:yt,account:ir}),or=d.coerce(d.union([d.instance(n.Buffer),tr]),d.union([mt,tr]),e=>Array.isArray(e)?d.create(e,ft):e),ar=d.type({executable:d.boolean(),owner:yt,lamports:d.number(),data:or,rentEpoch:d.number()}),cr=d.type({pubkey:yt,account:ar}),ur=d.type({state:d.union([d.literal("active"),d.literal("inactive"),d.literal("activating"),d.literal("deactivating")]),active:d.number(),inactive:d.number()}),lr=At(d.array(d.type({signature:d.string(),slot:d.number(),err:Pt,memo:d.nullable(d.string()),blockTime:d.optional(d.nullable(d.number()))}))),dr=At(d.array(d.type({signature:d.string(),slot:d.number(),err:Pt,memo:d.nullable(d.string()),blockTime:d.optional(d.nullable(d.number()))}))),hr=d.type({subscription:d.number(),result:Et(ir)}),br=d.type({pubkey:yt,account:ir}),pr=d.type({subscription:d.number(),result:Et(br)}),gr=d.type({parent:d.number(),slot:d.number(),root:d.number()}),yr=d.type({subscription:d.number(),result:gr}),mr=d.union([d.type({type:d.union([d.literal("firstShredReceived"),d.literal("completed"),d.literal("optimisticConfirmation"),d.literal("root")]),slot:d.number(),timestamp:d.number()}),d.type({type:d.literal("createdBank"),parent:d.number(),slot:d.number(),timestamp:d.number()}),d.type({type:d.literal("frozen"),slot:d.number(),timestamp:d.number(),stats:d.type({numTransactionEntries:d.number(),numSuccessfulTransactions:d.number(),numFailedTransactions:d.number(),maxTransactionsPerEntry:d.number()})}),d.type({type:d.literal("dead"),slot:d.number(),timestamp:d.number(),err:d.string()})]),fr=d.type({subscription:d.number(),result:mr}),kr=d.type({subscription:d.number(),result:Et(d.union([Rt,Ut]))}),wr=d.type({subscription:d.number(),result:d.number()}),Sr=d.type({pubkey:d.string(),gossip:d.nullable(d.string()),tpu:d.nullable(d.string()),rpc:d.nullable(d.string()),version:d.nullable(d.string())}),Ir=d.type({votePubkey:d.string(),nodePubkey:d.string(),activatedStake:d.number(),epochVoteAccount:d.boolean(),epochCredits:d.array(d.tuple([d.number(),d.number(),d.number()])),commission:d.number(),lastVote:d.number(),rootSlot:d.nullable(d.number())}),vr=At(d.type({current:d.array(Ir),delinquent:d.array(Ir)})),Ar=d.union([d.literal("processed"),d.literal("confirmed"),d.literal("finalized")]),_r=d.type({slot:d.number(),confirmations:d.nullable(d.number()),err:Pt,confirmationStatus:d.optional(Ar)}),Er=_t(d.array(d.nullable(_r))),Or=At(d.number()),Tr=d.type({accountKey:yt,writableIndexes:d.array(d.number()),readonlyIndexes:d.array(d.number())}),jr=d.type({signatures:d.array(d.string()),message:d.type({accountKeys:d.array(d.string()),header:d.type({numRequiredSignatures:d.number(),numReadonlySignedAccounts:d.number(),numReadonlyUnsignedAccounts:d.number()}),instructions:d.array(d.type({accounts:d.array(d.number()),data:d.string(),programIdIndex:d.number()})),recentBlockhash:d.string(),addressTableLookups:d.optional(d.array(Tr))})}),Br=d.type({pubkey:yt,signer:d.boolean(),writable:d.boolean(),source:d.optional(d.union([d.literal("transaction"),d.literal("lookupTable")]))}),Nr=d.type({accountKeys:d.array(Br),signatures:d.array(d.string())}),Mr=d.type({parsed:d.unknown(),program:d.string(),programId:yt}),xr=d.type({accounts:d.array(yt),data:d.string(),programId:yt}),Lr=d.union([xr,Mr]),Pr=d.union([d.type({parsed:d.unknown(),program:d.string(),programId:d.string()}),d.type({accounts:d.array(d.string()),data:d.string(),programId:d.string()})]),Rr=d.coerce(Lr,Pr,e=>"accounts"in e?d.create(e,xr):d.create(e,Mr)),Ur=d.type({signatures:d.array(d.string()),message:d.type({accountKeys:d.array(Br),instructions:d.array(Rr),recentBlockhash:d.string(),addressTableLookups:d.optional(d.nullable(d.array(Tr)))})}),zr=d.type({accountIndex:d.number(),mint:d.string(),owner:d.optional(d.string()),uiTokenAmount:Xt}),Wr=d.type({writable:d.array(yt),readonly:d.array(yt)}),Cr=d.type({err:Pt,fee:d.number(),innerInstructions:d.optional(d.nullable(d.array(d.type({index:d.number(),instructions:d.array(d.type({accounts:d.array(d.number()),data:d.string(),programIdIndex:d.number()}))})))),preBalances:d.array(d.number()),postBalances:d.array(d.number()),logMessages:d.optional(d.nullable(d.array(d.string()))),preTokenBalances:d.optional(d.nullable(d.array(zr))),postTokenBalances:d.optional(d.nullable(d.array(zr))),loadedAddresses:d.optional(Wr),computeUnitsConsumed:d.optional(d.number())}),Dr=d.type({err:Pt,fee:d.number(),innerInstructions:d.optional(d.nullable(d.array(d.type({index:d.number(),instructions:d.array(Rr)})))),preBalances:d.array(d.number()),postBalances:d.array(d.number()),logMessages:d.optional(d.nullable(d.array(d.string()))),preTokenBalances:d.optional(d.nullable(d.array(zr))),postTokenBalances:d.optional(d.nullable(d.array(zr))),loadedAddresses:d.optional(Wr),computeUnitsConsumed:d.optional(d.number())}),Fr=d.union([d.literal(0),d.literal("legacy")]),Vr=d.type({pubkey:d.string(),lamports:d.number(),postBalance:d.nullable(d.number()),rewardType:d.nullable(d.string()),commission:d.optional(d.nullable(d.number()))}),Kr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:jr,meta:d.nullable(Cr),version:d.optional(Fr)})),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Qr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Hr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:Nr,meta:d.nullable(Cr),version:d.optional(Fr)})),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Zr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:Ur,meta:d.nullable(Dr),version:d.optional(Fr)})),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),qr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:Nr,meta:d.nullable(Dr),version:d.optional(Fr)})),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Yr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Gr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:jr,meta:d.nullable(Cr)})),rewards:d.optional(d.array(Vr)),blockTime:d.nullable(d.number())}))),Jr=At(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),signatures:d.array(d.string()),blockTime:d.nullable(d.number())}))),Xr=At(d.nullable(d.type({slot:d.number(),meta:d.nullable(Cr),blockTime:d.optional(d.nullable(d.number())),transaction:jr,version:d.optional(Fr)}))),$r=At(d.nullable(d.type({slot:d.number(),transaction:Ur,meta:d.nullable(Dr),blockTime:d.optional(d.nullable(d.number())),version:d.optional(Fr)}))),en=_t(d.type({blockhash:d.string(),feeCalculator:d.type({lamportsPerSignature:d.number()})})),tn=_t(d.type({blockhash:d.string(),lastValidBlockHeight:d.number()})),rn=_t(d.boolean()),nn=d.type({slot:d.number(),numTransactions:d.number(),numSlots:d.number(),samplePeriodSecs:d.number()}),sn=At(d.array(nn)),on=_t(d.nullable(d.type({feeCalculator:d.type({lamportsPerSignature:d.number()})}))),an=At(d.string()),cn=At(d.string()),un=d.type({err:Pt,logs:d.array(d.string()),signature:d.string()}),ln=d.type({result:Et(un),subscription:d.number()}),dn={"solana-client":"js/0.0.0-development"};class hn{constructor(e,t){let r,n,i,s,o,a;this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const e={};return async t=>{var r;const{commitment:n,config:i}=St(t),s=this._buildArgs([],n,void 0,i),o=et(s);return e[o]=null!==(r=e[o])&&void 0!==r?r:(async()=>{try{const t=await this._rpcRequest("getBlockHeight",s),r=d.create(t,At(d.number()));if("error"in r)throw new at(r.error,"failed to get block height information");return r.result}finally{delete e[o]}})(),await e[o]}})(),t&&"string"===typeof t?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,r=t.wsEndpoint,n=t.httpHeaders,i=t.fetch,s=t.fetchMiddleware,o=t.disableRetryOnRateLimit,a=t.httpAgent),this._rpcEndpoint=wt(e),this._rpcWsEndpoint=r||gt(e),this._rpcClient=Dt(e,n,i,s,o,a),this._rpcRequest=Ft(this._rpcClient),this._rpcBatchRequest=Vt(this._rpcClient),this._rpcWebSocket=new ut(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgs([e.toBase58()],r,void 0,n),s=await this._rpcRequest("getBalance",i),o=d.create(s,_t(d.number()));if("error"in o)throw new at(o.error,"failed to get balance for "+e.toBase58());return o.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(e=>e.value).catch(t=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+t)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),r=d.create(t,At(d.nullable(d.number())));if("error"in r)throw new at(r.error,"failed to get block time for slot "+e);return r.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=d.create(e,At(d.number()));if("error"in t)throw new at(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=d.create(e,Gt);if("error"in t)throw new at(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};t="string"===typeof e?{commitment:e}:e?{...e,commitment:e&&e.commitment||this.commitment}:{commitment:this.commitment};const r=await this._rpcRequest("getSupply",[t]),n=d.create(r,Jt);if("error"in n)throw new at(n.error,"failed to get supply");return n.result}async getTokenSupply(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenSupply",r),i=d.create(n,_t(Xt));if("error"in i)throw new at(i.error,"failed to get token supply");return i.result}async getTokenAccountBalance(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenAccountBalance",r),i=d.create(n,_t(Xt));if("error"in i)throw new at(i.error,"failed to get token account balance");return i.result}async getTokenAccountsByOwner(e,t,r){const{commitment:n,config:i}=St(r);let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,n,"base64",i),a=await this._rpcRequest("getTokenAccountsByOwner",o),c=d.create(a,er);if("error"in c)throw new at(c.error,"failed to get token accounts owned by account "+e.toBase58());return c.result}async getParsedTokenAccountsByOwner(e,t,r){let n=[e.toBase58()];"mint"in t?n.push({mint:t.mint.toBase58()}):n.push({programId:t.programId.toBase58()});const i=this._buildArgs(n,r,"jsonParsed"),s=await this._rpcRequest("getTokenAccountsByOwner",i),o=d.create(s,rr);if("error"in o)throw new at(o.error,"failed to get token accounts owned by account "+e.toBase58());return o.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},r=t.filter||t.commitment?[t]:[],n=await this._rpcRequest("getLargestAccounts",r),i=d.create(n,nr);if("error"in i)throw new at(i.error,"failed to get largest accounts");return i.result}async getTokenLargestAccounts(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenLargestAccounts",r),i=d.create(n,$t);if("error"in i)throw new at(i.error,"failed to get token largest accounts");return i.result}async getAccountInfoAndContext(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgs([e.toBase58()],r,"base64",n),s=await this._rpcRequest("getAccountInfo",i),o=d.create(s,_t(d.nullable(ir)));if("error"in o)throw new at(o.error,"failed to get info about account "+e.toBase58());return o.result}async getParsedAccountInfo(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgs([e.toBase58()],r,"jsonParsed",n),s=await this._rpcRequest("getAccountInfo",i),o=d.create(s,_t(d.nullable(ar)));if("error"in o)throw new at(o.error,"failed to get info about account "+e.toBase58());return o.result}async getAccountInfo(e,t){try{const r=await this.getAccountInfoAndContext(e,t);return r.value}catch(r){throw new Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleParsedAccounts(e,t){const{commitment:r,config:n}=St(t),i=e.map(e=>e.toBase58()),s=this._buildArgs([i],r,"jsonParsed",n),o=await this._rpcRequest("getMultipleAccounts",s),a=d.create(o,_t(d.array(d.nullable(ar))));if("error"in a)throw new at(a.error,"failed to get info for accounts "+i);return a.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:r,config:n}=St(t),i=e.map(e=>e.toBase58()),s=this._buildArgs([i],r,"base64",n),o=await this._rpcRequest("getMultipleAccounts",s),a=d.create(o,_t(d.array(d.nullable(ir))));if("error"in a)throw new at(a.error,"failed to get info for accounts "+i);return a.result}async getMultipleAccountsInfo(e,t){const r=await this.getMultipleAccountsInfoAndContext(e,t);return r.value}async getStakeActivation(e,t,r){const{commitment:n,config:i}=St(t),s=this._buildArgs([e.toBase58()],n,void 0,{...i,epoch:null!=r?r:null===i||void 0===i?void 0:i.epoch}),o=await this._rpcRequest("getStakeActivation",s),a=d.create(o,At(ur));if("error"in a)throw new at(a.error,"failed to get Stake Activation "+e.toBase58());return a.result}async getProgramAccounts(e,t){const{commitment:r,config:n}=St(t),{encoding:i,...s}=n||{},o=this._buildArgs([e.toBase58()],r,i||"base64",s),a=await this._rpcRequest("getProgramAccounts",o),c=d.array(sr),u=!0===s.withContext?d.create(a,_t(c)):d.create(a,At(c));if("error"in u)throw new at(u.error,"failed to get accounts owned by program "+e.toBase58());return u.result}async getParsedProgramAccounts(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgs([e.toBase58()],r,"jsonParsed",n),s=await this._rpcRequest("getProgramAccounts",i),o=d.create(s,At(d.array(cr)));if("error"in o)throw new at(o.error,"failed to get accounts owned by program "+e.toBase58());return o.result}async confirmTransaction(e,t){let r,n;if("string"==typeof e)r=e;else{var i;const t=e;if(null!==(i=t.abortSignal)&&void 0!==i&&i.aborted)return Promise.reject(t.abortSignal.reason);r=t.signature}try{n=w.default.decode(r)}catch(s){throw new Error("signature must be base58 encoded: "+r)}return ae(64===n.length,"signature has invalid length"),"string"===typeof e?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:r}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,r)=>{null!=e&&(e.aborted?r(e.reason):e.addEventListener("abort",()=>{r(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let r,n,i=!1;const s=new Promise((s,o)=>{try{r=this.onSignature(t,(e,t)=>{r=void 0;const n={context:t,value:e};s({__type:he.PROCESSED,response:n})},e);const a=new Promise(e=>{null==r?e():n=this._onSubscriptionStateChange(r,t=>{"subscribed"===t&&e()})});(async()=>{if(await a,i)return;const r=await this.getSignatureStatus(t);if(i)return;if(null==r)return;const{context:n,value:c}=r;if(null!=c)if(null!==c&&void 0!==c&&c.err)o(c.err);else{switch(e){case"confirmed":case"single":case"singleGossip":if("processed"===c.confirmationStatus)return;break;case"finalized":case"max":case"root":if("processed"===c.confirmationStatus||"confirmed"===c.confirmationStatus)return;break;case"processed":case"recent":}i=!0,s({__type:he.PROCESSED,response:{context:n,value:c}})}})()}catch(a){o(a)}}),o=()=>{n&&(n(),n=void 0),null!=r&&(this.removeSignatureListener(r),r=void 0)};return{abortConfirmation:o,confirmationPromise:s}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:r,signature:n}}){let i=!1;const s=new Promise(t=>{const n=async()=>{try{const t=await this.getBlockHeight(e);return t}catch(t){return-1}};(async()=>{let e=await n();if(!i){while(e<=r){if(await Me(1e3),i)return;if(e=await n(),i)return}t({__type:he.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:o,confirmationPromise:a}=this.getTransactionConfirmationPromise({commitment:e,signature:n}),c=this.getCancellationPromise(t);let u;try{const e=await Promise.race([c,a,s]);if(e.__type!==he.PROCESSED)throw new Z(n);u=e.response}finally{i=!0,o()}return u}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:r,nonceAccountPubkey:n,nonceValue:i,signature:s}}){let o=!1;const a=new Promise(t=>{let s=i,a=null;const c=async()=>{try{const{context:t,value:i}=await this.getNonceAndContext(n,{commitment:e,minContextSlot:r});return a=t.slot,null===i||void 0===i?void 0:i.nonce}catch(t){return s}};(async()=>{if(s=await c(),!o)while(1){if(i!==s)return void t({__type:he.NONCE_INVALID,slotInWhichNonceDidAdvance:a});if(await Me(2e3),o)return;if(s=await c(),o)return}})()}),{abortConfirmation:c,confirmationPromise:u}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),l=this.getCancellationPromise(t);let d;try{const t=await Promise.race([l,u,a]);if(t.__type===he.PROCESSED)d=t.response;else{var h;let n;while(1){var b;const e=await this.getSignatureStatus(s);if(null==e)break;if(!(e.context.slot<(null!==(b=t.slotInWhichNonceDidAdvance)&&void 0!==b?b:r))){n=e;break}await Me(400)}if(null===(h=n)||void 0===h||!h.value)throw new Y(s);{const t=e||"finalized",{confirmationStatus:r}=n.value;switch(t){case"processed":case"recent":if("processed"!==r&&"confirmed"!==r&&"finalized"!==r)throw new Y(s);break;case"confirmed":case"single":case"singleGossip":if("confirmed"!==r&&"finalized"!==r)throw new Y(s);break;case"finalized":case"max":case"root":if("finalized"!==r)throw new Y(s);break;default:}d={context:n.context,value:{err:n.value.err}}}}}finally{o=!0,c()}return d}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let r;const n=new Promise(t=>{let n=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":n=this._confirmTransactionInitialTimeout||3e4;break}r=setTimeout(()=>t({__type:he.TIMED_OUT,timeoutMs:n}),n)}),{abortConfirmation:i,confirmationPromise:s}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let o;try{const e=await Promise.race([s,n]);if(e.__type!==he.PROCESSED)throw new q(t,e.timeoutMs/1e3);o=e.response}finally{clearTimeout(r),i()}return o}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=d.create(e,At(d.array(Sr)));if("error"in t)throw new at(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getVoteAccounts",t),n=d.create(r,vr);if("error"in n)throw new at(n.error,"failed to get vote accounts");return n.result}async getSlot(e){const{commitment:t,config:r}=St(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getSlot",n),s=d.create(i,At(d.number()));if("error"in s)throw new at(s.error,"failed to get slot");return s.result}async getSlotLeader(e){const{commitment:t,config:r}=St(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getSlotLeader",n),s=d.create(i,At(d.string()));if("error"in s)throw new at(s.error,"failed to get slot leader");return s.result}async getSlotLeaders(e,t){const r=[e,t],n=await this._rpcRequest("getSlotLeaders",r),i=d.create(n,At(d.array(yt)));if("error"in i)throw new at(i.error,"failed to get slot leaders");return i.result}async getSignatureStatus(e,t){const{context:r,value:n}=await this.getSignatureStatuses([e],t);ae(1===n.length);const i=n[0];return{context:r,value:i}}async getSignatureStatuses(e,t){const r=[e];t&&r.push(t);const n=await this._rpcRequest("getSignatureStatuses",r),i=d.create(n,Er);if("error"in i)throw new at(i.error,"failed to get signature status");return i.result}async getTransactionCount(e){const{commitment:t,config:r}=St(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getTransactionCount",n),s=d.create(i,At(d.number()));if("error"in s)throw new at(s.error,"failed to get transaction count");return s.result}async getTotalSupply(e){const t=await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0});return t.value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getInflationGovernor",t),n=d.create(r,Kt);if("error"in n)throw new at(n.error,"failed to get inflation");return n.result}async getInflationReward(e,t,r){const{commitment:n,config:i}=St(r),s=this._buildArgs([e.map(e=>e.toBase58())],n,void 0,{...i,epoch:null!=t?t:null===i||void 0===i?void 0:i.epoch}),o=await this._rpcRequest("getInflationReward",s),a=d.create(o,jt);if("error"in a)throw new at(a.error,"failed to get inflation reward");return a.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=d.create(e,Qt);if("error"in t)throw new at(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:r}=St(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getEpochInfo",n),s=d.create(i,Zt);if("error"in s)throw new at(s.error,"failed to get epoch info");return s.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=d.create(e,qt);if("error"in t)throw new at(t.error,"failed to get epoch schedule");const r=t.result;return new it(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=d.create(e,Yt);if("error"in t)throw new at(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getMinimumBalanceForRentExemption",r),i=d.create(n,Or);return"error"in i?0:i.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getRecentBlockhash",t),n=d.create(r,en);if("error"in n)throw new at(n.error,"failed to get recent blockhash");return n.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),r=d.create(t,sn);if("error"in r)throw new at(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getFeeCalculatorForBlockhash",r),i=d.create(n,on);if("error"in i)throw new at(i.error,"failed to get fee calculator");const{context:s,value:o}=i.result;return{context:s,value:null!==o?o.feeCalculator:null}}async getFeeForMessage(e,t){const r=N(e.serialize()).toString("base64"),n=this._buildArgs([r],t),i=await this._rpcRequest("getFeeForMessage",n),s=d.create(i,_t(d.nullable(d.number())));if("error"in s)throw new at(s.error,"failed to get fee for message");if(null===s.result)throw new Error("invalid blockhash");return s.result}async getRecentPrioritizationFees(e){var t;const r=null===e||void 0===e||null===(t=e.lockedWritableAccounts)||void 0===t?void 0:t.map(e=>e.toBase58()),n=null!==r&&void 0!==r&&r.length?[r]:[],i=await this._rpcRequest("getRecentPrioritizationFees",n),s=d.create(i,Ht);if("error"in s)throw new at(s.error,"failed to get recent prioritization fees");return s.result}async getRecentBlockhash(e){try{const t=await this.getRecentBlockhashAndContext(e);return t.value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{const t=await this.getLatestBlockhashAndContext(e);return t.value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:r}=St(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getLatestBlockhash",n),s=d.create(i,tn);if("error"in s)throw new at(s.error,"failed to get latest blockhash");return s.result}async isBlockhashValid(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgs([e],r,void 0,n),s=await this._rpcRequest("isBlockhashValid",i),o=d.create(s,rn);if("error"in o)throw new at(o.error,"failed to determine if the blockhash `"+e+"`is valid");return o.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=d.create(e,At(zt));if("error"in t)throw new at(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=d.create(e,At(d.string()));if("error"in t)throw new at(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgsAtLeastConfirmed([e],r,void 0,n),s=await this._rpcRequest("getBlock",i);try{switch(null===n||void 0===n?void 0:n.transactionDetails){case"accounts":{const e=d.create(s,Hr);if("error"in e)throw e.error;return e.result}case"none":{const e=d.create(s,Qr);if("error"in e)throw e.error;return e.result}default:{const e=d.create(s,Kr);if("error"in e)throw e.error;const{result:t}=e;return t?{...t,transactions:t.transactions.map(({transaction:e,meta:t,version:r})=>({meta:t,transaction:{...e,message:Ot(r,e.message)},version:r}))}:null}}}catch(o){throw new at(o,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),s=await this._rpcRequest("getBlock",i);try{switch(null===n||void 0===n?void 0:n.transactionDetails){case"accounts":{const e=d.create(s,qr);if("error"in e)throw e.error;return e.result}case"none":{const e=d.create(s,Yr);if("error"in e)throw e.error;return e.result}default:{const e=d.create(s,Zr);if("error"in e)throw e.error;return e.result}}}catch(o){throw new at(o,"failed to get block")}}async getBlockProduction(e){let t,r;if("string"===typeof e)r=e;else if(e){const{commitment:n,...i}=e;r=n,t=i}const n=this._buildArgs([],r,"base64",t),i=await this._rpcRequest("getBlockProduction",n),s=d.create(i,Ct);if("error"in s)throw new at(s.error,"failed to get block production information");return s.result}async getTransaction(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgsAtLeastConfirmed([e],r,void 0,n),s=await this._rpcRequest("getTransaction",i),o=d.create(s,Xr);if("error"in o)throw new at(o.error,"failed to get transaction");const a=o.result;return a?{...a,transaction:{...a.transaction,message:Ot(a.version,a.transaction.message)}}:a}async getParsedTransaction(e,t){const{commitment:r,config:n}=St(t),i=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),s=await this._rpcRequest("getTransaction",i),o=d.create(s,$r);if("error"in o)throw new at(o.error,"failed to get transaction");return o.result}async getParsedTransactions(e,t){const{commitment:r,config:n}=St(t),i=e.map(e=>{const t=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n);return{methodName:"getTransaction",args:t}}),s=await this._rpcBatchRequest(i),o=s.map(e=>{const t=d.create(e,$r);if("error"in t)throw new at(t.error,"failed to get transactions");return t.result});return o}async getTransactions(e,t){const{commitment:r,config:n}=St(t),i=e.map(e=>{const t=this._buildArgsAtLeastConfirmed([e],r,void 0,n);return{methodName:"getTransaction",args:t}}),s=await this._rpcBatchRequest(i),o=s.map(e=>{const t=d.create(e,Xr);if("error"in t)throw new at(t.error,"failed to get transactions");const r=t.result;return r?{...r,transaction:{...r.transaction,message:Ot(r.version,r.transaction.message)}}:r});return o}async getConfirmedBlock(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedBlock",r),i=d.create(n,Gr);if("error"in i)throw new at(i.error,"failed to get confirmed block");const s=i.result;if(!s)throw new Error("Confirmed block "+e+" not found");const o={...s,transactions:s.transactions.map(({transaction:e,meta:t})=>{const r=new ue(e.message);return{meta:t,transaction:{...e,message:r}}})};return{...o,transactions:o.transactions.map(({transaction:e,meta:t})=>({meta:t,transaction:ge.populate(e.message,e.signatures)}))}}async getBlocks(e,t,r){const n=this._buildArgsAtLeastConfirmed(void 0!==t?[e,t]:[e],r),i=await this._rpcRequest("getBlocks",n),s=d.create(i,At(d.array(d.number())));if("error"in s)throw new at(s.error,"failed to get blocks");return s.result}async getBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getBlock",r),i=d.create(n,Jr);if("error"in i)throw new at(i.error,"failed to get block");const s=i.result;if(!s)throw new Error("Block "+e+" not found");return s}async getConfirmedBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getConfirmedBlock",r),i=d.create(n,Jr);if("error"in i)throw new at(i.error,"failed to get confirmed block");const s=i.result;if(!s)throw new Error("Confirmed block "+e+" not found");return s}async getConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedTransaction",r),i=d.create(n,Xr);if("error"in i)throw new at(i.error,"failed to get transaction");const s=i.result;if(!s)return s;const o=new ue(s.transaction.message),a=s.transaction.signatures;return{...s,transaction:ge.populate(o,a)}}async getParsedConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),n=await this._rpcRequest("getConfirmedTransaction",r),i=d.create(n,$r);if("error"in i)throw new at(i.error,"failed to get confirmed transaction");return i.result}async getParsedConfirmedTransactions(e,t){const r=e.map(e=>{const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed");return{methodName:"getConfirmedTransaction",args:r}}),n=await this._rpcBatchRequest(r),i=n.map(e=>{const t=d.create(e,$r);if("error"in t)throw new at(t.error,"failed to get confirmed transactions");return t.result});return i}async getConfirmedSignaturesForAddress(e,t,r){let n={},i=await this.getFirstAvailableBlock();while(!("until"in n)){if(t--,t<=0||t<i)break;try{const e=await this.getConfirmedBlockSignatures(t,"finalized");e.signatures.length>0&&(n.until=e.signatures[e.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}}let s=await this.getSlot("finalized");while(!("before"in n)){if(r++,r>s)break;try{const e=await this.getConfirmedBlockSignatures(r);e.signatures.length>0&&(n.before=e.signatures[e.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}}const o=await this.getConfirmedSignaturesForAddress2(e,n);return o.map(e=>e.signature)}async getConfirmedSignaturesForAddress2(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),i=await this._rpcRequest("getConfirmedSignaturesForAddress2",n),s=d.create(i,lr);if("error"in s)throw new at(s.error,"failed to get confirmed signatures for address");return s.result}async getSignaturesForAddress(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),i=await this._rpcRequest("getSignaturesForAddress",n),s=d.create(i,dr);if("error"in s)throw new at(s.error,"failed to get signatures for address");return s.result}async getAddressLookupTable(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let i=null;return null!==n&&(i=new ht({key:e,state:ht.deserialize(n.data)})),{context:r,value:i}}async getNonceAndContext(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let i=null;return null!==n&&(i=ze.fromAccountData(n.data)),{context:r,value:i}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(e=>e.value).catch(t=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+t)})}async requestAirdrop(e,t){const r=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),n=d.create(r,an);if("error"in n)throw new at(n.error,`airdrop to ${e.toBase58()} failed`);return n.result}async _blockhashWithExpiryBlockHeight(e){if(!e){while(this._pollingBlockhash)await Me(100);const e=Date.now()-this._blockhashInfo.lastFetch,t=e>=kt;if(null!==this._blockhashInfo.latestBlockhash&&!t)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,r=t?t.blockhash:null;for(let n=0;n<50;n++){const e=await this.getLatestBlockhash("finalized");if(r!==e.blockhash)return this._blockhashInfo={latestBlockhash:e,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},e;await Me(Se/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:r}=St(e),n=this._buildArgs([],t,"base64",r),i=await this._rpcRequest("getStakeMinimumDelegation",n),s=d.create(i,_t(d.number()));if("error"in s)throw new at(s.error,"failed to get stake minimum delegation");return s.result}async simulateTransaction(e,t,r){if("message"in e){const i=e,s=i.serialize(),o=n.Buffer.from(s).toString("base64");if(Array.isArray(t)||void 0!==r)throw new Error("Invalid arguments");const a=t||{};a.encoding="base64","commitment"in a||(a.commitment=this.commitment);const c=[o,a],u=await this._rpcRequest("simulateTransaction",c),l=d.create(u,Wt);if("error"in l)throw new Error("failed to simulate transaction: "+l.error.message);return l.result}let i;if(e instanceof ge){let t=e;i=new ge,i.feePayer=t.feePayer,i.instructions=e.instructions,i.nonceInfo=t.nonceInfo,i.signatures=t.signatures}else i=ge.populate(e),i._message=i._json=void 0;if(void 0!==t&&!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(i.nonceInfo&&s)i.sign(...s);else{let e=this._disableBlockhashCaching;for(;;){const t=await this._blockhashWithExpiryBlockHeight(e);if(i.lastValidBlockHeight=t.lastValidBlockHeight,i.recentBlockhash=t.blockhash,!s)break;if(i.sign(...s),!i.signature)throw new Error("!signature");const r=i.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(r)&&!this._blockhashInfo.transactionSignatures.includes(r)){this._blockhashInfo.simulatedSignatures.push(r);break}e=!0}}const o=i._compile(),a=o.serialize(),c=i._serialize(a),u=c.toString("base64"),l={encoding:"base64",commitment:this.commitment};if(r){const e=(Array.isArray(r)?r:o.nonProgramIds()).map(e=>e.toBase58());l["accounts"]={encoding:"base64",addresses:e}}s&&(l.sigVerify=!0);const h=[u,l],b=await this._rpcRequest("simulateTransaction",h),p=d.create(b,Wt);if("error"in p){let e;if("data"in p.error&&(e=p.error.data.logs,e&&Array.isArray(e))){const t="\n    ";e.join(t)}throw new st("failed to simulate transaction: "+p.error.message,e)}return p.result}async sendTransaction(e,t,r){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const r=e.serialize();return await this.sendRawTransaction(r,t)}if(void 0===t||!Array.isArray(t))throw new Error("Invalid arguments");const n=t;if(e.nonceInfo)e.sign(...n);else{let t=this._disableBlockhashCaching;for(;;){const r=await this._blockhashWithExpiryBlockHeight(t);if(e.lastValidBlockHeight=r.lastValidBlockHeight,e.recentBlockhash=r.blockhash,e.sign(...n),!e.signature)throw new Error("!signature");const i=e.signature.toString("base64");if(!this._blockhashInfo.transactionSignatures.includes(i)){this._blockhashInfo.transactionSignatures.push(i);break}t=!0}}const i=e.serialize();return await this.sendRawTransaction(i,r)}async sendRawTransaction(e,t){const r=N(e).toString("base64"),n=await this.sendEncodedTransaction(r,t);return n}async sendEncodedTransaction(e,t){const r={encoding:"base64"},n=t&&t.skipPreflight,i=t&&t.preflightCommitment||this.commitment;t&&null!=t.maxRetries&&(r.maxRetries=t.maxRetries),t&&null!=t.minContextSlot&&(r.minContextSlot=t.minContextSlot),n&&(r.skipPreflight=n),i&&(r.preflightCommitment=i);const s=[e,r],o=await this._rpcRequest("sendTransaction",s),a=d.create(o,cn);if("error"in a){let e;throw"data"in a.error&&(e=a.error.data.logs),new st("failed to send transaction: "+a.error.message,e)}return a.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1}_wsOnClose(e){this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),1e3!==e?(this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([e,t])=>{this._setSubscription(e,{...t,state:"pending"})})):this._updateSubscriptions()}_setSubscription(e,t){var r;const n=null===(r=this._subscriptionsByHash[e])||void 0===r?void 0:r.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const r=this._subscriptionStateChangeCallbacksByHash[e];r&&r.forEach(e=>{try{e(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var r;const n=this._subscriptionHashByClientSubscriptionId[e];if(null==n)return()=>{};const i=(r=this._subscriptionStateChangeCallbacksByHash)[n]||(r[n]=new Set);return i.add(t),()=>{i.delete(t),0===i.size&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(0===Object.keys(this._subscriptionsByHash).length)return void(this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(e){Error}},500)));if(null!==this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected)return void this._rpcWebSocket.connect();const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async e=>{const r=this._subscriptionsByHash[e];if(void 0!==r)switch(r.state){case"pending":case"unsubscribed":if(0===r.callbacks.size)return delete this._subscriptionsByHash[e],"unsubscribed"===r.state&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],void await this._updateSubscriptions();await(async()=>{const{args:n,method:i}=r;try{this._setSubscription(e,{...r,state:"subscribing"});const t=await this._rpcWebSocket.call(i,n);this._setSubscription(e,{...r,serverSubscriptionId:t,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[t]=r.callbacks,await this._updateSubscriptions()}catch(s){if(Error,!t())return;this._setSubscription(e,{...r,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":0===r.callbacks.size&&await(async()=>{const{serverSubscriptionId:n,unsubscribeMethod:i}=r;if(this._subscriptionsAutoDisposedByRpc.has(n))this._subscriptionsAutoDisposedByRpc.delete(n);else{this._setSubscription(e,{...r,state:"unsubscribing"}),this._setSubscription(e,{...r,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[n])}catch(s){if(Error,!t())return;return this._setSubscription(e,{...r,state:"subscribed"}),void await this._updateSubscriptions()}}this._setSubscription(e,{...r,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const r=this._subscriptionCallbacksByServerSubscriptionId[e];void 0!==r&&r.forEach(e=>{try{e(...t)}catch(r){}})}_wsOnAccountNotification(e){const{result:t,subscription:r}=d.create(e,hr);this._handleServerNotification(r,[t.value,t.context])}_makeSubscription(e,t){const r=this._nextClientSubscriptionId++,n=et([e.method,t],!0),i=this._subscriptionsByHash[n];return void 0===i?this._subscriptionsByHash[n]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:i.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[r]=n,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const t=this._subscriptionsByHash[n];ae(void 0!==t,"Could not find a `Subscription` when tearing down client subscription #"+r),t.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(e,t,r){const n=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},n)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:r}=d.create(e,pr);this._handleServerNotification(r,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,r,n){const i=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",n?{filters:n}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},i)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,r){const n=this._buildArgs(["object"===typeof e?{mentions:[e.toString()]}:e],r||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},n)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:r}=d.create(e,ln);this._handleServerNotification(r,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:r}=d.create(e,yr);this._handleServerNotification(r,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:r}=d.create(e,fr);this._handleServerNotification(r,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];r&&await r()}_buildArgs(e,t,r,n){const i=t||this._commitment;if(i||r||n){let t={};r&&(t.encoding=r),i&&(t.commitment=i),n&&(t=Object.assign(t,n)),e.push(t)}return e}_buildArgsAtLeastConfirmed(e,t,r,n){const i=t||this._commitment;if(i&&!["confirmed","finalized"].includes(i))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,r,n)}_wsOnSignatureNotification(e){const{result:t,subscription:r}=d.create(e,kr);"receivedSignature"!==t.value&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,"receivedSignature"===t.value?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,r){const n=this._buildArgs([e],r||this._commitment||"finalized"),i=this._makeSubscription({callback:(e,r)=>{if("status"===e.type){t(e.result,r);try{this.removeSignatureListener(i)}catch(n){}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},n);return i}onSignatureWithOptions(e,t,r){const{commitment:n,...i}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},s=this._buildArgs([e],n,void 0,i),o=this._makeSubscription({callback:(e,r)=>{t(e,r);try{this.removeSignatureListener(o)}catch(n){}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:r}=d.create(e,wr);this._handleServerNotification(r,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class bn{constructor(e){this._keypair=void 0,this._keypair=null!==e&&void 0!==e?e:E()}static generate(){return new bn(E())}static fromSecretKey(e,t){if(64!==e.byteLength)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const t=e.slice(0,32),n=O(t);for(let e=0;e<32;e++)if(r[e]!==n[e])throw new Error("provided secretKey is invalid")}return new bn({publicKey:r,secretKey:e})}static fromSeed(e){const t=O(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new bn({publicKey:t,secretKey:r})}get publicKey(){return new D(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const pn=Object.freeze({CreateLookupTable:{index:0,layout:S.struct([S.u32("instruction"),De("recentSlot"),S.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:S.struct([S.u32("instruction")])},ExtendLookupTable:{index:2,layout:S.struct([S.u32("instruction"),De(),S.seq(J(),S.offset(S.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:S.struct([S.u32("instruction")])},CloseLookupTable:{index:4,layout:S.struct([S.u32("instruction")])}});class gn{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=S.u32("instruction"),r=t.decode(e.data);let n;for(const[i,s]of Object.entries(pn))if(s.index==r){n=i;break}if(!n)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return n}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:t}=Le(pn.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:t}=Le(pn.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(e=>new D(e))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(yn.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}class yn{constructor(){}static createLookupTable(e){const[t,r]=D.findProgramAddressSync([e.authority.toBuffer(),l.toBufferLE(BigInt(e.recentSlot),8)],this.programId),n=pn.CreateLookupTable,i=xe(n,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),s=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Ke.programId,isSigner:!1,isWritable:!1}];return[new pe({programId:this.programId,keys:s,data:i}),t]}static freezeLookupTable(e){const t=pn.FreezeLookupTable,r=xe(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new pe({programId:this.programId,keys:n,data:r})}static extendLookupTable(e){const t=pn.ExtendLookupTable,r=xe(t,{addresses:e.addresses.map(e=>e.toBytes())}),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&n.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Ke.programId,isSigner:!1,isWritable:!1}),new pe({programId:this.programId,keys:n,data:r})}static deactivateLookupTable(e){const t=pn.DeactivateLookupTable,r=xe(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new pe({programId:this.programId,keys:n,data:r})}static closeLookupTable(e){const t=pn.CloseLookupTable,r=xe(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new pe({programId:this.programId,keys:n,data:r})}}yn.programId=new D("AddressLookupTab1e1111111111111111111111111");class mn{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=S.u8("instruction"),r=t.decode(e.data);let n;for(const[i,s]of Object.entries(fn))if(s.index==r){n=i;break}if(!n)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return n}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:r}=Le(fn.RequestUnits,e.data);return{units:t,additionalFee:r}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=Le(fn.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=Le(fn.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=Le(fn.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(kn.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const fn=Object.freeze({RequestUnits:{index:0,layout:S.struct([S.u8("instruction"),S.u32("units"),S.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:S.struct([S.u8("instruction"),S.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:S.struct([S.u8("instruction"),S.u32("units")])},SetComputeUnitPrice:{index:3,layout:S.struct([S.u8("instruction"),De("microLamports")])}});class kn{constructor(){}static requestUnits(e){const t=fn.RequestUnits,r=xe(t,e);return new pe({keys:[],programId:this.programId,data:r})}static requestHeapFrame(e){const t=fn.RequestHeapFrame,r=xe(t,e);return new pe({keys:[],programId:this.programId,data:r})}static setComputeUnitLimit(e){const t=fn.SetComputeUnitLimit,r=xe(t,e);return new pe({keys:[],programId:this.programId,data:r})}static setComputeUnitPrice(e){const t=fn.SetComputeUnitPrice,r=xe(t,{microLamports:BigInt(e.microLamports)});return new pe({keys:[],programId:this.programId,data:r})}}kn.programId=new D("ComputeBudget111111111111111111111111111111");const wn=64,Sn=32,In=64,vn=S.struct([S.u8("numSignatures"),S.u8("padding"),S.u16("signatureOffset"),S.u16("signatureInstructionIndex"),S.u16("publicKeyOffset"),S.u16("publicKeyInstructionIndex"),S.u16("messageDataOffset"),S.u16("messageDataSize"),S.u16("messageInstructionIndex")]);class An{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:i,instructionIndex:s}=e;ae(t.length===Sn,`Public Key must be ${Sn} bytes but received ${t.length} bytes`),ae(i.length===In,`Signature must be ${In} bytes but received ${i.length} bytes`);const o=vn.span,a=o+t.length,c=a+i.length,u=1,l=n.Buffer.alloc(c+r.length),d=null==s?65535:s;return vn.encode({numSignatures:u,padding:0,signatureOffset:a,signatureInstructionIndex:d,publicKeyOffset:o,publicKeyInstructionIndex:d,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:d},l),l.fill(t,o),l.fill(i,a),l.fill(r,c),new pe({keys:[],programId:An.programId,data:l})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;ae(t.length===wn,`Private key must be ${wn} bytes but received ${t.length} bytes`);try{const e=bn.fromSecretKey(t),i=e.publicKey.toBytes(),s=j(r,e.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:s,instructionIndex:n})}catch(i){throw new Error("Error creating instruction; "+i)}}}An.programId=new D("Ed25519SigVerify111111111111111111111111111");const _n=(e,t)=>{const r=y.secp256k1.sign(e,t);return[r.toCompactRawBytes(),r.recovery]};y.secp256k1.utils.isValidPrivateKey;const En=y.secp256k1.getPublicKey,On=32,Tn=20,jn=64,Bn=11,Nn=S.struct([S.u8("numSignatures"),S.u16("signatureOffset"),S.u8("signatureInstructionIndex"),S.u16("ethAddressOffset"),S.u8("ethAddressInstructionIndex"),S.u16("messageDataOffset"),S.u16("messageDataSize"),S.u8("messageInstructionIndex"),S.blob(20,"ethAddress"),S.blob(64,"signature"),S.u8("recoveryId")]);class Mn{constructor(){}static publicKeyToEthAddress(e){ae(e.length===jn,`Public key must be ${jn} bytes but received ${e.length} bytes`);try{return n.Buffer.from(g.keccak_256(N(e))).slice(-Tn)}catch(t){throw new Error("Error constructing Ethereum address: "+t)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,recoveryId:i,instructionIndex:s}=e;return Mn.createInstructionWithEthAddress({ethAddress:Mn.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:i,instructionIndex:s})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:i,recoveryId:s,instructionIndex:o=0}=e;let a;a="string"===typeof t?t.startsWith("0x")?n.Buffer.from(t.substr(2),"hex"):n.Buffer.from(t,"hex"):t,ae(a.length===Tn,`Address must be ${Tn} bytes but received ${a.length} bytes`);const c=1+Bn,u=c,l=c+a.length,d=l+i.length+1,h=1,b=n.Buffer.alloc(Nn.span+r.length);return Nn.encode({numSignatures:h,signatureOffset:l,signatureInstructionIndex:o,ethAddressOffset:u,ethAddressInstructionIndex:o,messageDataOffset:d,messageDataSize:r.length,messageInstructionIndex:o,signature:N(i),ethAddress:N(a),recoveryId:s},b),b.fill(N(r),Nn.span),new pe({keys:[],programId:Mn.programId,data:b})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:i}=e;ae(t.length===On,`Private key must be ${On} bytes but received ${t.length} bytes`);try{const e=N(t),s=En(e,!1).slice(1),o=n.Buffer.from(g.keccak_256(N(r))),[a,c]=_n(o,e);return this.createInstructionWithPublicKey({publicKey:s,message:r,signature:a,recoveryId:c,instructionIndex:i})}catch(s){throw new Error("Error creating instruction; "+s)}}}var xn;Mn.programId=new D("KeccakSecp256k11111111111111111111111111111");const Ln=new D("StakeConfig11111111111111111111111111111111");class Pn{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class Rn{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}xn=Rn,Rn.default=new xn(0,0,D.default);class Un{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=S.u32("instruction"),r=t.decode(e.data);let n;for(const[i,s]of Object.entries(zn))if(s.index==r){n=i;break}if(!n)throw new Error("Instruction type incorrect; not a StakeInstruction");return n}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:r}=Le(zn.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new Pn(new D(t.staker),new D(t.withdrawer)),lockup:new Rn(r.unixTimestamp,r.epoch,new D(r.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),Le(zn.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:r}=Le(zn.Authorize,e.data),n={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new D(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(n.custodianPubkey=e.keys[3].pubkey),n}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:r,authoritySeed:n,authorityOwner:i}=Le(zn.AuthorizeWithSeed,e.data),s={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:n,authorityOwner:new D(i),newAuthorizedPubkey:new D(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(s.custodianPubkey=e.keys[3].pubkey),s}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=Le(zn.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),Le(zn.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=Le(zn.Withdraw,e.data),r={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(r.custodianPubkey=e.keys[5].pubkey),r}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),Le(zn.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(Cn.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const zn=Object.freeze({Initialize:{index:0,layout:S.struct([S.u32("instruction"),ee(),te()])},Authorize:{index:1,layout:S.struct([S.u32("instruction"),J("newAuthorized"),S.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:S.struct([S.u32("instruction")])},Split:{index:3,layout:S.struct([S.u32("instruction"),S.ns64("lamports")])},Withdraw:{index:4,layout:S.struct([S.u32("instruction"),S.ns64("lamports")])},Deactivate:{index:5,layout:S.struct([S.u32("instruction")])},Merge:{index:7,layout:S.struct([S.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:S.struct([S.u32("instruction"),J("newAuthorized"),S.u32("stakeAuthorizationType"),$("authoritySeed"),J("authorityOwner")])}}),Wn=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class Cn{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:n}=e,i=n||Rn.default,s=zn.Initialize,o=xe(s,{authorized:{staker:N(r.staker.toBuffer()),withdrawer:N(r.withdrawer.toBuffer())},lockup:{unixTimestamp:i.unixTimestamp,epoch:i.epoch,custodian:N(i.custodian.toBuffer())}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ee,isSigner:!1,isWritable:!1}],programId:this.programId,data:o};return new pe(a)}static createAccountWithSeed(e){const t=new ge;t.add(Ke.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:i}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:i}))}static createAccount(e){const t=new ge;t.add(Ke.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:i}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:i}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,i=zn.Delegate,s=xe(i);return(new ge).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:Be,isSigner:!1,isWritable:!1},{pubkey:Ln,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:i,custodianPubkey:s}=e,o=zn.Authorize,a=xe(o,{newAuthorized:N(n.toBuffer()),stakeAuthorizationType:i.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ie,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return s&&c.push({pubkey:s,isSigner:!0,isWritable:!1}),(new ge).add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:i,newAuthorizedPubkey:s,stakeAuthorizationType:o,custodianPubkey:a}=e,c=zn.AuthorizeWithSeed,u=xe(c,{newAuthorized:N(s.toBuffer()),stakeAuthorizationType:o.index,authoritySeed:n,authorityOwner:N(i.toBuffer())}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:Ie,isSigner:!1,isWritable:!1}];return a&&l.push({pubkey:a,isSigner:!0,isWritable:!1}),(new ge).add({keys:l,programId:this.programId,data:u})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:i}=e,s=zn.Split,o=xe(s,{lamports:i});return new pe({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static split(e,t){const r=new ge;return r.add(Ke.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),r.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:i,basePubkey:s,seed:o,lamports:a}=e,c=new ge;return c.add(Ke.allocate({accountPubkey:i,basePubkey:s,seed:o,space:this.space,programId:this.programId})),t&&t>0&&c.add(Ke.transfer({fromPubkey:e.authorizedPubkey,toPubkey:i,lamports:t})),c.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:n,splitStakePubkey:i,lamports:a}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,i=zn.Merge,s=xe(i);return(new ge).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:Be,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:i,custodianPubkey:s}=e,o=zn.Withdraw,a=xe(o,{lamports:i}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:Be,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return s&&c.push({pubkey:s,isSigner:!0,isWritable:!1}),(new ge).add({keys:c,programId:this.programId,data:a})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,n=zn.Deactivate,i=xe(n);return(new ge).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}}Cn.programId=new D("Stake11111111111111111111111111111111111111"),Cn.space=200;class Dn{constructor(e,t,r,n){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=r,this.commission=n}}class Fn{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=S.u32("instruction"),r=t.decode(e.data);let n;for(const[i,s]of Object.entries(Vn))if(s.index==r){n=i;break}if(!n)throw new Error("Instruction type incorrect; not a VoteInstruction");return n}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=Le(Vn.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new Dn(new D(t.nodePubkey),new D(t.authorizedVoter),new D(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:r}=Le(Vn.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new D(t),voteAuthorizationType:{index:r}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:r,newAuthorized:n,voteAuthorizationType:i}}=Le(Vn.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new D(t),currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:new D(n),voteAuthorizationType:{index:i},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=Le(Vn.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Qn.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const Vn=Object.freeze({InitializeAccount:{index:0,layout:S.struct([S.u32("instruction"),re()])},Authorize:{index:1,layout:S.struct([S.u32("instruction"),J("newAuthorized"),S.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:S.struct([S.u32("instruction"),S.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:S.struct([S.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:S.struct([S.u32("instruction"),ne()])}}),Kn=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class Qn{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:n}=e,i=Vn.InitializeAccount,s=xe(i,{voteInit:{nodePubkey:N(n.nodePubkey.toBuffer()),authorizedVoter:N(n.authorizedVoter.toBuffer()),authorizedWithdrawer:N(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),o={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ee,isSigner:!1,isWritable:!1},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s};return new pe(o)}static createAccount(e){const t=new ge;return t.add(Ke.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:i}=e,s=Vn.Authorize,o=xe(s,{newAuthorized:N(n.toBuffer()),voteAuthorizationType:i.index}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ge).add({keys:a,programId:this.programId,data:o})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:i,voteAuthorizationType:s,votePubkey:o}=e,a=Vn.AuthorizeWithSeed,c=xe(a,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:N(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:N(i.toBuffer()),voteAuthorizationType:s.index}}),u=[{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Ie,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return(new ge).add({keys:u,programId:this.programId,data:c})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:i}=e,s=Vn.Withdraw,o=xe(s,{lamports:n}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ge).add({keys:a,programId:this.programId,data:o})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return Qn.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,nodePubkey:n}=e,i=Vn.UpdateValidatorIdentity,s=xe(i),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ge).add({keys:o,programId:this.programId,data:s})}}Qn.programId=new D("Vote111111111111111111111111111111111111111"),Qn.space=3762;const Hn=new D("Va1idator1nfo111111111111111111111111111111"),Zn=d.type({name:d.string(),website:d.optional(d.string()),details:d.optional(d.string()),keybaseUsername:d.optional(d.string())});class qn{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];const r=se(t);if(2!==r)return null;const i=[];for(let n=0;n<2;n++){const e=new D(t.slice(0,z));t=t.slice(z);const r=1===t.slice(0,1)[0];t=t.slice(1),i.push({publicKey:e,isSigner:r})}if(i[0].publicKey.equals(Hn)&&i[1].isSigner){const e=$().decode(n.Buffer.from(t)),r=JSON.parse(e);return d.assert(r,Zn),new qn(i[1].publicKey,r)}return null}}const Yn=new D("Vote111111111111111111111111111111111111111"),Gn=S.struct([J("nodePubkey"),J("authorizedWithdrawer"),S.u8("commission"),S.nu64(),S.seq(S.struct([S.nu64("slot"),S.u32("confirmationCount")]),S.offset(S.u32(),-8),"votes"),S.u8("rootSlotValid"),S.nu64("rootSlot"),S.nu64(),S.seq(S.struct([S.nu64("epoch"),J("authorizedVoter")]),S.offset(S.u32(),-8),"authorizedVoters"),S.struct([S.seq(S.struct([J("authorizedPubkey"),S.nu64("epochOfLastAuthorizedSwitch"),S.nu64("targetEpoch")]),32,"buf"),S.nu64("idx"),S.u8("isEmpty")],"priorVoters"),S.nu64(),S.seq(S.struct([S.nu64("epoch"),S.nu64("credits"),S.nu64("prevCredits")]),S.offset(S.u32(),-8),"epochCredits"),S.struct([S.nu64("slot"),S.nu64("timestamp")],"lastTimestamp")]);class Jn{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const t=4,r=Gn.decode(N(e),t);let n=r.rootSlot;return r.rootSlotValid||(n=null),new Jn({nodePubkey:new D(r.nodePubkey),authorizedWithdrawer:new D(r.authorizedWithdrawer),commission:r.commission,votes:r.votes,rootSlot:n,authorizedVoters:r.authorizedVoters.map(Xn),priorVoters:ei(r.priorVoters),epochCredits:r.epochCredits,lastTimestamp:r.lastTimestamp})}}function Xn({authorizedVoter:e,epoch:t}){return{epoch:t,authorizedVoter:new D(e)}}function $n({authorizedPubkey:e,epochOfLastAuthorizedSwitch:t,targetEpoch:r}){return{authorizedPubkey:new D(e),epochOfLastAuthorizedSwitch:t,targetEpoch:r}}function ei({buf:e,idx:t,isEmpty:r}){return r?[]:[...e.slice(t+1).map($n),...e.slice(0,t).map($n)]}const ti={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function ri(e,t){const r=!1===t?"http":"https";if(!e)return ti[r]["devnet"];const n=ti[r][e];if(!n)throw new Error(`Unknown ${r} cluster: ${e}`);return n}async function ni(e,t,r,n){let i,s;r&&Object.prototype.hasOwnProperty.call(r,"lastValidBlockHeight")||r&&Object.prototype.hasOwnProperty.call(r,"nonceValue")?(i=r,s=n):s=r;const o=s&&{skipPreflight:s.skipPreflight,preflightCommitment:s.preflightCommitment||s.commitment,minContextSlot:s.minContextSlot},a=await e.sendRawTransaction(t,o),c=s&&s.commitment,u=i?e.confirmTransaction(i,c):e.confirmTransaction(a,c),l=(await u).value;if(l.err)throw new Error(`Raw transaction ${a} failed (${JSON.stringify(l)})`);return a}const ii=1e9;t.Account=F,t.AddressLookupTableAccount=ht,t.AddressLookupTableInstruction=gn,t.AddressLookupTableProgram=yn,t.Authorized=Pn,t.BLOCKHASH_CACHE_TIMEOUT_MS=kt,t.BPF_LOADER_DEPRECATED_PROGRAM_ID=V,t.BPF_LOADER_PROGRAM_ID=Ze,t.BpfLoader=qe,t.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS=fn,t.ComputeBudgetInstruction=mn,t.ComputeBudgetProgram=kn,t.Connection=hn,t.Ed25519Program=An,t.Enum=x,t.EpochSchedule=it,t.FeeCalculatorLayout=Pe,t.Keypair=bn,t.LAMPORTS_PER_SOL=ii,t.LOOKUP_TABLE_INSTRUCTION_LAYOUTS=pn,t.Loader=He,t.Lockup=Rn,t.MAX_SEED_LENGTH=U,t.Message=ue,t.MessageAccountKeys=G,t.MessageV0=le,t.NONCE_ACCOUNT_LENGTH=Ue,t.NonceAccount=ze,t.PACKET_DATA_SIZE=K,t.PUBLIC_KEY_LENGTH=z,t.PublicKey=D,t.SIGNATURE_LENGTH_IN_BYTES=H,t.SOLANA_SCHEMA=L,t.STAKE_CONFIG_ID=Ln,t.STAKE_INSTRUCTION_LAYOUTS=zn,t.SYSTEM_INSTRUCTION_LAYOUTS=Ve,t.SYSVAR_CLOCK_PUBKEY=Ie,t.SYSVAR_EPOCH_SCHEDULE_PUBKEY=ve,t.SYSVAR_INSTRUCTIONS_PUBKEY=Ae,t.SYSVAR_RECENT_BLOCKHASHES_PUBKEY=_e,t.SYSVAR_RENT_PUBKEY=Ee,t.SYSVAR_REWARDS_PUBKEY=Oe,t.SYSVAR_SLOT_HASHES_PUBKEY=Te,t.SYSVAR_SLOT_HISTORY_PUBKEY=je,t.SYSVAR_STAKE_HISTORY_PUBKEY=Be,t.Secp256k1Program=Mn,t.SendTransactionError=st,t.SolanaJSONRPCError=at,t.SolanaJSONRPCErrorCode=ot,t.StakeAuthorizationLayout=Wn,t.StakeInstruction=Un,t.StakeProgram=Cn,t.Struct=M,t.SystemInstruction=Fe,t.SystemProgram=Ke,t.Transaction=ge,t.TransactionExpiredBlockheightExceededError=Z,t.TransactionExpiredNonceInvalidError=Y,t.TransactionExpiredTimeoutError=q,t.TransactionInstruction=pe,t.TransactionMessage=ye,t.TransactionStatus=he,t.VALIDATOR_INFO_KEY=Hn,t.VERSION_PREFIX_MASK=Q,t.VOTE_PROGRAM_ID=Yn,t.ValidatorInfo=qn,t.VersionedMessage=de,t.VersionedTransaction=me,t.VoteAccount=Jn,t.VoteAuthorizationLayout=Kn,t.VoteInit=Dn,t.VoteInstruction=Fn,t.VoteProgram=Qn,t.clusterApiUrl=ri,t.sendAndConfirmRawTransaction=ni,t.sendAndConfirmTransaction=Ne},"2a8a":function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.convertSecretKeyToX25519=t.convertPublicKeyToX25519=t.verify=t.sign=t.extractPublicKeyFromSecretKey=t.generateKeyPair=t.generateKeyPairFromSeed=t.SEED_LENGTH=t.SECRET_KEY_LENGTH=t.PUBLIC_KEY_LENGTH=t.SIGNATURE_LENGTH=void 0;const n=r("e5f1"),i=r("c162"),s=r("ff6a");function o(e){const t=new Float64Array(16);if(e)for(let r=0;r<e.length;r++)t[r]=e[r];return t}t.SIGNATURE_LENGTH=64,t.PUBLIC_KEY_LENGTH=32,t.SECRET_KEY_LENGTH=64,t.SEED_LENGTH=32;const a=new Uint8Array(32);a[0]=9;const c=o(),u=o([1]),l=o([30883,4953,19914,30187,55467,16705,2637,112,59544,30585,16505,36039,65139,11119,27886,20995]),d=o([61785,9906,39828,60374,45398,33411,5274,224,53552,61171,33010,6542,64743,22239,55772,9222]),h=o([54554,36645,11616,51542,42930,38181,51040,26924,56412,64982,57905,49316,21502,52590,14035,8553]),b=o([26200,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214]),p=o([41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139]);function g(e,t){for(let r=0;r<16;r++)e[r]=0|t[r]}function y(e){let t=1;for(let r=0;r<16;r++){let n=e[r]+t+65535;t=Math.floor(n/65536),e[r]=n-65536*t}e[0]+=t-1+37*(t-1)}function m(e,t,r){const n=~(r-1);for(let i=0;i<16;i++){const r=n&(e[i]^t[i]);e[i]^=r,t[i]^=r}}function f(e,t){const r=o(),n=o();for(let i=0;i<16;i++)n[i]=t[i];y(n),y(n),y(n);for(let i=0;i<2;i++){r[0]=n[0]-65517;for(let t=1;t<15;t++)r[t]=n[t]-65535-(r[t-1]>>16&1),r[t-1]&=65535;r[15]=n[15]-32767-(r[14]>>16&1);const e=r[15]>>16&1;r[14]&=65535,m(n,r,1-e)}for(let i=0;i<16;i++)e[2*i]=255&n[i],e[2*i+1]=n[i]>>8}function k(e,t){let r=0;for(let n=0;n<32;n++)r|=e[n]^t[n];return(1&r-1>>>8)-1}function w(e,t){const r=new Uint8Array(32),n=new Uint8Array(32);return f(r,e),f(n,t),k(r,n)}function S(e){const t=new Uint8Array(32);return f(t,e),1&t[0]}function I(e,t){for(let r=0;r<16;r++)e[r]=t[2*r]+(t[2*r+1]<<8);e[15]&=32767}function v(e,t,r){for(let n=0;n<16;n++)e[n]=t[n]+r[n]}function A(e,t,r){for(let n=0;n<16;n++)e[n]=t[n]-r[n]}function _(e,t,r){let n,i,s=0,o=0,a=0,c=0,u=0,l=0,d=0,h=0,b=0,p=0,g=0,y=0,m=0,f=0,k=0,w=0,S=0,I=0,v=0,A=0,_=0,E=0,O=0,T=0,j=0,B=0,N=0,M=0,x=0,L=0,P=0,R=r[0],U=r[1],z=r[2],W=r[3],C=r[4],D=r[5],F=r[6],V=r[7],K=r[8],Q=r[9],H=r[10],Z=r[11],q=r[12],Y=r[13],G=r[14],J=r[15];n=t[0],s+=n*R,o+=n*U,a+=n*z,c+=n*W,u+=n*C,l+=n*D,d+=n*F,h+=n*V,b+=n*K,p+=n*Q,g+=n*H,y+=n*Z,m+=n*q,f+=n*Y,k+=n*G,w+=n*J,n=t[1],o+=n*R,a+=n*U,c+=n*z,u+=n*W,l+=n*C,d+=n*D,h+=n*F,b+=n*V,p+=n*K,g+=n*Q,y+=n*H,m+=n*Z,f+=n*q,k+=n*Y,w+=n*G,S+=n*J,n=t[2],a+=n*R,c+=n*U,u+=n*z,l+=n*W,d+=n*C,h+=n*D,b+=n*F,p+=n*V,g+=n*K,y+=n*Q,m+=n*H,f+=n*Z,k+=n*q,w+=n*Y,S+=n*G,I+=n*J,n=t[3],c+=n*R,u+=n*U,l+=n*z,d+=n*W,h+=n*C,b+=n*D,p+=n*F,g+=n*V,y+=n*K,m+=n*Q,f+=n*H,k+=n*Z,w+=n*q,S+=n*Y,I+=n*G,v+=n*J,n=t[4],u+=n*R,l+=n*U,d+=n*z,h+=n*W,b+=n*C,p+=n*D,g+=n*F,y+=n*V,m+=n*K,f+=n*Q,k+=n*H,w+=n*Z,S+=n*q,I+=n*Y,v+=n*G,A+=n*J,n=t[5],l+=n*R,d+=n*U,h+=n*z,b+=n*W,p+=n*C,g+=n*D,y+=n*F,m+=n*V,f+=n*K,k+=n*Q,w+=n*H,S+=n*Z,I+=n*q,v+=n*Y,A+=n*G,_+=n*J,n=t[6],d+=n*R,h+=n*U,b+=n*z,p+=n*W,g+=n*C,y+=n*D,m+=n*F,f+=n*V,k+=n*K,w+=n*Q,S+=n*H,I+=n*Z,v+=n*q,A+=n*Y,_+=n*G,E+=n*J,n=t[7],h+=n*R,b+=n*U,p+=n*z,g+=n*W,y+=n*C,m+=n*D,f+=n*F,k+=n*V,w+=n*K,S+=n*Q,I+=n*H,v+=n*Z,A+=n*q,_+=n*Y,E+=n*G,O+=n*J,n=t[8],b+=n*R,p+=n*U,g+=n*z,y+=n*W,m+=n*C,f+=n*D,k+=n*F,w+=n*V,S+=n*K,I+=n*Q,v+=n*H,A+=n*Z,_+=n*q,E+=n*Y,O+=n*G,T+=n*J,n=t[9],p+=n*R,g+=n*U,y+=n*z,m+=n*W,f+=n*C,k+=n*D,w+=n*F,S+=n*V,I+=n*K,v+=n*Q,A+=n*H,_+=n*Z,E+=n*q,O+=n*Y,T+=n*G,j+=n*J,n=t[10],g+=n*R,y+=n*U,m+=n*z,f+=n*W,k+=n*C,w+=n*D,S+=n*F,I+=n*V,v+=n*K,A+=n*Q,_+=n*H,E+=n*Z,O+=n*q,T+=n*Y,j+=n*G,B+=n*J,n=t[11],y+=n*R,m+=n*U,f+=n*z,k+=n*W,w+=n*C,S+=n*D,I+=n*F,v+=n*V,A+=n*K,_+=n*Q,E+=n*H,O+=n*Z,T+=n*q,j+=n*Y,B+=n*G,N+=n*J,n=t[12],m+=n*R,f+=n*U,k+=n*z,w+=n*W,S+=n*C,I+=n*D,v+=n*F,A+=n*V,_+=n*K,E+=n*Q,O+=n*H,T+=n*Z,j+=n*q,B+=n*Y,N+=n*G,M+=n*J,n=t[13],f+=n*R,k+=n*U,w+=n*z,S+=n*W,I+=n*C,v+=n*D,A+=n*F,_+=n*V,E+=n*K,O+=n*Q,T+=n*H,j+=n*Z,B+=n*q,N+=n*Y,M+=n*G,x+=n*J,n=t[14],k+=n*R,w+=n*U,S+=n*z,I+=n*W,v+=n*C,A+=n*D,_+=n*F,E+=n*V,O+=n*K,T+=n*Q,j+=n*H,B+=n*Z,N+=n*q,M+=n*Y,x+=n*G,L+=n*J,n=t[15],w+=n*R,S+=n*U,I+=n*z,v+=n*W,A+=n*C,_+=n*D,E+=n*F,O+=n*V,T+=n*K,j+=n*Q,B+=n*H,N+=n*Z,M+=n*q,x+=n*Y,L+=n*G,P+=n*J,s+=38*S,o+=38*I,a+=38*v,c+=38*A,u+=38*_,l+=38*E,d+=38*O,h+=38*T,b+=38*j,p+=38*B,g+=38*N,y+=38*M,m+=38*x,f+=38*L,k+=38*P,i=1,n=s+i+65535,i=Math.floor(n/65536),s=n-65536*i,n=o+i+65535,i=Math.floor(n/65536),o=n-65536*i,n=a+i+65535,i=Math.floor(n/65536),a=n-65536*i,n=c+i+65535,i=Math.floor(n/65536),c=n-65536*i,n=u+i+65535,i=Math.floor(n/65536),u=n-65536*i,n=l+i+65535,i=Math.floor(n/65536),l=n-65536*i,n=d+i+65535,i=Math.floor(n/65536),d=n-65536*i,n=h+i+65535,i=Math.floor(n/65536),h=n-65536*i,n=b+i+65535,i=Math.floor(n/65536),b=n-65536*i,n=p+i+65535,i=Math.floor(n/65536),p=n-65536*i,n=g+i+65535,i=Math.floor(n/65536),g=n-65536*i,n=y+i+65535,i=Math.floor(n/65536),y=n-65536*i,n=m+i+65535,i=Math.floor(n/65536),m=n-65536*i,n=f+i+65535,i=Math.floor(n/65536),f=n-65536*i,n=k+i+65535,i=Math.floor(n/65536),k=n-65536*i,n=w+i+65535,i=Math.floor(n/65536),w=n-65536*i,s+=i-1+37*(i-1),i=1,n=s+i+65535,i=Math.floor(n/65536),s=n-65536*i,n=o+i+65535,i=Math.floor(n/65536),o=n-65536*i,n=a+i+65535,i=Math.floor(n/65536),a=n-65536*i,n=c+i+65535,i=Math.floor(n/65536),c=n-65536*i,n=u+i+65535,i=Math.floor(n/65536),u=n-65536*i,n=l+i+65535,i=Math.floor(n/65536),l=n-65536*i,n=d+i+65535,i=Math.floor(n/65536),d=n-65536*i,n=h+i+65535,i=Math.floor(n/65536),h=n-65536*i,n=b+i+65535,i=Math.floor(n/65536),b=n-65536*i,n=p+i+65535,i=Math.floor(n/65536),p=n-65536*i,n=g+i+65535,i=Math.floor(n/65536),g=n-65536*i,n=y+i+65535,i=Math.floor(n/65536),y=n-65536*i,n=m+i+65535,i=Math.floor(n/65536),m=n-65536*i,n=f+i+65535,i=Math.floor(n/65536),f=n-65536*i,n=k+i+65535,i=Math.floor(n/65536),k=n-65536*i,n=w+i+65535,i=Math.floor(n/65536),w=n-65536*i,s+=i-1+37*(i-1),e[0]=s,e[1]=o,e[2]=a,e[3]=c,e[4]=u,e[5]=l,e[6]=d,e[7]=h,e[8]=b,e[9]=p,e[10]=g,e[11]=y,e[12]=m,e[13]=f,e[14]=k,e[15]=w}function E(e,t){_(e,t,t)}function O(e,t){const r=o();let n;for(n=0;n<16;n++)r[n]=t[n];for(n=253;n>=0;n--)E(r,r),2!==n&&4!==n&&_(r,r,t);for(n=0;n<16;n++)e[n]=r[n]}function T(e,t){const r=o();let n;for(n=0;n<16;n++)r[n]=t[n];for(n=250;n>=0;n--)E(r,r),1!==n&&_(r,r,t);for(n=0;n<16;n++)e[n]=r[n]}function j(e,t){const r=o(),n=o(),i=o(),s=o(),a=o(),c=o(),u=o(),l=o(),h=o();A(r,e[1],e[0]),A(h,t[1],t[0]),_(r,r,h),v(n,e[0],e[1]),v(h,t[0],t[1]),_(n,n,h),_(i,e[3],t[3]),_(i,i,d),_(s,e[2],t[2]),v(s,s,s),A(a,n,r),A(c,s,i),v(u,s,i),v(l,n,r),_(e[0],a,c),_(e[1],l,u),_(e[2],u,c),_(e[3],a,l)}function B(e,t,r){for(let n=0;n<4;n++)m(e[n],t[n],r)}function N(e,t){const r=o(),n=o(),i=o();O(i,t[2]),_(r,t[0],i),_(n,t[1],i),f(e,n),e[31]^=S(r)<<7}function M(e,t,r){g(e[0],c),g(e[1],u),g(e[2],u),g(e[3],c);for(let n=255;n>=0;--n){const i=r[n/8|0]>>(7&n)&1;B(e,t,i),j(t,e),j(e,e),B(e,t,i)}}function x(e,t){const r=[o(),o(),o(),o()];g(r[0],h),g(r[1],b),g(r[2],u),_(r[3],h,b),M(e,r,t)}function L(e){if(e.length!==t.SEED_LENGTH)throw new Error(`ed25519: seed must be ${t.SEED_LENGTH} bytes`);const r=(0,i.hash)(e);r[0]&=248,r[31]&=127,r[31]|=64;const n=new Uint8Array(32),s=[o(),o(),o(),o()];x(s,r),N(n,s);const a=new Uint8Array(64);return a.set(e),a.set(n,32),{publicKey:n,secretKey:a}}function P(e){const t=(0,n.randomBytes)(32,e),r=L(t);return(0,s.wipe)(t),r}function R(e){if(e.length!==t.SECRET_KEY_LENGTH)throw new Error(`ed25519: secret key must be ${t.SECRET_KEY_LENGTH} bytes`);return new Uint8Array(e.subarray(32))}t.generateKeyPairFromSeed=L,t.generateKeyPair=P,t.extractPublicKeyFromSecretKey=R;const U=new Float64Array([237,211,245,92,26,99,18,88,214,156,247,162,222,249,222,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16]);function z(e,t){let r,n,i,s;for(n=63;n>=32;--n){for(r=0,i=n-32,s=n-12;i<s;++i)t[i]+=r-16*t[n]*U[i-(n-32)],r=Math.floor((t[i]+128)/256),t[i]-=256*r;t[i]+=r,t[n]=0}for(r=0,i=0;i<32;i++)t[i]+=r-(t[31]>>4)*U[i],r=t[i]>>8,t[i]&=255;for(i=0;i<32;i++)t[i]-=r*U[i];for(n=0;n<32;n++)t[n+1]+=t[n]>>8,e[n]=255&t[n]}function W(e){const t=new Float64Array(64);for(let r=0;r<64;r++)t[r]=e[r];for(let r=0;r<64;r++)e[r]=0;z(e,t)}function C(e,t){const r=new Float64Array(64),n=[o(),o(),o(),o()],s=(0,i.hash)(e.subarray(0,32));s[0]&=248,s[31]&=127,s[31]|=64;const a=new Uint8Array(64);a.set(s.subarray(32),32);const c=new i.SHA512;c.update(a.subarray(32)),c.update(t);const u=c.digest();c.clean(),W(u),x(n,u),N(a,n),c.reset(),c.update(a.subarray(0,32)),c.update(e.subarray(32)),c.update(t);const l=c.digest();W(l);for(let i=0;i<32;i++)r[i]=u[i];for(let i=0;i<32;i++)for(let e=0;e<32;e++)r[i+e]+=l[i]*s[e];return z(a.subarray(32),r),a}function D(e,t){const r=o(),n=o(),i=o(),s=o(),a=o(),d=o(),h=o();return g(e[2],u),I(e[1],t),E(i,e[1]),_(s,i,l),A(i,i,e[2]),v(s,e[2],s),E(a,s),E(d,a),_(h,d,a),_(r,h,i),_(r,r,s),T(r,r),_(r,r,i),_(r,r,s),_(r,r,s),_(e[0],r,s),E(n,e[0]),_(n,n,s),w(n,i)&&_(e[0],e[0],p),E(n,e[0]),_(n,n,s),w(n,i)?-1:(S(e[0])===t[31]>>7&&A(e[0],c,e[0]),_(e[3],e[0],e[1]),0)}function F(e,r,n){const s=new Uint8Array(32),a=[o(),o(),o(),o()],c=[o(),o(),o(),o()];if(n.length!==t.SIGNATURE_LENGTH)throw new Error(`ed25519: signature must be ${t.SIGNATURE_LENGTH} bytes`);if(D(c,e))return!1;const u=new i.SHA512;u.update(n.subarray(0,32)),u.update(e),u.update(r);const l=u.digest();return W(l),M(a,c,l),x(c,n.subarray(32)),j(a,c),N(s,a),!k(n,s)}function V(e){let t=[o(),o(),o(),o()];if(D(t,e))throw new Error("Ed25519: invalid public key");let r=o(),n=o(),i=t[1];v(r,u,i),A(n,u,i),O(n,n),_(r,r,n);let s=new Uint8Array(32);return f(s,r),s}function K(e){const t=(0,i.hash)(e.subarray(0,32));t[0]&=248,t[31]&=127,t[31]|=64;const r=new Uint8Array(t.subarray(0,32));return(0,s.wipe)(t),r}t.sign=C,t.verify=F,t.convertPublicKeyToX25519=V,t.convertSecretKeyToX25519=K},3583:function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r("290c"),i=r("ff6a"),s=20;function o(e,t,r){for(var i=1634760805,o=857760878,a=2036477234,c=1797285236,u=r[3]<<24|r[2]<<16|r[1]<<8|r[0],l=r[7]<<24|r[6]<<16|r[5]<<8|r[4],d=r[11]<<24|r[10]<<16|r[9]<<8|r[8],h=r[15]<<24|r[14]<<16|r[13]<<8|r[12],b=r[19]<<24|r[18]<<16|r[17]<<8|r[16],p=r[23]<<24|r[22]<<16|r[21]<<8|r[20],g=r[27]<<24|r[26]<<16|r[25]<<8|r[24],y=r[31]<<24|r[30]<<16|r[29]<<8|r[28],m=t[3]<<24|t[2]<<16|t[1]<<8|t[0],f=t[7]<<24|t[6]<<16|t[5]<<8|t[4],k=t[11]<<24|t[10]<<16|t[9]<<8|t[8],w=t[15]<<24|t[14]<<16|t[13]<<8|t[12],S=i,I=o,v=a,A=c,_=u,E=l,O=d,T=h,j=b,B=p,N=g,M=y,x=m,L=f,P=k,R=w,U=0;U<s;U+=2)S=S+_|0,x^=S,x=x>>>16|x<<16,j=j+x|0,_^=j,_=_>>>20|_<<12,I=I+E|0,L^=I,L=L>>>16|L<<16,B=B+L|0,E^=B,E=E>>>20|E<<12,v=v+O|0,P^=v,P=P>>>16|P<<16,N=N+P|0,O^=N,O=O>>>20|O<<12,A=A+T|0,R^=A,R=R>>>16|R<<16,M=M+R|0,T^=M,T=T>>>20|T<<12,v=v+O|0,P^=v,P=P>>>24|P<<8,N=N+P|0,O^=N,O=O>>>25|O<<7,A=A+T|0,R^=A,R=R>>>24|R<<8,M=M+R|0,T^=M,T=T>>>25|T<<7,I=I+E|0,L^=I,L=L>>>24|L<<8,B=B+L|0,E^=B,E=E>>>25|E<<7,S=S+_|0,x^=S,x=x>>>24|x<<8,j=j+x|0,_^=j,_=_>>>25|_<<7,S=S+E|0,R^=S,R=R>>>16|R<<16,N=N+R|0,E^=N,E=E>>>20|E<<12,I=I+O|0,x^=I,x=x>>>16|x<<16,M=M+x|0,O^=M,O=O>>>20|O<<12,v=v+T|0,L^=v,L=L>>>16|L<<16,j=j+L|0,T^=j,T=T>>>20|T<<12,A=A+_|0,P^=A,P=P>>>16|P<<16,B=B+P|0,_^=B,_=_>>>20|_<<12,v=v+T|0,L^=v,L=L>>>24|L<<8,j=j+L|0,T^=j,T=T>>>25|T<<7,A=A+_|0,P^=A,P=P>>>24|P<<8,B=B+P|0,_^=B,_=_>>>25|_<<7,I=I+O|0,x^=I,x=x>>>24|x<<8,M=M+x|0,O^=M,O=O>>>25|O<<7,S=S+E|0,R^=S,R=R>>>24|R<<8,N=N+R|0,E^=N,E=E>>>25|E<<7;n.writeUint32LE(S+i|0,e,0),n.writeUint32LE(I+o|0,e,4),n.writeUint32LE(v+a|0,e,8),n.writeUint32LE(A+c|0,e,12),n.writeUint32LE(_+u|0,e,16),n.writeUint32LE(E+l|0,e,20),n.writeUint32LE(O+d|0,e,24),n.writeUint32LE(T+h|0,e,28),n.writeUint32LE(j+b|0,e,32),n.writeUint32LE(B+p|0,e,36),n.writeUint32LE(N+g|0,e,40),n.writeUint32LE(M+y|0,e,44),n.writeUint32LE(x+m|0,e,48),n.writeUint32LE(L+f|0,e,52),n.writeUint32LE(P+k|0,e,56),n.writeUint32LE(R+w|0,e,60)}function a(e,t,r,n,s){if(void 0===s&&(s=0),32!==e.length)throw new Error("ChaCha: key size must be 32 bytes");if(n.length<r.length)throw new Error("ChaCha: destination is shorter than source");var a,c;if(0===s){if(8!==t.length&&12!==t.length)throw new Error("ChaCha nonce must be 8 or 12 bytes");a=new Uint8Array(16),c=a.length-t.length,a.set(t,c)}else{if(16!==t.length)throw new Error("ChaCha nonce with counter must be 16 bytes");a=t,c=s}for(var l=new Uint8Array(64),d=0;d<r.length;d+=64){o(l,a,e);for(var h=d;h<d+64&&h<r.length;h++)n[h]=r[h]^l[h-d];u(a,0,c)}return i.wipe(l),0===s&&i.wipe(a),n}function c(e,t,r,n){return void 0===n&&(n=0),i.wipe(r),a(e,t,r,r,n)}function u(e,t,r){var n=1;while(r--)n=n+(255&e[t])|0,e[t]=255&n,n>>>=8,t++;if(n>0)throw new Error("ChaCha: counter overflow")}t.streamXOR=a,t.stream=c},"3e8b":function(e,t,r){"use strict";
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function n(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function i(e,...t){if(!n(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function s(e,t){return!!Array.isArray(t)&&(0===t.length||(e?t.every(e=>"string"===typeof e):t.every(e=>Number.isSafeInteger(e))))}function o(e){if("function"!==typeof e)throw new Error("function expected");return!0}function a(e,t){if("string"!==typeof t)throw new Error(e+": string expected");return!0}function c(e){if(!Number.isSafeInteger(e))throw new Error("invalid integer: "+e)}function u(e){if(!Array.isArray(e))throw new Error("array expected")}function l(e,t){if(!s(!0,t))throw new Error(e+": array of strings expected")}function d(e,t){if(!s(!1,t))throw new Error(e+": array of numbers expected")}function h(...e){const t=e=>e,r=(e,t)=>r=>e(t(r)),n=e.map(e=>e.encode).reduceRight(r,t),i=e.map(e=>e.decode).reduce(r,t);return{encode:n,decode:i}}function b(e){const t="string"===typeof e?e.split(""):e,r=t.length;l("alphabet",t);const n=new Map(t.map((e,t)=>[e,t]));return{encode:n=>(u(n),n.map(n=>{if(!Number.isSafeInteger(n)||n<0||n>=r)throw new Error(`alphabet.encode: digit index outside alphabet "${n}". Allowed: ${e}`);return t[n]})),decode:t=>(u(t),t.map(t=>{a("alphabet.decode",t);const r=n.get(t);if(void 0===r)throw new Error(`Unknown letter: "${t}". Allowed: ${e}`);return r}))}}function p(e=""){return a("join",e),{encode:t=>(l("join.decode",t),t.join(e)),decode:t=>(a("join.decode",t),t.split(e))}}function g(e,t="="){return c(e),a("padding",t),{encode(r){l("padding.encode",r);while(r.length*e%8)r.push(t);return r},decode(r){l("padding.decode",r);let n=r.length;if(n*e%8)throw new Error("padding: invalid, string should have whole number of bytes");for(;n>0&&r[n-1]===t;n--){const t=n-1,r=t*e;if(r%8===0)throw new Error("padding: invalid, string has too much padding")}return r.slice(0,n)}}}function y(e){return o(e),{encode:e=>e,decode:t=>e(t)}}function m(e,t,r){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);if(u(e),!e.length)return[];let n=0;const i=[],s=Array.from(e,e=>{if(c(e),e<0||e>=t)throw new Error("invalid integer: "+e);return e}),o=s.length;while(1){let e=0,a=!0;for(let i=n;i<o;i++){const o=s[i],c=t*e,u=c+o;if(!Number.isSafeInteger(u)||c/t!==e||u-o!==c)throw new Error("convertRadix: carry overflow");const l=u/r;e=u%r;const d=Math.floor(l);if(s[i]=d,!Number.isSafeInteger(d)||d*r+e!==u)throw new Error("convertRadix: carry overflow");a&&(d?a=!1:n=i)}if(i.push(e),a)break}for(let a=0;a<e.length-1&&0===e[a];a++)i.push(0);return i.reverse()}r.d(t,"a",(function(){return T}));const f=(e,t)=>0===t?e:f(t,e%t),k=(e,t)=>e+(t-f(e,t)),w=(()=>{let e=[];for(let t=0;t<40;t++)e.push(2**t);return e})();function S(e,t,r,n){if(u(e),t<=0||t>32)throw new Error("convertRadix2: wrong from="+t);if(r<=0||r>32)throw new Error("convertRadix2: wrong to="+r);if(k(t,r)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${k(t,r)}`);let i=0,s=0;const o=w[t],a=w[r]-1,l=[];for(const u of e){if(c(u),u>=o)throw new Error(`convertRadix2: invalid data word=${u} from=${t}`);if(i=i<<t|u,s+t>32)throw new Error(`convertRadix2: carry overflow pos=${s} from=${t}`);for(s+=t;s>=r;s-=r)l.push((i>>s-r&a)>>>0);const e=w[s];if(void 0===e)throw new Error("invalid carry");i&=e-1}if(i=i<<r-s&a,!n&&s>=t)throw new Error("Excess padding");if(!n&&i>0)throw new Error("Non-zero padding: "+i);return n&&s>0&&l.push(i>>>0),l}function I(e){c(e);const t=256;return{encode:r=>{if(!n(r))throw new Error("radix.encode input should be Uint8Array");return m(Array.from(r),t,e)},decode:r=>(d("radix.decode",r),Uint8Array.from(m(r,e,t)))}}function v(e,t=!1){if(c(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(k(8,e)>32||k(e,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!n(r))throw new Error("radix2.encode input should be Uint8Array");return S(Array.from(r),8,e,!t)},decode:r=>(d("radix2.decode",r),Uint8Array.from(S(r,e,8,t)))}}function A(e){return o(e),function(...t){try{return e.apply(null,t)}catch(r){}}}h(v(4),b("0123456789ABCDEF"),p("")),h(v(5),b("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),g(5),p("")),h(v(5),b("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),p("")),h(v(5),b("0123456789ABCDEFGHIJKLMNOPQRSTUV"),g(5),p("")),h(v(5),b("0123456789ABCDEFGHIJKLMNOPQRSTUV"),p("")),h(v(5),b("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),p(""),y(e=>e.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")));const _=(()=>"function"===typeof Uint8Array.from([]).toBase64&&"function"===typeof Uint8Array.fromBase64)(),E=(e,t)=>{a("base64",e);const r=t?/^[A-Za-z0-9=_-]+$/:/^[A-Za-z0-9=+/]+$/,n=t?"base64url":"base64";if(e.length>0&&!r.test(e))throw new Error("invalid base64");return Uint8Array.fromBase64(e,{alphabet:n,lastChunkHandling:"strict"})},O=(_||h(v(6),b("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),g(6),p("")),h(v(6),b("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),p("")),_||h(v(6),b("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),g(6),p("")),h(v(6),b("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),p("")),e=>h(I(58),b(e),p(""))),T=O("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),j=(O("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),O("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"),h(b("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),p(""))),B=[996825010,642813549,513874426,1027748829,705979059];function N(e){const t=e>>25;let r=(33554431&e)<<5;for(let n=0;n<B.length;n++)1===(t>>n&1)&&(r^=B[n]);return r}function M(e,t,r=1){const n=e.length;let i=1;for(let s=0;s<n;s++){const t=e.charCodeAt(s);if(t<33||t>126)throw new Error(`Invalid prefix (${e})`);i=N(i)^t>>5}i=N(i);for(let s=0;s<n;s++)i=N(i)^31&e.charCodeAt(s);for(let s of t)i=N(i)^s;for(let s=0;s<6;s++)i=N(i);return i^=r,j.encode(S([i%w[30]],30,5,!1))}function x(e){const t="bech32"===e?1:734539939,r=v(5),i=r.decode,s=r.encode,o=A(i);function c(e,r,i=90){a("bech32.encode prefix",e),n(r)&&(r=Array.from(r)),d("bech32.encode",r);const s=e.length;if(0===s)throw new TypeError("Invalid prefix length "+s);const o=s+7+r.length;if(!1!==i&&o>i)throw new TypeError(`Length ${o} exceeds limit ${i}`);const c=e.toLowerCase(),u=M(c,r,t);return`${c}1${j.encode(r)}${u}`}function u(e,r=90){a("bech32.decode input",e);const n=e.length;if(n<8||!1!==r&&n>r)throw new TypeError(`invalid string length: ${n} (${e}). Expected (8..${r})`);const i=e.toLowerCase();if(e!==i&&e!==e.toUpperCase())throw new Error("String must be lowercase or uppercase");const s=i.lastIndexOf("1");if(0===s||-1===s)throw new Error('Letter "1" must be present between prefix and data only');const o=i.slice(0,s),c=i.slice(s+1);if(c.length<6)throw new Error("Data must be at least 6 characters long");const u=j.decode(c).slice(0,-6),l=M(o,u,t);if(!c.endsWith(l))throw new Error(`Invalid checksum in ${e}: expected "${l}"`);return{prefix:o,words:u}}const l=A(u);function h(e){const{prefix:t,words:r}=u(e,!1);return{prefix:t,words:r,bytes:i(r)}}function b(e,t){return c(e,s(t))}return{encode:c,decode:u,encodeFromBytes:b,decodeToBytes:h,decodeUnsafe:l,fromWords:i,fromWordsUnsafe:o,toWords:s}}x("bech32"),x("bech32m");const L=(()=>"function"===typeof Uint8Array.from([]).toHex&&"function"===typeof Uint8Array.fromHex)(),P={encode(e){return i(e),e.toHex()},decode(e){return a("hex",e),Uint8Array.fromHex(e)}};L||h(v(4),b("0123456789abcdef"),p(""),y(e=>{if("string"!==typeof e||e.length%2!==0)throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);return e.toLowerCase()}))},"405f":function(e,t,r){var n=r("42a7"),i="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";e.exports=n(i)},"477e":function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r("7dcf"),i=r("47c4"),s=r("ff6a"),o=function(){function e(e,t){this._finished=!1,this._inner=new e,this._outer=new e,this.blockSize=this._outer.blockSize,this.digestLength=this._outer.digestLength;var r=new Uint8Array(this.blockSize);t.length>this.blockSize?this._inner.update(t).finish(r).clean():r.set(t);for(var i=0;i<r.length;i++)r[i]^=54;this._inner.update(r);for(i=0;i<r.length;i++)r[i]^=106;this._outer.update(r),n.isSerializableHash(this._inner)&&n.isSerializableHash(this._outer)&&(this._innerKeyedState=this._inner.saveState(),this._outerKeyedState=this._outer.saveState()),s.wipe(r)}return e.prototype.reset=function(){if(!n.isSerializableHash(this._inner)||!n.isSerializableHash(this._outer))throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");return this._inner.restoreState(this._innerKeyedState),this._outer.restoreState(this._outerKeyedState),this._finished=!1,this},e.prototype.clean=function(){n.isSerializableHash(this._inner)&&this._inner.cleanSavedState(this._innerKeyedState),n.isSerializableHash(this._outer)&&this._outer.cleanSavedState(this._outerKeyedState),this._inner.clean(),this._outer.clean()},e.prototype.update=function(e){return this._inner.update(e),this},e.prototype.finish=function(e){return this._finished?(this._outer.finish(e),this):(this._inner.finish(e),this._outer.update(e.subarray(0,this.digestLength)).finish(e),this._finished=!0,this)},e.prototype.digest=function(){var e=new Uint8Array(this.digestLength);return this.finish(e),e},e.prototype.saveState=function(){if(!n.isSerializableHash(this._inner))throw new Error("hmac: can't saveState() because hash doesn't implement it");return this._inner.saveState()},e.prototype.restoreState=function(e){if(!n.isSerializableHash(this._inner)||!n.isSerializableHash(this._outer))throw new Error("hmac: can't restoreState() because hash doesn't implement it");return this._inner.restoreState(e),this._outer.restoreState(this._outerKeyedState),this._finished=!1,this},e.prototype.cleanSavedState=function(e){if(!n.isSerializableHash(this._inner))throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");this._inner.cleanSavedState(e)},e}();function a(e,t,r){var n=new o(e,t);n.update(r);var i=n.digest();return n.clean(),i}t.HMAC=o,t.hmac=a,t.equal=i.equal},"47c4":function(e,t,r){"use strict";function n(e,t,r){return~(e-1)&t|e-1&r}function i(e,t){return(0|e)-(0|t)-1>>>31&1}function s(e,t){if(e.length!==t.length)return 0;for(var r=0,n=0;n<e.length;n++)r|=e[n]^t[n];return 1&r-1>>>8}function o(e,t){return 0!==e.length&&0!==t.length&&0!==s(e,t)}Object.defineProperty(t,"__esModule",{value:!0}),t.select=n,t.lessOrEqual=i,t.compare=s,t.equal=o},"4ea9":function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),i(r("834f"),t),i(r("8217"),t),i(r("0fa3"),t),i(r("caeb"),t),i(r("e1c8"),t),i(r("6d7f"),t)},"52c3":function(e,t,r){"use strict";r.d(t,"f",(function(){return n})),r.d(t,"i",(function(){return i})),r.d(t,"g",(function(){return s})),r.d(t,"b",(function(){return o})),r.d(t,"c",(function(){return a})),r.d(t,"d",(function(){return c})),r.d(t,"e",(function(){return u})),r.d(t,"a",(function(){return l})),r.d(t,"j",(function(){return d})),r.d(t,"h",(function(){return h})),r.d(t,"k",(function(){return b})),r.d(t,"m",(function(){return p})),r.d(t,"l",(function(){return g}));r("d9e2");class n extends Error{constructor(e,t){super(e),this.error=t}}class i extends n{constructor(){super(...arguments),this.name="WalletNotReadyError"}}class s extends n{constructor(){super(...arguments),this.name="WalletLoadError"}}class o extends n{constructor(){super(...arguments),this.name="WalletConfigError"}}class a extends n{constructor(){super(...arguments),this.name="WalletConnectionError"}}class c extends n{constructor(){super(...arguments),this.name="WalletDisconnectedError"}}class u extends n{constructor(){super(...arguments),this.name="WalletDisconnectionError"}}class l extends n{constructor(){super(...arguments),this.name="WalletAccountError"}}class d extends n{constructor(){super(...arguments),this.name="WalletPublicKeyError"}}class h extends n{constructor(){super(...arguments),this.name="WalletNotConnectedError"}}class b extends n{constructor(){super(...arguments),this.name="WalletSendTransactionError"}}class p extends n{constructor(){super(...arguments),this.name="WalletSignTransactionError"}}class g extends n{constructor(){super(...arguments),this.name="WalletSignMessageError"}}},5621:function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r("47c4"),i=r("ff6a");t.DIGEST_LENGTH=16;var s=function(){function e(e){this.digestLength=t.DIGEST_LENGTH,this._buffer=new Uint8Array(16),this._r=new Uint16Array(10),this._h=new Uint16Array(10),this._pad=new Uint16Array(8),this._leftover=0,this._fin=0,this._finished=!1;var r=e[0]|e[1]<<8;this._r[0]=8191&r;var n=e[2]|e[3]<<8;this._r[1]=8191&(r>>>13|n<<3);var i=e[4]|e[5]<<8;this._r[2]=7939&(n>>>10|i<<6);var s=e[6]|e[7]<<8;this._r[3]=8191&(i>>>7|s<<9);var o=e[8]|e[9]<<8;this._r[4]=255&(s>>>4|o<<12),this._r[5]=o>>>1&8190;var a=e[10]|e[11]<<8;this._r[6]=8191&(o>>>14|a<<2);var c=e[12]|e[13]<<8;this._r[7]=8065&(a>>>11|c<<5);var u=e[14]|e[15]<<8;this._r[8]=8191&(c>>>8|u<<8),this._r[9]=u>>>5&127,this._pad[0]=e[16]|e[17]<<8,this._pad[1]=e[18]|e[19]<<8,this._pad[2]=e[20]|e[21]<<8,this._pad[3]=e[22]|e[23]<<8,this._pad[4]=e[24]|e[25]<<8,this._pad[5]=e[26]|e[27]<<8,this._pad[6]=e[28]|e[29]<<8,this._pad[7]=e[30]|e[31]<<8}return e.prototype._blocks=function(e,t,r){var n=this._fin?0:2048,i=this._h[0],s=this._h[1],o=this._h[2],a=this._h[3],c=this._h[4],u=this._h[5],l=this._h[6],d=this._h[7],h=this._h[8],b=this._h[9],p=this._r[0],g=this._r[1],y=this._r[2],m=this._r[3],f=this._r[4],k=this._r[5],w=this._r[6],S=this._r[7],I=this._r[8],v=this._r[9];while(r>=16){var A=e[t+0]|e[t+1]<<8;i+=8191&A;var _=e[t+2]|e[t+3]<<8;s+=8191&(A>>>13|_<<3);var E=e[t+4]|e[t+5]<<8;o+=8191&(_>>>10|E<<6);var O=e[t+6]|e[t+7]<<8;a+=8191&(E>>>7|O<<9);var T=e[t+8]|e[t+9]<<8;c+=8191&(O>>>4|T<<12),u+=T>>>1&8191;var j=e[t+10]|e[t+11]<<8;l+=8191&(T>>>14|j<<2);var B=e[t+12]|e[t+13]<<8;d+=8191&(j>>>11|B<<5);var N=e[t+14]|e[t+15]<<8;h+=8191&(B>>>8|N<<8),b+=N>>>5|n;var M=0,x=M;x+=i*p,x+=s*(5*v),x+=o*(5*I),x+=a*(5*S),x+=c*(5*w),M=x>>>13,x&=8191,x+=u*(5*k),x+=l*(5*f),x+=d*(5*m),x+=h*(5*y),x+=b*(5*g),M+=x>>>13,x&=8191;var L=M;L+=i*g,L+=s*p,L+=o*(5*v),L+=a*(5*I),L+=c*(5*S),M=L>>>13,L&=8191,L+=u*(5*w),L+=l*(5*k),L+=d*(5*f),L+=h*(5*m),L+=b*(5*y),M+=L>>>13,L&=8191;var P=M;P+=i*y,P+=s*g,P+=o*p,P+=a*(5*v),P+=c*(5*I),M=P>>>13,P&=8191,P+=u*(5*S),P+=l*(5*w),P+=d*(5*k),P+=h*(5*f),P+=b*(5*m),M+=P>>>13,P&=8191;var R=M;R+=i*m,R+=s*y,R+=o*g,R+=a*p,R+=c*(5*v),M=R>>>13,R&=8191,R+=u*(5*I),R+=l*(5*S),R+=d*(5*w),R+=h*(5*k),R+=b*(5*f),M+=R>>>13,R&=8191;var U=M;U+=i*f,U+=s*m,U+=o*y,U+=a*g,U+=c*p,M=U>>>13,U&=8191,U+=u*(5*v),U+=l*(5*I),U+=d*(5*S),U+=h*(5*w),U+=b*(5*k),M+=U>>>13,U&=8191;var z=M;z+=i*k,z+=s*f,z+=o*m,z+=a*y,z+=c*g,M=z>>>13,z&=8191,z+=u*p,z+=l*(5*v),z+=d*(5*I),z+=h*(5*S),z+=b*(5*w),M+=z>>>13,z&=8191;var W=M;W+=i*w,W+=s*k,W+=o*f,W+=a*m,W+=c*y,M=W>>>13,W&=8191,W+=u*g,W+=l*p,W+=d*(5*v),W+=h*(5*I),W+=b*(5*S),M+=W>>>13,W&=8191;var C=M;C+=i*S,C+=s*w,C+=o*k,C+=a*f,C+=c*m,M=C>>>13,C&=8191,C+=u*y,C+=l*g,C+=d*p,C+=h*(5*v),C+=b*(5*I),M+=C>>>13,C&=8191;var D=M;D+=i*I,D+=s*S,D+=o*w,D+=a*k,D+=c*f,M=D>>>13,D&=8191,D+=u*m,D+=l*y,D+=d*g,D+=h*p,D+=b*(5*v),M+=D>>>13,D&=8191;var F=M;F+=i*v,F+=s*I,F+=o*S,F+=a*w,F+=c*k,M=F>>>13,F&=8191,F+=u*f,F+=l*m,F+=d*y,F+=h*g,F+=b*p,M+=F>>>13,F&=8191,M=(M<<2)+M|0,M=M+x|0,x=8191&M,M>>>=13,L+=M,i=x,s=L,o=P,a=R,c=U,u=z,l=W,d=C,h=D,b=F,t+=16,r-=16}this._h[0]=i,this._h[1]=s,this._h[2]=o,this._h[3]=a,this._h[4]=c,this._h[5]=u,this._h[6]=l,this._h[7]=d,this._h[8]=h,this._h[9]=b},e.prototype.finish=function(e,t){void 0===t&&(t=0);var r,n,i,s,o=new Uint16Array(10);if(this._leftover){for(s=this._leftover,this._buffer[s++]=1;s<16;s++)this._buffer[s]=0;this._fin=1,this._blocks(this._buffer,0,16)}for(r=this._h[1]>>>13,this._h[1]&=8191,s=2;s<10;s++)this._h[s]+=r,r=this._h[s]>>>13,this._h[s]&=8191;for(this._h[0]+=5*r,r=this._h[0]>>>13,this._h[0]&=8191,this._h[1]+=r,r=this._h[1]>>>13,this._h[1]&=8191,this._h[2]+=r,o[0]=this._h[0]+5,r=o[0]>>>13,o[0]&=8191,s=1;s<10;s++)o[s]=this._h[s]+r,r=o[s]>>>13,o[s]&=8191;for(o[9]-=8192,n=(1^r)-1,s=0;s<10;s++)o[s]&=n;for(n=~n,s=0;s<10;s++)this._h[s]=this._h[s]&n|o[s];for(this._h[0]=65535&(this._h[0]|this._h[1]<<13),this._h[1]=65535&(this._h[1]>>>3|this._h[2]<<10),this._h[2]=65535&(this._h[2]>>>6|this._h[3]<<7),this._h[3]=65535&(this._h[3]>>>9|this._h[4]<<4),this._h[4]=65535&(this._h[4]>>>12|this._h[5]<<1|this._h[6]<<14),this._h[5]=65535&(this._h[6]>>>2|this._h[7]<<11),this._h[6]=65535&(this._h[7]>>>5|this._h[8]<<8),this._h[7]=65535&(this._h[8]>>>8|this._h[9]<<5),i=this._h[0]+this._pad[0],this._h[0]=65535&i,s=1;s<8;s++)i=(this._h[s]+this._pad[s]|0)+(i>>>16)|0,this._h[s]=65535&i;return e[t+0]=this._h[0]>>>0,e[t+1]=this._h[0]>>>8,e[t+2]=this._h[1]>>>0,e[t+3]=this._h[1]>>>8,e[t+4]=this._h[2]>>>0,e[t+5]=this._h[2]>>>8,e[t+6]=this._h[3]>>>0,e[t+7]=this._h[3]>>>8,e[t+8]=this._h[4]>>>0,e[t+9]=this._h[4]>>>8,e[t+10]=this._h[5]>>>0,e[t+11]=this._h[5]>>>8,e[t+12]=this._h[6]>>>0,e[t+13]=this._h[6]>>>8,e[t+14]=this._h[7]>>>0,e[t+15]=this._h[7]>>>8,this._finished=!0,this},e.prototype.update=function(e){var t,r=0,n=e.length;if(this._leftover){t=16-this._leftover,t>n&&(t=n);for(var i=0;i<t;i++)this._buffer[this._leftover+i]=e[r+i];if(n-=t,r+=t,this._leftover+=t,this._leftover<16)return this;this._blocks(this._buffer,0,16),this._leftover=0}if(n>=16&&(t=n-n%16,this._blocks(e,r,t),r+=t,n-=t),n){for(i=0;i<n;i++)this._buffer[this._leftover+i]=e[r+i];this._leftover+=n}return this},e.prototype.digest=function(){if(this._finished)throw new Error("Poly1305 was finished");var e=new Uint8Array(16);return this.finish(e),e},e.prototype.clean=function(){return i.wipe(this._buffer),i.wipe(this._r),i.wipe(this._h),i.wipe(this._pad),this._leftover=0,this._fin=0,this._finished=!0,this},e}();function o(e,t){var r=new s(e);r.update(t);var n=r.digest();return r.clean(),n}function a(e,r){return e.length===t.DIGEST_LENGTH&&r.length===t.DIGEST_LENGTH&&n.equal(e,r)}t.Poly1305=s,t.oneTimeAuth=o,t.equal=a},"5cc4":function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SystemRandomSource=void 0;const n=r("843f"),i=r("e512");class s{constructor(){return this.isAvailable=!1,this.name="",this._source=new n.BrowserRandomSource,this._source.isAvailable?(this.isAvailable=!0,void(this.name="Browser")):(this._source=new i.NodeRandomSource,this._source.isAvailable?(this.isAvailable=!0,void(this.name="Node")):void 0)}randomBytes(e){if(!this.isAvailable)throw new Error("System random byte generator is not available.");return this._source.randomBytes(e)}}t.SystemRandomSource=s},"633a":function(e,t,r){"use strict";r.d(t,"c",(function(){return i["b"]})),r.d(t,"a",(function(){return c})),r.d(t,"b",(function(){return l}));var n=r("bbae"),i=r("a81a"),s=r("901e"),o=r.n(s);new o.a("1e+18");var a=r("8df2");const c=e=>{const t=Object(a["u8"])(e),{encode:r,decode:i}=Object(n["a"])(t),s=t;return s.decode=(e,t)=>{const r=i(e,t);return!!r},s.encode=(e,t,n)=>{const i=Number(e);return r(i,t,n)},s};var u=r("2923");const l=e=>{const t=Object(a["blob"])(32,e),{encode:r,decode:i}=Object(n["a"])(t),s=t;return s.decode=(e,t)=>{const r=i(e,t);return new u["PublicKey"](r)},s.encode=(e,t,n)=>{const i=e.toBuffer();return r(i,t,n)},s}},"64b9":function(e,t,r){"use strict";r.d(t,"a",(function(){return Ye})),r.d(t,"b",(function(){return $r})),r.d(t,"c",(function(){return qr})),r.d(t,"d",(function(){return Yr})),r.d(t,"e",(function(){return R})),r.d(t,"f",(function(){return ge})),r.d(t,"g",(function(){return me})),r.d(t,"h",(function(){return Be})),r.d(t,"i",(function(){return ce})),r.d(t,"j",(function(){return ae})),r.d(t,"k",(function(){return ue})),r.d(t,"l",(function(){return le}));r("d9e2"),r("14d9"),r("13d5"),r("907a"),r("986a"),r("1d02"),r("3c5d"),r("6ce5"),r("2834"),r("4ea1"),r("669d"),r("109c"),r("b2c1"),r("0643"),r("76d6"),r("2382"),r("fffc"),r("4e3e"),r("a573"),r("9d4a"),r("9a9a"),r("88e6"),r("70cc"),r("eb03"),r("22e5"),r("c01e"),r("fa76"),r("8306");var n=r("1c35"),i=r("aecc"),s=r("399f"),o=r.n(s),a=r("8ab6"),c=r.n(a),u=r("d129"),l=r("fa13"),d=r("8df2"),h=r("9ea2"),b=r("d920"),p=r("502a"),g=r.n(p),y=r("e01f"),m=r.n(y),f=r("136e"),k=r.n(f),w=r("00e3"),S=r("fb4a");i["ed25519"].utils.randomPrivateKey;const I=()=>{const e=i["ed25519"].utils.randomPrivateKey(),t=v(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),{publicKey:t,secretKey:r}},v=i["ed25519"].getPublicKey;function A(e){try{return i["ed25519"].ExtendedPoint.fromHex(e),!0}catch{return!1}}const _=(e,t)=>i["ed25519"].sign(e,t.slice(0,32)),E=i["ed25519"].verify,O=e=>n["Buffer"].isBuffer(e)?e:e instanceof Uint8Array?n["Buffer"].from(e.buffer,e.byteOffset,e.byteLength):n["Buffer"].from(e);class T{constructor(e){Object.assign(this,e)}encode(){return n["Buffer"].from(Object(l["serialize"])(j,this))}static decode(e){return Object(l["deserialize"])(j,this,e)}static decodeUnchecked(e){return Object(l["deserializeUnchecked"])(j,this,e)}}const j=new Map;var B;let N;const M=32,x=32;function L(e){return void 0!==e._bn}let P=1;N=Symbol.toStringTag;class R extends T{constructor(e){if(super({}),this._bn=void 0,L(e))this._bn=e._bn;else{if("string"===typeof e){const t=c.a.decode(e);if(t.length!=x)throw new Error("Invalid public key input");this._bn=new o.a(t)}else this._bn=new o.a(e);if(this._bn.byteLength()>x)throw new Error("Invalid public key input")}}static unique(){const e=new R(P);return P+=1,new R(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return c.a.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(n["Buffer"]);if(e.length===x)return e;const t=n["Buffer"].alloc(32);return e.copy(t,32-e.length),t}get[N](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const i=n["Buffer"].concat([e.toBuffer(),n["Buffer"].from(t),r.toBuffer()]),s=Object(u["sha256"])(i);return new R(s)}static createProgramAddressSync(e,t){let r=n["Buffer"].alloc(0);e.forEach((function(e){if(e.length>M)throw new TypeError("Max seed length exceeded");r=n["Buffer"].concat([r,O(e)])})),r=n["Buffer"].concat([r,t.toBuffer(),n["Buffer"].from("ProgramDerivedAddress")]);const i=Object(u["sha256"])(r);if(A(i))throw new Error("Invalid seeds, address must fall off the curve");return new R(i)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r,i=255;while(0!=i){try{const s=e.concat(n["Buffer"].from([i]));r=this.createProgramAddressSync(s,t)}catch(s){if(s instanceof TypeError)throw s;i--;continue}return[r,i]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new R(e);return A(t.toBytes())}}B=R,R.default=new B("11111111111111111111111111111111"),j.set(R,{kind:"struct",fields:[["_bn","u256"]]});new R("BPFLoader1111111111111111111111111111111111");const U=1232,z=127,W=64;class C extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(C.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class D extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature `+e+" using the Solana Explorer or CLI tools."),this.signature=void 0,this.signature=e}}Object.defineProperty(D.prototype,"name",{value:"TransactionExpiredTimeoutError"});class F extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(F.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class V{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){const t=255;if(this.length>t+1)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((e,t)=>{r.set(e.toBase58(),t)});const n=e=>{const t=r.get(e.toBase58());if(void 0===t)throw new Error("Encountered an unknown instruction account key during compilation");return t};return e.map(e=>({programIdIndex:n(e.programId),accountKeyIndexes:e.keys.map(e=>n(e.pubkey)),data:e.data}))}}const K=(e="publicKey")=>d["blob"](32,e),Q=(e="signature")=>d["blob"](64,e),H=(e="string")=>{const t=d["struct"]([d["u32"]("length"),d["u32"]("lengthPadding"),d["blob"](d["offset"](d["u32"](),-8),"chars")],e),r=t.decode.bind(t),i=t.encode.bind(t),s=t;return s.decode=(e,t)=>{const n=r(e,t);return n["chars"].toString()},s.encode=(e,t,r)=>{const s={chars:n["Buffer"].from(e,"utf8")};return i(s,t,r)},s.alloc=e=>d["u32"]().span+d["u32"]().span+n["Buffer"].from(e,"utf8").length,s},Z=(e="authorized")=>d["struct"]([K("staker"),K("withdrawer")],e),q=(e="lockup")=>d["struct"]([d["ns64"]("unixTimestamp"),d["ns64"]("epoch"),K("custodian")],e),Y=(e="voteInit")=>d["struct"]([K("nodePubkey"),K("authorizedVoter"),K("authorizedWithdrawer"),d["u8"]("commission")],e),G=(e="voteAuthorizeWithSeedArgs")=>d["struct"]([d["u32"]("voteAuthorizationType"),K("currentAuthorityDerivedKeyOwnerPubkey"),H("currentAuthorityDerivedKeySeed"),K("newAuthorized")],e);function J(e,t){const r=e=>{if(e.span>=0)return e.span;if("function"===typeof e.alloc)return e.alloc(t[e.property]);if("count"in e&&"elementLayout"in e){const n=t[e.property];if(Array.isArray(n))return n.length*r(e.elementLayout)}else if("fields"in e)return J({layout:e},t[e.property]);return 0};let n=0;return e.layout.fields.forEach(e=>{n+=r(e)}),n}function X(e){let t=0,r=0;for(;;){let n=e.shift();if(t|=(127&n)<<7*r,r+=1,0===(128&n))break}return t}function $(e,t){let r=t;for(;;){let t=127&r;if(r>>=7,0==r){e.push(t);break}t|=128,e.push(t)}}function ee(e,t){if(!e)throw new Error(t||"Assertion failed")}class te{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,n=e=>{const t=e.toBase58();let n=r.get(t);return void 0===n&&(n={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(t,n)),n},i=n(t);i.isSigner=!0,i.isWritable=!0;for(const s of e){n(s.programId).isInvoked=!0;for(const e of s.keys){const t=n(e.pubkey);t.isSigner||(t.isSigner=e.isSigner),t.isWritable||(t.isWritable=e.isWritable)}}return new te(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];ee(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,e])=>e.isSigner&&e.isWritable),r=e.filter(([,e])=>e.isSigner&&!e.isWritable),n=e.filter(([,e])=>!e.isSigner&&e.isWritable),i=e.filter(([,e])=>!e.isSigner&&!e.isWritable),s={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:i.length};{ee(t.length>0,"Expected at least one writable signer key");const[e]=t[0];ee(e===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const o=[...t.map(([e])=>new R(e)),...r.map(([e])=>new R(e)),...n.map(([e])=>new R(e)),...i.map(([e])=>new R(e))];return[s,o]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,e=>!e.isSigner&&!e.isInvoked&&e.isWritable),[n,i]=this.drainKeysFoundInLookupTable(e.state.addresses,e=>!e.isSigner&&!e.isInvoked&&!e.isWritable);if(0!==t.length||0!==n.length)return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:n},{writable:r,readonly:i}]}drainKeysFoundInLookupTable(e,t){const r=new Array,n=new Array;for(const[i,s]of this.keyMetaMap.entries())if(t(s)){const t=new R(i),s=e.findIndex(e=>e.equals(t));s>=0&&(ee(s<256,"Max lookup table index exceeded"),r.push(s),n.push(t),this.keyMetaMap.delete(i))}return[r,n]}}class re{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(e=>new R(e)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:c.a.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new V(this.staticAccountKeys)}static compile(e){const t=te.compile(e.instructions,e.payerKey),[r,n]=t.getMessageComponents(),i=new V(n),s=i.compileInstructions(e.instructions).map(e=>({programIdIndex:e.programIdIndex,accounts:e.accountKeyIndexes,data:c.a.encode(e.data)}));return new re({header:r,accountKeys:n,recentBlockhash:e.recentBlockhash,instructions:s})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const r=e-t,n=this.accountKeys.length-t,i=n-this.header.numReadonlyUnsignedAccounts;return r<i}{const r=t-this.header.numReadonlySignedAccounts;return e<r}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];$(t,e);const r=this.instructions.map(e=>{const{accounts:t,programIdIndex:r}=e,i=Array.from(c.a.decode(e.data));let s=[];$(s,t.length);let o=[];return $(o,i.length),{programIdIndex:r,keyIndicesCount:n["Buffer"].from(s),keyIndices:t,dataLength:n["Buffer"].from(o),data:i}});let i=[];$(i,r.length);let s=n["Buffer"].alloc(U);n["Buffer"].from(i).copy(s);let o=i.length;r.forEach(e=>{const t=d["struct"]([d["u8"]("programIdIndex"),d["blob"](e.keyIndicesCount.length,"keyIndicesCount"),d["seq"](d["u8"]("keyIndex"),e.keyIndices.length,"keyIndices"),d["blob"](e.dataLength.length,"dataLength"),d["seq"](d["u8"]("userdatum"),e.data.length,"data")]),r=t.encode(e,s,o);o+=r}),s=s.slice(0,o);const a=d["struct"]([d["blob"](1,"numRequiredSignatures"),d["blob"](1,"numReadonlySignedAccounts"),d["blob"](1,"numReadonlyUnsignedAccounts"),d["blob"](t.length,"keyCount"),d["seq"](K("key"),e,"keys"),K("recentBlockhash")]),u={numRequiredSignatures:n["Buffer"].from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:n["Buffer"].from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:n["Buffer"].from([this.header.numReadonlyUnsignedAccounts]),keyCount:n["Buffer"].from(t),keys:this.accountKeys.map(e=>O(e.toBytes())),recentBlockhash:c.a.decode(this.recentBlockhash)};let l=n["Buffer"].alloc(2048);const h=a.encode(u,l);return s.copy(l,h),l.slice(0,h+s.length)}static from(e){let t=[...e];const r=t.shift();if(r!==(r&z))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const i=t.shift(),s=t.shift(),o=X(t);let a=[];for(let c=0;c<o;c++){const e=t.splice(0,x);a.push(new R(n["Buffer"].from(e)))}const u=t.splice(0,x),l=X(t);let d=[];for(let b=0;b<l;b++){const e=t.shift(),r=X(t),i=t.splice(0,r),s=X(t),o=t.splice(0,s),a=c.a.encode(n["Buffer"].from(o));d.push({programIdIndex:e,accounts:i,data:a})}const h={header:{numRequiredSignatures:r,numReadonlySignedAccounts:i,numReadonlyUnsignedAccounts:s},recentBlockhash:c.a.encode(n["Buffer"].from(u)),accountKeys:a,instructions:d};return new re(h)}}class ne{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new V(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){const t=e-r,n=this.addressTableLookups.reduce((e,t)=>e+t.writableIndexes.length,0);return t<n}if(e>=this.header.numRequiredSignatures){const n=e-t,i=r-t,s=i-this.header.numReadonlyUnsignedAccounts;return n<s}{const r=t-this.header.numReadonlySignedAccounts;return e<r}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const n=e.find(e=>e.key.equals(r.accountKey));if(!n)throw new Error("Failed to find address lookup table account for table key "+r.accountKey.toBase58());for(const e of r.writableIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.writable.push(n.state.addresses[e])}for(const e of r.readonlyIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.readonly.push(n.state.addresses[e])}}return t}static compile(e){const t=te.compile(e.instructions,e.payerKey),r=new Array,n={writable:new Array,readonly:new Array},i=e.addressLookupTableAccounts||[];for(const u of i){const e=t.extractTableLookup(u);if(void 0!==e){const[t,{writable:i,readonly:s}]=e;r.push(t),n.writable.push(...i),n.readonly.push(...s)}}const[s,o]=t.getMessageComponents(),a=new V(o,n),c=a.compileInstructions(e.instructions);return new ne({header:s,staticAccountKeys:o,recentBlockhash:e.recentBlockhash,compiledInstructions:c,addressTableLookups:r})}serialize(){const e=Array();$(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();$(r,this.compiledInstructions.length);const n=this.serializeAddressTableLookups(),i=Array();$(i,this.addressTableLookups.length);const s=d["struct"]([d["u8"]("prefix"),d["struct"]([d["u8"]("numRequiredSignatures"),d["u8"]("numReadonlySignedAccounts"),d["u8"]("numReadonlyUnsignedAccounts")],"header"),d["blob"](e.length,"staticAccountKeysLength"),d["seq"](K(),this.staticAccountKeys.length,"staticAccountKeys"),K("recentBlockhash"),d["blob"](r.length,"instructionsLength"),d["blob"](t.length,"serializedInstructions"),d["blob"](i.length,"addressTableLookupsLength"),d["blob"](n.length,"serializedAddressTableLookups")]),o=new Uint8Array(U),a=128,u=s.encode({prefix:a,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(e=>e.toBytes()),recentBlockhash:c.a.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(i),serializedAddressTableLookups:n},o);return o.slice(0,u)}serializeInstructions(){let e=0;const t=new Uint8Array(U);for(const r of this.compiledInstructions){const n=Array();$(n,r.accountKeyIndexes.length);const i=Array();$(i,r.data.length);const s=d["struct"]([d["u8"]("programIdIndex"),d["blob"](n.length,"encodedAccountKeyIndexesLength"),d["seq"](d["u8"](),r.accountKeyIndexes.length,"accountKeyIndexes"),d["blob"](i.length,"encodedDataLength"),d["blob"](r.data.length,"data")]);e+=s.encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(n),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(i),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(U);for(const r of this.addressTableLookups){const n=Array();$(n,r.writableIndexes.length);const i=Array();$(i,r.readonlyIndexes.length);const s=d["struct"]([K("accountKey"),d["blob"](n.length,"encodedWritableIndexesLength"),d["seq"](d["u8"](),r.writableIndexes.length,"writableIndexes"),d["blob"](i.length,"encodedReadonlyIndexesLength"),d["seq"](d["u8"](),r.readonlyIndexes.length,"readonlyIndexes")]);e+=s.encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(n),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(i),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=t.shift(),n=r&z;ee(r!==n,"Expected versioned message but received legacy message");const i=n;ee(0===i,"Expected versioned message with version 0 but found version "+i);const s={numRequiredSignatures:t.shift(),numReadonlySignedAccounts:t.shift(),numReadonlyUnsignedAccounts:t.shift()},o=[],a=X(t);for(let c=0;c<a;c++)o.push(new R(t.splice(0,x)));const u=c.a.encode(t.splice(0,x)),l=X(t),d=[];for(let c=0;c<l;c++){const e=t.shift(),r=X(t),n=t.splice(0,r),i=X(t),s=new Uint8Array(t.splice(0,i));d.push({programIdIndex:e,accountKeyIndexes:n,data:s})}const h=X(t),b=[];for(let c=0;c<h;c++){const e=new R(t.splice(0,x)),r=X(t),n=t.splice(0,r),i=X(t),s=t.splice(0,i);b.push({accountKey:e,writableIndexes:n,readonlyIndexes:s})}return new ne({header:s,staticAccountKeys:o,recentBlockhash:u,compiledInstructions:d,addressTableLookups:b})}}const ie={deserializeMessageVersion(e){const t=e[0],r=t&z;return r===t?"legacy":r},deserialize:e=>{const t=ie.deserializeMessageVersion(e);if("legacy"===t)return re.from(e);if(0===t)return ne.deserialize(e);throw new Error(`Transaction message version ${t} deserialization is not supported`)}};let se=function(e){return e[e["BLOCKHEIGHT_EXCEEDED"]=0]="BLOCKHEIGHT_EXCEEDED",e[e["PROCESSED"]=1]="PROCESSED",e[e["TIMED_OUT"]=2]="TIMED_OUT",e[e["NONCE_INVALID"]=3]="NONCE_INVALID",e}({});const oe=n["Buffer"].alloc(W).fill(0);class ae{constructor(e){this.keys=void 0,this.programId=void 0,this.data=n["Buffer"].alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class ce{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(0===e.length)throw new Error("No instructions");return e.forEach(e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new ae(e))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t,r;if(this.nonceInfo?(e=this.nonceInfo.nonce,t=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");if(t.length,this.feePayer)r=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");r=this.signatures[0].publicKey}for(let c=0;c<t.length;c++)if(void 0===t[c].programId)throw new Error(`Transaction instruction index ${c} has undefined program id`);const n=[],i=[];t.forEach(e=>{e.keys.forEach(e=>{i.push({...e})});const t=e.programId.toString();n.includes(t)||n.push(t)}),n.forEach(e=>{i.push({pubkey:new R(e),isSigner:!1,isWritable:!1})});const s=[];i.forEach(e=>{const t=e.pubkey.toString(),r=s.findIndex(e=>e.pubkey.toString()===t);r>-1?(s[r].isWritable=s[r].isWritable||e.isWritable,s[r].isSigner=s[r].isSigner||e.isSigner):s.push(e)}),s.sort((function(e,t){if(e.isSigner!==t.isSigner)return e.isSigner?-1:1;if(e.isWritable!==t.isWritable)return e.isWritable?-1:1;const r={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return e.pubkey.toBase58().localeCompare(t.pubkey.toBase58(),"en",r)}));const o=s.findIndex(e=>e.pubkey.equals(r));if(o>-1){const[e]=s.splice(o,1);e.isSigner=!0,e.isWritable=!0,s.unshift(e)}else s.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const c of this.signatures){const e=s.findIndex(e=>e.pubkey.equals(c.publicKey));if(!(e>-1))throw new Error("unknown signer: "+c.publicKey.toString());s[e].isSigner||(s[e].isSigner=!0)}let a=0,u=0,l=0;const d=[],h=[];s.forEach(({pubkey:e,isSigner:t,isWritable:r})=>{t?(d.push(e.toString()),a+=1,r||(u+=1)):(h.push(e.toString()),r||(l+=1))});const b=d.concat(h),p=t.map(e=>{const{data:t,programId:r}=e;return{programIdIndex:b.indexOf(r.toString()),accounts:e.keys.map(e=>b.indexOf(e.pubkey.toString())),data:c.a.encode(t)}});return p.forEach(e=>{ee(e.programIdIndex>=0),e.accounts.forEach(e=>ee(e>=0))}),new re({header:{numRequiredSignatures:a,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:l},accountKeys:b,recentBlockhash:e,instructions:p})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);if(this.signatures.length===t.length){const r=this.signatures.every((e,r)=>t[r].equals(e.publicKey));if(r)return e}return this.signatures=t.map(e=>({signature:null,publicKey:e})),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(0===e.length)throw new Error("No signers");const t=new Set;this.signatures=e.filter(e=>{const r=e.toString();return!t.has(r)&&(t.add(r),!0)}).map(e=>({signature:null,publicKey:e}))}sign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const i of e){const e=i.publicKey.toString();t.has(e)||(t.add(e),r.push(i))}this.signatures=r.map(e=>({signature:null,publicKey:e.publicKey}));const n=this._compile();this._partialSign(n,...r)}partialSign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const i of e){const e=i.publicKey.toString();t.has(e)||(t.add(e),r.push(i))}const n=this._compile();this._partialSign(n,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach(e=>{const t=_(r,e.secretKey);this._addSignature(e.publicKey,O(t))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){ee(64===t.length);const r=this.signatures.findIndex(t=>e.equals(t.publicKey));if(r<0)throw new Error("unknown signer: "+e.toString());this.signatures[r].signature=n["Buffer"].from(t)}verifySignatures(e=!0){const t=this._getMessageSignednessErrors(this.serializeMessage(),e);return!t}_getMessageSignednessErrors(e,t){const r={};for(const{signature:n,publicKey:i}of this.signatures)null===n?t&&(r.missing||(r.missing=[])).push(i):E(n,e,i.toBytes())||(r.invalid||(r.invalid=[])).push(i);return r.invalid||r.missing?r:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r){const e=this._getMessageSignednessErrors(n,t);if(e){let t="Signature verification failed.";throw e.invalid&&(t+=`\nInvalid signature for public key${1===e.invalid.length?"":"(s)"} [\`${e.invalid.map(e=>e.toBase58()).join("`, `")}\`].`),e.missing&&(t+=`\nMissing signature for public key${1===e.missing.length?"":"(s)"} [\`${e.missing.map(e=>e.toBase58()).join("`, `")}\`].`),new Error(t)}}return this._serialize(n)}_serialize(e){const{signatures:t}=this,r=[];$(r,t.length);const i=r.length+64*t.length+e.length,s=n["Buffer"].alloc(i);return ee(t.length<256),n["Buffer"].from(r).copy(s,0),t.forEach(({signature:e},t)=>{null!==e&&(ee(64===e.length,"signature has invalid length"),n["Buffer"].from(e).copy(s,r.length+64*t))}),e.copy(s,r.length+64*t.length),ee(s.length<=U,`Transaction too large: ${s.length} > ${U}`),s}get keys(){return ee(1===this.instructions.length),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return ee(1===this.instructions.length),this.instructions[0].programId}get data(){return ee(1===this.instructions.length),this.instructions[0].data}static from(e){let t=[...e];const r=X(t);let i=[];for(let s=0;s<r;s++){const e=t.splice(0,W);i.push(c.a.encode(n["Buffer"].from(e)))}return ce.populate(re.from(t),i)}static populate(e,t=[]){const r=new ce;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach((t,n)=>{const i={signature:t==c.a.encode(oe)?null:c.a.decode(t),publicKey:e.accountKeys[n]};r.signatures.push(i)}),e.instructions.forEach(t=>{const n=t.accounts.map(t=>{const n=e.accountKeys[t];return{pubkey:n,isSigner:r.signatures.some(e=>e.publicKey.toString()===n.toString())||e.isAccountSigner(t),isWritable:e.isAccountWritable(t)}});r.instructions.push(new ae({keys:n,programId:e.accountKeys[t.programIdIndex],data:c.a.decode(t.data)}))}),r._message=e,r._json=r.toJSON(),r}}class ue{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:r,compiledInstructions:n,recentBlockhash:i}=e,{numRequiredSignatures:s,numReadonlySignedAccounts:o,numReadonlyUnsignedAccounts:a}=r,c=s-o;ee(c>0,"Message header is invalid");const u=e.staticAccountKeys.length-s-a;ee(u>=0,"Message header is invalid");const l=e.getAccountKeys(t),d=l.get(0);if(void 0===d)throw new Error("Failed to decompile message because no account keys were found");const h=[];for(const b of n){const e=[];for(const n of b.accountKeyIndexes){const t=l.get(n);if(void 0===t)throw new Error("Failed to find key for account key index "+n);const i=n<s;let o;o=i?n<c:n<l.staticAccountKeys.length?n-s<u:n-l.staticAccountKeys.length<l.accountKeysFromLookups.writable.length,e.push({pubkey:t,isSigner:n<r.numRequiredSignatures,isWritable:o})}const t=l.get(b.programIdIndex);if(void 0===t)throw new Error("Failed to find program id for program id index "+b.programIdIndex);h.push(new ae({programId:t,data:O(b.data),keys:e}))}return new ue({payerKey:d,instructions:h,recentBlockhash:i})}compileToLegacyMessage(){return re.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return ne.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class le{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,void 0!==t)ee(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const t=[];for(let r=0;r<e.header.numRequiredSignatures;r++)t.push(new Uint8Array(W));this.signatures=t}this.message=e}serialize(){const e=this.message.serialize(),t=Array();$(t,this.signatures.length);const r=d["struct"]([d["blob"](t.length,"encodedSignaturesLength"),d["seq"](Q(),this.signatures.length,"signatures"),d["blob"](e.length,"serializedMessage")]),n=new Uint8Array(2048),i=r.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},n);return n.slice(0,i)}static deserialize(e){let t=[...e];const r=[],n=X(t);for(let s=0;s<n;s++)r.push(new Uint8Array(t.splice(0,W)));const i=ie.deserialize(new Uint8Array(t));return new le(i,r)}sign(e){const t=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const n of e){const e=r.findIndex(e=>e.equals(n.publicKey));ee(e>=0,"Cannot sign with non signer key "+n.publicKey.toBase58()),this.signatures[e]=_(t,n.secretKey)}}addSignature(e,t){ee(64===t.byteLength,"Signature must be 64 bytes long");const r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures),n=r.findIndex(t=>t.equals(e));ee(n>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[n]=t}}const de=160,he=64,be=de/he,pe=1e3/be,ge=new R("SysvarC1ock11111111111111111111111111111111"),ye=(new R("SysvarEpochSchedu1e111111111111111111111111"),new R("Sysvar1nstructions1111111111111111111111111"),new R("SysvarRecentB1ockHashes11111111111111111111")),me=new R("SysvarRent111111111111111111111111111111111"),fe=(new R("SysvarRewards111111111111111111111111111111"),new R("SysvarS1otHashes111111111111111111111111111"),new R("SysvarS1otHistory11111111111111111111111111"),new R("SysvarStakeHistory1111111111111111111111111"));async function ke(e,t,r,n){const i=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},s=await e.sendTransaction(t,r,i);let o;if(null!=t.recentBlockhash&&null!=t.lastValidBlockHeight)o=(await e.confirmTransaction({abortSignal:null===n||void 0===n?void 0:n.abortSignal,signature:s,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},n&&n.commitment)).value;else if(null!=t.minNonceContextSlot&&null!=t.nonceInfo){const{nonceInstruction:r}=t.nonceInfo,i=r.keys[0].pubkey;o=(await e.confirmTransaction({abortSignal:null===n||void 0===n?void 0:n.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:i,nonceValue:t.nonceInfo.nonce,signature:s},n&&n.commitment)).value}else null===n||void 0===n||n.abortSignal,o=(await e.confirmTransaction(s,n&&n.commitment)).value;if(o.err)throw new Error(`Transaction ${s} failed (${JSON.stringify(o)})`);return s}function we(e){return new Promise(t=>setTimeout(t,e))}function Se(e,t){const r=e.layout.span>=0?e.layout.span:J(e,t),i=n["Buffer"].alloc(r),s=Object.assign({instruction:e.index},t);return e.layout.encode(s,i),i}const Ie=d["nu64"]("lamportsPerSignature"),ve=d["struct"]([d["u32"]("version"),d["u32"]("state"),K("authorizedPubkey"),K("nonce"),d["struct"]([Ie],"feeCalculator")]),Ae=ve.span;class _e{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=ve.decode(O(e),0);return new _e({authorizedPubkey:new R(t.authorizedPubkey),nonce:new R(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const Ee=e=>{const t=e.decode.bind(e),r=e.encode.bind(e);return{decode:t,encode:r}},Oe=e=>t=>{const r=Object(d["blob"])(e,t),{encode:i,decode:s}=Ee(r),o=r;return o.decode=(e,t)=>{const r=s(e,t);return Object(h["toBigIntLE"])(n["Buffer"].from(r))},o.encode=(t,r,n)=>{const s=Object(h["toBufferLE"])(t,e);return i(s,r,n)},o},Te=Oe(8);const je=Object.freeze({Create:{index:0,layout:d["struct"]([d["u32"]("instruction"),d["ns64"]("lamports"),d["ns64"]("space"),K("programId")])},Assign:{index:1,layout:d["struct"]([d["u32"]("instruction"),K("programId")])},Transfer:{index:2,layout:d["struct"]([d["u32"]("instruction"),Te("lamports")])},CreateWithSeed:{index:3,layout:d["struct"]([d["u32"]("instruction"),K("base"),H("seed"),d["ns64"]("lamports"),d["ns64"]("space"),K("programId")])},AdvanceNonceAccount:{index:4,layout:d["struct"]([d["u32"]("instruction")])},WithdrawNonceAccount:{index:5,layout:d["struct"]([d["u32"]("instruction"),d["ns64"]("lamports")])},InitializeNonceAccount:{index:6,layout:d["struct"]([d["u32"]("instruction"),K("authorized")])},AuthorizeNonceAccount:{index:7,layout:d["struct"]([d["u32"]("instruction"),K("authorized")])},Allocate:{index:8,layout:d["struct"]([d["u32"]("instruction"),d["ns64"]("space")])},AllocateWithSeed:{index:9,layout:d["struct"]([d["u32"]("instruction"),K("base"),H("seed"),d["ns64"]("space"),K("programId")])},AssignWithSeed:{index:10,layout:d["struct"]([d["u32"]("instruction"),K("base"),H("seed"),K("programId")])},TransferWithSeed:{index:11,layout:d["struct"]([d["u32"]("instruction"),Te("lamports"),H("seed"),K("programId")])},UpgradeNonceAccount:{index:12,layout:d["struct"]([d["u32"]("instruction")])}});class Be{constructor(){}static createAccount(e){const t=je.Create,r=Se(t,{lamports:e.lamports,space:e.space,programId:O(e.programId.toBuffer())});return new ae({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(e){let t,r;if("basePubkey"in e){const n=je.TransferWithSeed;t=Se(n,{lamports:BigInt(e.lamports),seed:e.seed,programId:O(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const n=je.Transfer;t=Se(n,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new ae({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){const n=je.AssignWithSeed;t=Se(n,{base:O(e.basePubkey.toBuffer()),seed:e.seed,programId:O(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const n=je.Assign;t=Se(n,{programId:O(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new ae({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=je.CreateWithSeed,r=Se(t,{base:O(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:O(e.programId.toBuffer())});let n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&n.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new ae({keys:n,programId:this.programId,data:r})}static createNonceAccount(e){const t=new ce;"basePubkey"in e&&"seed"in e?t.add(Be.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Ae,programId:this.programId})):t.add(Be.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Ae,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=je.InitializeNonceAccount,r=Se(t,{authorized:O(e.authorizedPubkey.toBuffer())}),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new ae(n)}static nonceAdvance(e){const t=je.AdvanceNonceAccount,r=Se(t),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new ae(n)}static nonceWithdraw(e){const t=je.WithdrawNonceAccount,r=Se(t,{lamports:e.lamports});return new ae({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(e){const t=je.AuthorizeNonceAccount,r=Se(t,{authorized:O(e.newAuthorizedPubkey.toBuffer())});return new ae({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(e){let t,r;if("basePubkey"in e){const n=je.AllocateWithSeed;t=Se(n,{base:O(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:O(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const n=je.Allocate;t=Se(n,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new ae({keys:r,programId:this.programId,data:t})}}Be.programId=new R("11111111111111111111111111111111");const Ne=U-300;class Me{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/Me.chunkSize)+1+1)}static async load(e,t,r,i,s){{const n=await e.getMinimumBalanceForRentExemption(s.length),o=await e.getAccountInfo(r.publicKey,"confirmed");let a=null;if(null!==o){if(o.executable)return!1;o.data.length!==s.length&&(a=a||new ce,a.add(Be.allocate({accountPubkey:r.publicKey,space:s.length}))),o.owner.equals(i)||(a=a||new ce,a.add(Be.assign({accountPubkey:r.publicKey,programId:i}))),o.lamports<n&&(a=a||new ce,a.add(Be.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:n-o.lamports})))}else a=(new ce).add(Be.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:n>0?n:1,space:s.length,programId:i}));null!==a&&await ke(e,a,[t,r],{commitment:"confirmed"})}const o=d["struct"]([d["u32"]("instruction"),d["u32"]("offset"),d["u32"]("bytesLength"),d["u32"]("bytesLengthPadding"),d["seq"](d["u8"]("byte"),d["offset"](d["u32"](),-8),"bytes")]),a=Me.chunkSize;let c=0,u=s,l=[];while(u.length>0){const s=u.slice(0,a),d=n["Buffer"].alloc(a+16);o.encode({instruction:0,offset:c,bytes:s,bytesLength:0,bytesLengthPadding:0},d);const h=(new ce).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:i,data:d});if(l.push(ke(e,h,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")){const e=4;await we(1e3/e)}c+=a,u=u.slice(a)}await Promise.all(l);{const s=d["struct"]([d["u32"]("instruction")]),o=n["Buffer"].alloc(s.span);s.encode({instruction:1},o);const a=(new ce).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:me,isSigner:!1,isWritable:!1}],programId:i,data:o}),c="processed",u=await e.sendTransaction(a,[t,r],{preflightCommitment:c}),{context:l,value:h}=await e.confirmTransaction({signature:u,lastValidBlockHeight:a.lastValidBlockHeight,blockhash:a.recentBlockhash},c);if(h.err)throw new Error(`Transaction ${u} failed (${JSON.stringify(h)})`);while(1){try{const t=await e.getSlot({commitment:c});if(t>l.slot)break}catch{}await new Promise(e=>setTimeout(e,Math.round(pe/2)))}}return!0}}Me.chunkSize=Ne;new R("BPFLoader2111111111111111111111111111111111");function xe(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e["default"]:e}var Le=Object.prototype.toString,Pe=Object.keys||function(e){var t=[];for(var r in e)t.push(r);return t};function Re(e,t){var r,n,i,s,o,a,c;if(!0===e)return"true";if(!1===e)return"false";switch(typeof e){case"object":if(null===e)return null;if(e.toJSON&&"function"===typeof e.toJSON)return Re(e.toJSON(),t);if(c=Le.call(e),"[object Array]"===c){for(i="[",n=e.length-1,r=0;r<n;r++)i+=Re(e[r],!0)+",";return n>-1&&(i+=Re(e[r],!0)),i+"]"}if("[object Object]"===c){s=Pe(e).sort(),n=s.length,i="",r=0;while(r<n)o=s[r],a=Re(e[o],!1),void 0!==a&&(i&&(i+=","),i+=JSON.stringify(o)+":"+a),r++;return"{"+i+"}"}return JSON.stringify(e);case"function":case"undefined":return t?null:void 0;case"string":return JSON.stringify(e);default:return isFinite(e)?e:null}}var Ue=function(e){var t=Re(e,!1);if(void 0!==t)return""+t},ze=xe(Ue);const We=32;function Ce(e){let t=0;while(e>1)e/=2,t++;return t}function De(e){return 0===e?1:(e--,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,e|=e>>32,e+1)}class Fe{constructor(e,t,r,n,i){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=r,this.firstNormalEpoch=n,this.firstNormalSlot=i}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=Ce(De(e+We+1))-Ce(We)-1,r=this.getSlotsInEpoch(t),n=e-(r-We);return[t,n]}{const t=e-this.firstNormalSlot,r=Math.floor(t/this.slotsPerEpoch),n=this.firstNormalEpoch+r,i=t%this.slotsPerEpoch;return[n,i]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*We:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Ce(We)):this.slotsPerEpoch}}class Ve extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}class Ke extends Error{constructor({code:e,message:t,data:r},n){super(null!=n?`${n}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=r,this.name="SolanaJSONRPCError"}}var Qe=globalThis.fetch;class He extends m.a{constructor(e,t,r){const n=e=>{const r=k()(e,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return this.underlyingSocket="socket"in r?r.socket:r,r};super(n,e,t,r),this.underlyingSocket=void 0}call(...e){var t;const r=null===(t=this.underlyingSocket)||void 0===t?void 0:t.readyState;return 1===r?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}notify(...e){var t;const r=null===(t=this.underlyingSocket)||void 0===t?void 0:t.readyState;return 1===r?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}}function Ze(e,t){let r;try{r=e.layout.decode(t)}catch(n){throw new Error("invalid instruction; "+n)}if(r.typeIndex!==e.index)throw new Error(`invalid account data; account type mismatch ${r.typeIndex} != ${e.index}`);return r}const qe=56;class Ye{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=Ze(Ge,e),r=e.length-qe;ee(r>=0,"lookup table is invalid"),ee(r%32===0,"lookup table is invalid");const n=r/32,{addresses:i}=d["struct"]([d["seq"](K(),n,"addresses")]).decode(e.slice(qe));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:0!==t.authority.length?new R(t.authority[0]):void 0,addresses:i.map(e=>new R(e))}}}const Ge={index:1,layout:d["struct"]([d["u32"]("typeIndex"),Te("deactivationSlot"),d["nu64"]("lastExtendedSlot"),d["u8"]("lastExtendedStartIndex"),d["u8"](),d["seq"](K(),d["offset"](d["u8"](),-1),"authority")])},Je=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Xe(e){const t=e.match(Je);if(null==t)throw TypeError(`Failed to validate endpoint URL \`${e}\``);const[r,n,i,s]=t,o=e.startsWith("https:")?"wss:":"ws:",a=null==i?null:parseInt(i.slice(1),10),c=null==a?"":":"+(a+1);return`${o}//${n}${c}${s}`}const $e=Object(b["coerce"])(Object(b["instance"])(R),Object(b["string"])(),e=>new R(e)),et=Object(b["tuple"])([Object(b["string"])(),Object(b["literal"])("base64")]),tt=Object(b["coerce"])(Object(b["instance"])(n["Buffer"]),et,e=>n["Buffer"].from(e[0],"base64")),rt=3e4;function nt(e){if(!1===/^https?:/.test(e))throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return e}function it(e){let t,r;if("string"===typeof e)t=e;else if(e){const{commitment:n,...i}=e;t=n,r=i}return{commitment:t,config:r}}function st(e){return Object(b["union"])([Object(b["type"])({jsonrpc:Object(b["literal"])("2.0"),id:Object(b["string"])(),result:e}),Object(b["type"])({jsonrpc:Object(b["literal"])("2.0"),id:Object(b["string"])(),error:Object(b["type"])({code:Object(b["unknown"])(),message:Object(b["string"])(),data:Object(b["optional"])(Object(b["any"])())})})])}const ot=st(Object(b["unknown"])());function at(e){return Object(b["coerce"])(st(e),ot,t=>"error"in t?t:{...t,result:Object(b["create"])(t.result,e)})}function ct(e){return at(Object(b["type"])({context:Object(b["type"])({slot:Object(b["number"])()}),value:e}))}function ut(e){return Object(b["type"])({context:Object(b["type"])({slot:Object(b["number"])()}),value:e})}function lt(e,t){return 0===e?new ne({header:t.header,staticAccountKeys:t.accountKeys.map(e=>new R(e)),recentBlockhash:t.recentBlockhash,compiledInstructions:t.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:c.a.decode(e.data)})),addressTableLookups:t.addressTableLookups}):new re(t)}const dt=Object(b["type"])({foundation:Object(b["number"])(),foundationTerm:Object(b["number"])(),initial:Object(b["number"])(),taper:Object(b["number"])(),terminal:Object(b["number"])()}),ht=at(Object(b["array"])(Object(b["nullable"])(Object(b["type"])({epoch:Object(b["number"])(),effectiveSlot:Object(b["number"])(),amount:Object(b["number"])(),postBalance:Object(b["number"])(),commission:Object(b["optional"])(Object(b["nullable"])(Object(b["number"])()))})))),bt=Object(b["array"])(Object(b["type"])({slot:Object(b["number"])(),prioritizationFee:Object(b["number"])()})),pt=Object(b["type"])({total:Object(b["number"])(),validator:Object(b["number"])(),foundation:Object(b["number"])(),epoch:Object(b["number"])()}),gt=Object(b["type"])({epoch:Object(b["number"])(),slotIndex:Object(b["number"])(),slotsInEpoch:Object(b["number"])(),absoluteSlot:Object(b["number"])(),blockHeight:Object(b["optional"])(Object(b["number"])()),transactionCount:Object(b["optional"])(Object(b["number"])())}),yt=Object(b["type"])({slotsPerEpoch:Object(b["number"])(),leaderScheduleSlotOffset:Object(b["number"])(),warmup:Object(b["boolean"])(),firstNormalEpoch:Object(b["number"])(),firstNormalSlot:Object(b["number"])()}),mt=Object(b["record"])(Object(b["string"])(),Object(b["array"])(Object(b["number"])())),ft=Object(b["nullable"])(Object(b["union"])([Object(b["type"])({}),Object(b["string"])()])),kt=Object(b["type"])({err:ft}),wt=Object(b["literal"])("receivedSignature"),St=Object(b["type"])({"solana-core":Object(b["string"])(),"feature-set":Object(b["optional"])(Object(b["number"])())}),It=ct(Object(b["type"])({err:Object(b["nullable"])(Object(b["union"])([Object(b["type"])({}),Object(b["string"])()])),logs:Object(b["nullable"])(Object(b["array"])(Object(b["string"])())),accounts:Object(b["optional"])(Object(b["nullable"])(Object(b["array"])(Object(b["nullable"])(Object(b["type"])({executable:Object(b["boolean"])(),owner:Object(b["string"])(),lamports:Object(b["number"])(),data:Object(b["array"])(Object(b["string"])()),rentEpoch:Object(b["optional"])(Object(b["number"])())}))))),unitsConsumed:Object(b["optional"])(Object(b["number"])()),returnData:Object(b["optional"])(Object(b["nullable"])(Object(b["type"])({programId:Object(b["string"])(),data:Object(b["tuple"])([Object(b["string"])(),Object(b["literal"])("base64")])})))})),vt=ct(Object(b["type"])({byIdentity:Object(b["record"])(Object(b["string"])(),Object(b["array"])(Object(b["number"])())),range:Object(b["type"])({firstSlot:Object(b["number"])(),lastSlot:Object(b["number"])()})}));function At(e,t,r,n,i,s){const o=r||Qe;let a,c;n&&(c=async(e,t)=>{const r=await new Promise((r,i)=>{try{n(e,t,(e,t)=>r([e,t]))}catch(s){i(s)}});return await o(...r)});const u=new g.a(async(r,n)=>{const s={method:"POST",body:r,agent:a,headers:Object.assign({"Content-Type":"application/json"},t||{},Zr)};try{let t,r=5,a=500;for(;;){if(t=c?await c(e,s):await o(e,s),429!==t.status)break;if(!0===i)break;if(r-=1,0===r)break;await we(a),a*=2}const u=await t.text();t.ok?n(null,u):n(new Error(`${t.status} ${t.statusText}: ${u}`))}catch(u){u instanceof Error&&n(u)}},{});return u}function _t(e){return(t,r)=>new Promise((n,i)=>{e.request(t,r,(e,t)=>{e?i(e):n(t)})})}function Et(e){return t=>new Promise((r,n)=>{0===t.length&&r([]);const i=t.map(t=>e.request(t.methodName,t.args));e.request(i,(e,t)=>{e?n(e):r(t)})})}const Ot=at(dt),Tt=at(pt),jt=at(bt),Bt=at(gt),Nt=at(yt),Mt=at(mt),xt=at(Object(b["number"])()),Lt=ct(Object(b["type"])({total:Object(b["number"])(),circulating:Object(b["number"])(),nonCirculating:Object(b["number"])(),nonCirculatingAccounts:Object(b["array"])($e)})),Pt=Object(b["type"])({amount:Object(b["string"])(),uiAmount:Object(b["nullable"])(Object(b["number"])()),decimals:Object(b["number"])(),uiAmountString:Object(b["optional"])(Object(b["string"])())}),Rt=ct(Object(b["array"])(Object(b["type"])({address:$e,amount:Object(b["string"])(),uiAmount:Object(b["nullable"])(Object(b["number"])()),decimals:Object(b["number"])(),uiAmountString:Object(b["optional"])(Object(b["string"])())}))),Ut=ct(Object(b["array"])(Object(b["type"])({pubkey:$e,account:Object(b["type"])({executable:Object(b["boolean"])(),owner:$e,lamports:Object(b["number"])(),data:tt,rentEpoch:Object(b["number"])()})}))),zt=Object(b["type"])({program:Object(b["string"])(),parsed:Object(b["unknown"])(),space:Object(b["number"])()}),Wt=ct(Object(b["array"])(Object(b["type"])({pubkey:$e,account:Object(b["type"])({executable:Object(b["boolean"])(),owner:$e,lamports:Object(b["number"])(),data:zt,rentEpoch:Object(b["number"])()})}))),Ct=ct(Object(b["array"])(Object(b["type"])({lamports:Object(b["number"])(),address:$e}))),Dt=Object(b["type"])({executable:Object(b["boolean"])(),owner:$e,lamports:Object(b["number"])(),data:tt,rentEpoch:Object(b["number"])()}),Ft=Object(b["type"])({pubkey:$e,account:Dt}),Vt=Object(b["coerce"])(Object(b["union"])([Object(b["instance"])(n["Buffer"]),zt]),Object(b["union"])([et,zt]),e=>Array.isArray(e)?Object(b["create"])(e,tt):e),Kt=Object(b["type"])({executable:Object(b["boolean"])(),owner:$e,lamports:Object(b["number"])(),data:Vt,rentEpoch:Object(b["number"])()}),Qt=Object(b["type"])({pubkey:$e,account:Kt}),Ht=Object(b["type"])({state:Object(b["union"])([Object(b["literal"])("active"),Object(b["literal"])("inactive"),Object(b["literal"])("activating"),Object(b["literal"])("deactivating")]),active:Object(b["number"])(),inactive:Object(b["number"])()}),Zt=at(Object(b["array"])(Object(b["type"])({signature:Object(b["string"])(),slot:Object(b["number"])(),err:ft,memo:Object(b["nullable"])(Object(b["string"])()),blockTime:Object(b["optional"])(Object(b["nullable"])(Object(b["number"])()))}))),qt=at(Object(b["array"])(Object(b["type"])({signature:Object(b["string"])(),slot:Object(b["number"])(),err:ft,memo:Object(b["nullable"])(Object(b["string"])()),blockTime:Object(b["optional"])(Object(b["nullable"])(Object(b["number"])()))}))),Yt=Object(b["type"])({subscription:Object(b["number"])(),result:ut(Dt)}),Gt=Object(b["type"])({pubkey:$e,account:Dt}),Jt=Object(b["type"])({subscription:Object(b["number"])(),result:ut(Gt)}),Xt=Object(b["type"])({parent:Object(b["number"])(),slot:Object(b["number"])(),root:Object(b["number"])()}),$t=Object(b["type"])({subscription:Object(b["number"])(),result:Xt}),er=Object(b["union"])([Object(b["type"])({type:Object(b["union"])([Object(b["literal"])("firstShredReceived"),Object(b["literal"])("completed"),Object(b["literal"])("optimisticConfirmation"),Object(b["literal"])("root")]),slot:Object(b["number"])(),timestamp:Object(b["number"])()}),Object(b["type"])({type:Object(b["literal"])("createdBank"),parent:Object(b["number"])(),slot:Object(b["number"])(),timestamp:Object(b["number"])()}),Object(b["type"])({type:Object(b["literal"])("frozen"),slot:Object(b["number"])(),timestamp:Object(b["number"])(),stats:Object(b["type"])({numTransactionEntries:Object(b["number"])(),numSuccessfulTransactions:Object(b["number"])(),numFailedTransactions:Object(b["number"])(),maxTransactionsPerEntry:Object(b["number"])()})}),Object(b["type"])({type:Object(b["literal"])("dead"),slot:Object(b["number"])(),timestamp:Object(b["number"])(),err:Object(b["string"])()})]),tr=Object(b["type"])({subscription:Object(b["number"])(),result:er}),rr=Object(b["type"])({subscription:Object(b["number"])(),result:ut(Object(b["union"])([kt,wt]))}),nr=Object(b["type"])({subscription:Object(b["number"])(),result:Object(b["number"])()}),ir=Object(b["type"])({pubkey:Object(b["string"])(),gossip:Object(b["nullable"])(Object(b["string"])()),tpu:Object(b["nullable"])(Object(b["string"])()),rpc:Object(b["nullable"])(Object(b["string"])()),version:Object(b["nullable"])(Object(b["string"])())}),sr=Object(b["type"])({votePubkey:Object(b["string"])(),nodePubkey:Object(b["string"])(),activatedStake:Object(b["number"])(),epochVoteAccount:Object(b["boolean"])(),epochCredits:Object(b["array"])(Object(b["tuple"])([Object(b["number"])(),Object(b["number"])(),Object(b["number"])()])),commission:Object(b["number"])(),lastVote:Object(b["number"])(),rootSlot:Object(b["nullable"])(Object(b["number"])())}),or=at(Object(b["type"])({current:Object(b["array"])(sr),delinquent:Object(b["array"])(sr)})),ar=Object(b["union"])([Object(b["literal"])("processed"),Object(b["literal"])("confirmed"),Object(b["literal"])("finalized")]),cr=Object(b["type"])({slot:Object(b["number"])(),confirmations:Object(b["nullable"])(Object(b["number"])()),err:ft,confirmationStatus:Object(b["optional"])(ar)}),ur=ct(Object(b["array"])(Object(b["nullable"])(cr))),lr=at(Object(b["number"])()),dr=Object(b["type"])({accountKey:$e,writableIndexes:Object(b["array"])(Object(b["number"])()),readonlyIndexes:Object(b["array"])(Object(b["number"])())}),hr=Object(b["type"])({signatures:Object(b["array"])(Object(b["string"])()),message:Object(b["type"])({accountKeys:Object(b["array"])(Object(b["string"])()),header:Object(b["type"])({numRequiredSignatures:Object(b["number"])(),numReadonlySignedAccounts:Object(b["number"])(),numReadonlyUnsignedAccounts:Object(b["number"])()}),instructions:Object(b["array"])(Object(b["type"])({accounts:Object(b["array"])(Object(b["number"])()),data:Object(b["string"])(),programIdIndex:Object(b["number"])()})),recentBlockhash:Object(b["string"])(),addressTableLookups:Object(b["optional"])(Object(b["array"])(dr))})}),br=Object(b["type"])({pubkey:$e,signer:Object(b["boolean"])(),writable:Object(b["boolean"])(),source:Object(b["optional"])(Object(b["union"])([Object(b["literal"])("transaction"),Object(b["literal"])("lookupTable")]))}),pr=Object(b["type"])({accountKeys:Object(b["array"])(br),signatures:Object(b["array"])(Object(b["string"])())}),gr=Object(b["type"])({parsed:Object(b["unknown"])(),program:Object(b["string"])(),programId:$e}),yr=Object(b["type"])({accounts:Object(b["array"])($e),data:Object(b["string"])(),programId:$e}),mr=Object(b["union"])([yr,gr]),fr=Object(b["union"])([Object(b["type"])({parsed:Object(b["unknown"])(),program:Object(b["string"])(),programId:Object(b["string"])()}),Object(b["type"])({accounts:Object(b["array"])(Object(b["string"])()),data:Object(b["string"])(),programId:Object(b["string"])()})]),kr=Object(b["coerce"])(mr,fr,e=>"accounts"in e?Object(b["create"])(e,yr):Object(b["create"])(e,gr)),wr=Object(b["type"])({signatures:Object(b["array"])(Object(b["string"])()),message:Object(b["type"])({accountKeys:Object(b["array"])(br),instructions:Object(b["array"])(kr),recentBlockhash:Object(b["string"])(),addressTableLookups:Object(b["optional"])(Object(b["nullable"])(Object(b["array"])(dr)))})}),Sr=Object(b["type"])({accountIndex:Object(b["number"])(),mint:Object(b["string"])(),owner:Object(b["optional"])(Object(b["string"])()),uiTokenAmount:Pt}),Ir=Object(b["type"])({writable:Object(b["array"])($e),readonly:Object(b["array"])($e)}),vr=Object(b["type"])({err:ft,fee:Object(b["number"])(),innerInstructions:Object(b["optional"])(Object(b["nullable"])(Object(b["array"])(Object(b["type"])({index:Object(b["number"])(),instructions:Object(b["array"])(Object(b["type"])({accounts:Object(b["array"])(Object(b["number"])()),data:Object(b["string"])(),programIdIndex:Object(b["number"])()}))})))),preBalances:Object(b["array"])(Object(b["number"])()),postBalances:Object(b["array"])(Object(b["number"])()),logMessages:Object(b["optional"])(Object(b["nullable"])(Object(b["array"])(Object(b["string"])()))),preTokenBalances:Object(b["optional"])(Object(b["nullable"])(Object(b["array"])(Sr))),postTokenBalances:Object(b["optional"])(Object(b["nullable"])(Object(b["array"])(Sr))),loadedAddresses:Object(b["optional"])(Ir),computeUnitsConsumed:Object(b["optional"])(Object(b["number"])())}),Ar=Object(b["type"])({err:ft,fee:Object(b["number"])(),innerInstructions:Object(b["optional"])(Object(b["nullable"])(Object(b["array"])(Object(b["type"])({index:Object(b["number"])(),instructions:Object(b["array"])(kr)})))),preBalances:Object(b["array"])(Object(b["number"])()),postBalances:Object(b["array"])(Object(b["number"])()),logMessages:Object(b["optional"])(Object(b["nullable"])(Object(b["array"])(Object(b["string"])()))),preTokenBalances:Object(b["optional"])(Object(b["nullable"])(Object(b["array"])(Sr))),postTokenBalances:Object(b["optional"])(Object(b["nullable"])(Object(b["array"])(Sr))),loadedAddresses:Object(b["optional"])(Ir),computeUnitsConsumed:Object(b["optional"])(Object(b["number"])())}),_r=Object(b["union"])([Object(b["literal"])(0),Object(b["literal"])("legacy")]),Er=Object(b["type"])({pubkey:Object(b["string"])(),lamports:Object(b["number"])(),postBalance:Object(b["nullable"])(Object(b["number"])()),rewardType:Object(b["nullable"])(Object(b["string"])()),commission:Object(b["optional"])(Object(b["nullable"])(Object(b["number"])()))}),Or=at(Object(b["nullable"])(Object(b["type"])({blockhash:Object(b["string"])(),previousBlockhash:Object(b["string"])(),parentSlot:Object(b["number"])(),transactions:Object(b["array"])(Object(b["type"])({transaction:hr,meta:Object(b["nullable"])(vr),version:Object(b["optional"])(_r)})),rewards:Object(b["optional"])(Object(b["array"])(Er)),blockTime:Object(b["nullable"])(Object(b["number"])()),blockHeight:Object(b["nullable"])(Object(b["number"])())}))),Tr=at(Object(b["nullable"])(Object(b["type"])({blockhash:Object(b["string"])(),previousBlockhash:Object(b["string"])(),parentSlot:Object(b["number"])(),rewards:Object(b["optional"])(Object(b["array"])(Er)),blockTime:Object(b["nullable"])(Object(b["number"])()),blockHeight:Object(b["nullable"])(Object(b["number"])())}))),jr=at(Object(b["nullable"])(Object(b["type"])({blockhash:Object(b["string"])(),previousBlockhash:Object(b["string"])(),parentSlot:Object(b["number"])(),transactions:Object(b["array"])(Object(b["type"])({transaction:pr,meta:Object(b["nullable"])(vr),version:Object(b["optional"])(_r)})),rewards:Object(b["optional"])(Object(b["array"])(Er)),blockTime:Object(b["nullable"])(Object(b["number"])()),blockHeight:Object(b["nullable"])(Object(b["number"])())}))),Br=at(Object(b["nullable"])(Object(b["type"])({blockhash:Object(b["string"])(),previousBlockhash:Object(b["string"])(),parentSlot:Object(b["number"])(),transactions:Object(b["array"])(Object(b["type"])({transaction:wr,meta:Object(b["nullable"])(Ar),version:Object(b["optional"])(_r)})),rewards:Object(b["optional"])(Object(b["array"])(Er)),blockTime:Object(b["nullable"])(Object(b["number"])()),blockHeight:Object(b["nullable"])(Object(b["number"])())}))),Nr=at(Object(b["nullable"])(Object(b["type"])({blockhash:Object(b["string"])(),previousBlockhash:Object(b["string"])(),parentSlot:Object(b["number"])(),transactions:Object(b["array"])(Object(b["type"])({transaction:pr,meta:Object(b["nullable"])(Ar),version:Object(b["optional"])(_r)})),rewards:Object(b["optional"])(Object(b["array"])(Er)),blockTime:Object(b["nullable"])(Object(b["number"])()),blockHeight:Object(b["nullable"])(Object(b["number"])())}))),Mr=at(Object(b["nullable"])(Object(b["type"])({blockhash:Object(b["string"])(),previousBlockhash:Object(b["string"])(),parentSlot:Object(b["number"])(),rewards:Object(b["optional"])(Object(b["array"])(Er)),blockTime:Object(b["nullable"])(Object(b["number"])()),blockHeight:Object(b["nullable"])(Object(b["number"])())}))),xr=at(Object(b["nullable"])(Object(b["type"])({blockhash:Object(b["string"])(),previousBlockhash:Object(b["string"])(),parentSlot:Object(b["number"])(),transactions:Object(b["array"])(Object(b["type"])({transaction:hr,meta:Object(b["nullable"])(vr)})),rewards:Object(b["optional"])(Object(b["array"])(Er)),blockTime:Object(b["nullable"])(Object(b["number"])())}))),Lr=at(Object(b["nullable"])(Object(b["type"])({blockhash:Object(b["string"])(),previousBlockhash:Object(b["string"])(),parentSlot:Object(b["number"])(),signatures:Object(b["array"])(Object(b["string"])()),blockTime:Object(b["nullable"])(Object(b["number"])())}))),Pr=at(Object(b["nullable"])(Object(b["type"])({slot:Object(b["number"])(),meta:Object(b["nullable"])(vr),blockTime:Object(b["optional"])(Object(b["nullable"])(Object(b["number"])())),transaction:hr,version:Object(b["optional"])(_r)}))),Rr=at(Object(b["nullable"])(Object(b["type"])({slot:Object(b["number"])(),transaction:wr,meta:Object(b["nullable"])(Ar),blockTime:Object(b["optional"])(Object(b["nullable"])(Object(b["number"])())),version:Object(b["optional"])(_r)}))),Ur=ct(Object(b["type"])({blockhash:Object(b["string"])(),feeCalculator:Object(b["type"])({lamportsPerSignature:Object(b["number"])()})})),zr=ct(Object(b["type"])({blockhash:Object(b["string"])(),lastValidBlockHeight:Object(b["number"])()})),Wr=ct(Object(b["boolean"])()),Cr=Object(b["type"])({slot:Object(b["number"])(),numTransactions:Object(b["number"])(),numSlots:Object(b["number"])(),samplePeriodSecs:Object(b["number"])()}),Dr=at(Object(b["array"])(Cr)),Fr=ct(Object(b["nullable"])(Object(b["type"])({feeCalculator:Object(b["type"])({lamportsPerSignature:Object(b["number"])()})}))),Vr=at(Object(b["string"])()),Kr=at(Object(b["string"])()),Qr=Object(b["type"])({err:ft,logs:Object(b["array"])(Object(b["string"])()),signature:Object(b["string"])()}),Hr=Object(b["type"])({result:ut(Qr),subscription:Object(b["number"])()}),Zr={"solana-client":"js/0.0.0-development"};class qr{constructor(e,t){let r,n,i,s,o,a;this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const e={};return async t=>{var r;const{commitment:n,config:i}=it(t),s=this._buildArgs([],n,void 0,i),o=ze(s);return e[o]=null!==(r=e[o])&&void 0!==r?r:(async()=>{try{const t=await this._rpcRequest("getBlockHeight",s),r=Object(b["create"])(t,at(Object(b["number"])()));if("error"in r)throw new Ke(r.error,"failed to get block height information");return r.result}finally{delete e[o]}})(),await e[o]}})(),t&&"string"===typeof t?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,r=t.wsEndpoint,n=t.httpHeaders,i=t.fetch,s=t.fetchMiddleware,o=t.disableRetryOnRateLimit,a=t.httpAgent),this._rpcEndpoint=nt(e),this._rpcWsEndpoint=r||Xe(e),this._rpcClient=At(e,n,i,s,o,a),this._rpcRequest=_t(this._rpcClient),this._rpcBatchRequest=Et(this._rpcClient),this._rpcWebSocket=new He(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:r,config:n}=it(t),i=this._buildArgs([e.toBase58()],r,void 0,n),s=await this._rpcRequest("getBalance",i),o=Object(b["create"])(s,ct(Object(b["number"])()));if("error"in o)throw new Ke(o.error,"failed to get balance for "+e.toBase58());return o.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(e=>e.value).catch(t=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+t)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),r=Object(b["create"])(t,at(Object(b["nullable"])(Object(b["number"])())));if("error"in r)throw new Ke(r.error,"failed to get block time for slot "+e);return r.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=Object(b["create"])(e,at(Object(b["number"])()));if("error"in t)throw new Ke(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=Object(b["create"])(e,xt);if("error"in t)throw new Ke(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};t="string"===typeof e?{commitment:e}:e?{...e,commitment:e&&e.commitment||this.commitment}:{commitment:this.commitment};const r=await this._rpcRequest("getSupply",[t]),n=Object(b["create"])(r,Lt);if("error"in n)throw new Ke(n.error,"failed to get supply");return n.result}async getTokenSupply(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenSupply",r),i=Object(b["create"])(n,ct(Pt));if("error"in i)throw new Ke(i.error,"failed to get token supply");return i.result}async getTokenAccountBalance(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenAccountBalance",r),i=Object(b["create"])(n,ct(Pt));if("error"in i)throw new Ke(i.error,"failed to get token account balance");return i.result}async getTokenAccountsByOwner(e,t,r){const{commitment:n,config:i}=it(r);let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,n,"base64",i),a=await this._rpcRequest("getTokenAccountsByOwner",o),c=Object(b["create"])(a,Ut);if("error"in c)throw new Ke(c.error,"failed to get token accounts owned by account "+e.toBase58());return c.result}async getParsedTokenAccountsByOwner(e,t,r){let n=[e.toBase58()];"mint"in t?n.push({mint:t.mint.toBase58()}):n.push({programId:t.programId.toBase58()});const i=this._buildArgs(n,r,"jsonParsed"),s=await this._rpcRequest("getTokenAccountsByOwner",i),o=Object(b["create"])(s,Wt);if("error"in o)throw new Ke(o.error,"failed to get token accounts owned by account "+e.toBase58());return o.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},r=t.filter||t.commitment?[t]:[],n=await this._rpcRequest("getLargestAccounts",r),i=Object(b["create"])(n,Ct);if("error"in i)throw new Ke(i.error,"failed to get largest accounts");return i.result}async getTokenLargestAccounts(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenLargestAccounts",r),i=Object(b["create"])(n,Rt);if("error"in i)throw new Ke(i.error,"failed to get token largest accounts");return i.result}async getAccountInfoAndContext(e,t){const{commitment:r,config:n}=it(t),i=this._buildArgs([e.toBase58()],r,"base64",n),s=await this._rpcRequest("getAccountInfo",i),o=Object(b["create"])(s,ct(Object(b["nullable"])(Dt)));if("error"in o)throw new Ke(o.error,"failed to get info about account "+e.toBase58());return o.result}async getParsedAccountInfo(e,t){const{commitment:r,config:n}=it(t),i=this._buildArgs([e.toBase58()],r,"jsonParsed",n),s=await this._rpcRequest("getAccountInfo",i),o=Object(b["create"])(s,ct(Object(b["nullable"])(Kt)));if("error"in o)throw new Ke(o.error,"failed to get info about account "+e.toBase58());return o.result}async getAccountInfo(e,t){try{const r=await this.getAccountInfoAndContext(e,t);return r.value}catch(r){throw new Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleParsedAccounts(e,t){const{commitment:r,config:n}=it(t),i=e.map(e=>e.toBase58()),s=this._buildArgs([i],r,"jsonParsed",n),o=await this._rpcRequest("getMultipleAccounts",s),a=Object(b["create"])(o,ct(Object(b["array"])(Object(b["nullable"])(Kt))));if("error"in a)throw new Ke(a.error,"failed to get info for accounts "+i);return a.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:r,config:n}=it(t),i=e.map(e=>e.toBase58()),s=this._buildArgs([i],r,"base64",n),o=await this._rpcRequest("getMultipleAccounts",s),a=Object(b["create"])(o,ct(Object(b["array"])(Object(b["nullable"])(Dt))));if("error"in a)throw new Ke(a.error,"failed to get info for accounts "+i);return a.result}async getMultipleAccountsInfo(e,t){const r=await this.getMultipleAccountsInfoAndContext(e,t);return r.value}async getStakeActivation(e,t,r){const{commitment:n,config:i}=it(t),s=this._buildArgs([e.toBase58()],n,void 0,{...i,epoch:null!=r?r:null===i||void 0===i?void 0:i.epoch}),o=await this._rpcRequest("getStakeActivation",s),a=Object(b["create"])(o,at(Ht));if("error"in a)throw new Ke(a.error,"failed to get Stake Activation "+e.toBase58());return a.result}async getProgramAccounts(e,t){const{commitment:r,config:n}=it(t),{encoding:i,...s}=n||{},o=this._buildArgs([e.toBase58()],r,i||"base64",s),a=await this._rpcRequest("getProgramAccounts",o),c=Object(b["array"])(Ft),u=!0===s.withContext?Object(b["create"])(a,ct(c)):Object(b["create"])(a,at(c));if("error"in u)throw new Ke(u.error,"failed to get accounts owned by program "+e.toBase58());return u.result}async getParsedProgramAccounts(e,t){const{commitment:r,config:n}=it(t),i=this._buildArgs([e.toBase58()],r,"jsonParsed",n),s=await this._rpcRequest("getProgramAccounts",i),o=Object(b["create"])(s,at(Object(b["array"])(Qt)));if("error"in o)throw new Ke(o.error,"failed to get accounts owned by program "+e.toBase58());return o.result}async confirmTransaction(e,t){let r,n;if("string"==typeof e)r=e;else{var i;const t=e;if(null!==(i=t.abortSignal)&&void 0!==i&&i.aborted)return Promise.reject(t.abortSignal.reason);r=t.signature}try{n=c.a.decode(r)}catch(s){throw new Error("signature must be base58 encoded: "+r)}return ee(64===n.length,"signature has invalid length"),"string"===typeof e?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:r}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,r)=>{null!=e&&(e.aborted?r(e.reason):e.addEventListener("abort",()=>{r(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let r,n,i=!1;const s=new Promise((s,o)=>{try{r=this.onSignature(t,(e,t)=>{r=void 0;const n={context:t,value:e};s({__type:se.PROCESSED,response:n})},e);const a=new Promise(e=>{null==r?e():n=this._onSubscriptionStateChange(r,t=>{"subscribed"===t&&e()})});(async()=>{if(await a,i)return;const r=await this.getSignatureStatus(t);if(i)return;if(null==r)return;const{context:n,value:c}=r;if(null!=c)if(null!==c&&void 0!==c&&c.err)o(c.err);else{switch(e){case"confirmed":case"single":case"singleGossip":if("processed"===c.confirmationStatus)return;break;case"finalized":case"max":case"root":if("processed"===c.confirmationStatus||"confirmed"===c.confirmationStatus)return;break;case"processed":case"recent":}i=!0,s({__type:se.PROCESSED,response:{context:n,value:c}})}})()}catch(a){o(a)}}),o=()=>{n&&(n(),n=void 0),null!=r&&(this.removeSignatureListener(r),r=void 0)};return{abortConfirmation:o,confirmationPromise:s}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:r,signature:n}}){let i=!1;const s=new Promise(t=>{const n=async()=>{try{const t=await this.getBlockHeight(e);return t}catch(t){return-1}};(async()=>{let e=await n();if(!i){while(e<=r){if(await we(1e3),i)return;if(e=await n(),i)return}t({__type:se.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:o,confirmationPromise:a}=this.getTransactionConfirmationPromise({commitment:e,signature:n}),c=this.getCancellationPromise(t);let u;try{const e=await Promise.race([c,a,s]);if(e.__type!==se.PROCESSED)throw new C(n);u=e.response}finally{i=!0,o()}return u}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:r,nonceAccountPubkey:n,nonceValue:i,signature:s}}){let o=!1;const a=new Promise(t=>{let s=i,a=null;const c=async()=>{try{const{context:t,value:i}=await this.getNonceAndContext(n,{commitment:e,minContextSlot:r});return a=t.slot,null===i||void 0===i?void 0:i.nonce}catch(t){return s}};(async()=>{if(s=await c(),!o)while(1){if(i!==s)return void t({__type:se.NONCE_INVALID,slotInWhichNonceDidAdvance:a});if(await we(2e3),o)return;if(s=await c(),o)return}})()}),{abortConfirmation:c,confirmationPromise:u}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),l=this.getCancellationPromise(t);let d;try{const t=await Promise.race([l,u,a]);if(t.__type===se.PROCESSED)d=t.response;else{var h;let n;while(1){var b;const e=await this.getSignatureStatus(s);if(null==e)break;if(!(e.context.slot<(null!==(b=t.slotInWhichNonceDidAdvance)&&void 0!==b?b:r))){n=e;break}await we(400)}if(null===(h=n)||void 0===h||!h.value)throw new F(s);{const t=e||"finalized",{confirmationStatus:r}=n.value;switch(t){case"processed":case"recent":if("processed"!==r&&"confirmed"!==r&&"finalized"!==r)throw new F(s);break;case"confirmed":case"single":case"singleGossip":if("confirmed"!==r&&"finalized"!==r)throw new F(s);break;case"finalized":case"max":case"root":if("finalized"!==r)throw new F(s);break;default:}d={context:n.context,value:{err:n.value.err}}}}}finally{o=!0,c()}return d}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let r;const n=new Promise(t=>{let n=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":n=this._confirmTransactionInitialTimeout||3e4;break}r=setTimeout(()=>t({__type:se.TIMED_OUT,timeoutMs:n}),n)}),{abortConfirmation:i,confirmationPromise:s}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let o;try{const e=await Promise.race([s,n]);if(e.__type!==se.PROCESSED)throw new D(t,e.timeoutMs/1e3);o=e.response}finally{clearTimeout(r),i()}return o}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=Object(b["create"])(e,at(Object(b["array"])(ir)));if("error"in t)throw new Ke(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getVoteAccounts",t),n=Object(b["create"])(r,or);if("error"in n)throw new Ke(n.error,"failed to get vote accounts");return n.result}async getSlot(e){const{commitment:t,config:r}=it(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getSlot",n),s=Object(b["create"])(i,at(Object(b["number"])()));if("error"in s)throw new Ke(s.error,"failed to get slot");return s.result}async getSlotLeader(e){const{commitment:t,config:r}=it(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getSlotLeader",n),s=Object(b["create"])(i,at(Object(b["string"])()));if("error"in s)throw new Ke(s.error,"failed to get slot leader");return s.result}async getSlotLeaders(e,t){const r=[e,t],n=await this._rpcRequest("getSlotLeaders",r),i=Object(b["create"])(n,at(Object(b["array"])($e)));if("error"in i)throw new Ke(i.error,"failed to get slot leaders");return i.result}async getSignatureStatus(e,t){const{context:r,value:n}=await this.getSignatureStatuses([e],t);ee(1===n.length);const i=n[0];return{context:r,value:i}}async getSignatureStatuses(e,t){const r=[e];t&&r.push(t);const n=await this._rpcRequest("getSignatureStatuses",r),i=Object(b["create"])(n,ur);if("error"in i)throw new Ke(i.error,"failed to get signature status");return i.result}async getTransactionCount(e){const{commitment:t,config:r}=it(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getTransactionCount",n),s=Object(b["create"])(i,at(Object(b["number"])()));if("error"in s)throw new Ke(s.error,"failed to get transaction count");return s.result}async getTotalSupply(e){const t=await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0});return t.value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getInflationGovernor",t),n=Object(b["create"])(r,Ot);if("error"in n)throw new Ke(n.error,"failed to get inflation");return n.result}async getInflationReward(e,t,r){const{commitment:n,config:i}=it(r),s=this._buildArgs([e.map(e=>e.toBase58())],n,void 0,{...i,epoch:null!=t?t:null===i||void 0===i?void 0:i.epoch}),o=await this._rpcRequest("getInflationReward",s),a=Object(b["create"])(o,ht);if("error"in a)throw new Ke(a.error,"failed to get inflation reward");return a.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=Object(b["create"])(e,Tt);if("error"in t)throw new Ke(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:r}=it(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getEpochInfo",n),s=Object(b["create"])(i,Bt);if("error"in s)throw new Ke(s.error,"failed to get epoch info");return s.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=Object(b["create"])(e,Nt);if("error"in t)throw new Ke(t.error,"failed to get epoch schedule");const r=t.result;return new Fe(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=Object(b["create"])(e,Mt);if("error"in t)throw new Ke(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getMinimumBalanceForRentExemption",r),i=Object(b["create"])(n,lr);return"error"in i?0:i.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getRecentBlockhash",t),n=Object(b["create"])(r,Ur);if("error"in n)throw new Ke(n.error,"failed to get recent blockhash");return n.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),r=Object(b["create"])(t,Dr);if("error"in r)throw new Ke(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getFeeCalculatorForBlockhash",r),i=Object(b["create"])(n,Fr);if("error"in i)throw new Ke(i.error,"failed to get fee calculator");const{context:s,value:o}=i.result;return{context:s,value:null!==o?o.feeCalculator:null}}async getFeeForMessage(e,t){const r=O(e.serialize()).toString("base64"),n=this._buildArgs([r],t),i=await this._rpcRequest("getFeeForMessage",n),s=Object(b["create"])(i,ct(Object(b["nullable"])(Object(b["number"])())));if("error"in s)throw new Ke(s.error,"failed to get fee for message");if(null===s.result)throw new Error("invalid blockhash");return s.result}async getRecentPrioritizationFees(e){var t;const r=null===e||void 0===e||null===(t=e.lockedWritableAccounts)||void 0===t?void 0:t.map(e=>e.toBase58()),n=null!==r&&void 0!==r&&r.length?[r]:[],i=await this._rpcRequest("getRecentPrioritizationFees",n),s=Object(b["create"])(i,jt);if("error"in s)throw new Ke(s.error,"failed to get recent prioritization fees");return s.result}async getRecentBlockhash(e){try{const t=await this.getRecentBlockhashAndContext(e);return t.value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{const t=await this.getLatestBlockhashAndContext(e);return t.value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:r}=it(e),n=this._buildArgs([],t,void 0,r),i=await this._rpcRequest("getLatestBlockhash",n),s=Object(b["create"])(i,zr);if("error"in s)throw new Ke(s.error,"failed to get latest blockhash");return s.result}async isBlockhashValid(e,t){const{commitment:r,config:n}=it(t),i=this._buildArgs([e],r,void 0,n),s=await this._rpcRequest("isBlockhashValid",i),o=Object(b["create"])(s,Wr);if("error"in o)throw new Ke(o.error,"failed to determine if the blockhash `"+e+"`is valid");return o.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=Object(b["create"])(e,at(St));if("error"in t)throw new Ke(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=Object(b["create"])(e,at(Object(b["string"])()));if("error"in t)throw new Ke(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:r,config:n}=it(t),i=this._buildArgsAtLeastConfirmed([e],r,void 0,n),s=await this._rpcRequest("getBlock",i);try{switch(null===n||void 0===n?void 0:n.transactionDetails){case"accounts":{const e=Object(b["create"])(s,jr);if("error"in e)throw e.error;return e.result}case"none":{const e=Object(b["create"])(s,Tr);if("error"in e)throw e.error;return e.result}default:{const e=Object(b["create"])(s,Or);if("error"in e)throw e.error;const{result:t}=e;return t?{...t,transactions:t.transactions.map(({transaction:e,meta:t,version:r})=>({meta:t,transaction:{...e,message:lt(r,e.message)},version:r}))}:null}}}catch(o){throw new Ke(o,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:r,config:n}=it(t),i=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),s=await this._rpcRequest("getBlock",i);try{switch(null===n||void 0===n?void 0:n.transactionDetails){case"accounts":{const e=Object(b["create"])(s,Nr);if("error"in e)throw e.error;return e.result}case"none":{const e=Object(b["create"])(s,Mr);if("error"in e)throw e.error;return e.result}default:{const e=Object(b["create"])(s,Br);if("error"in e)throw e.error;return e.result}}}catch(o){throw new Ke(o,"failed to get block")}}async getBlockProduction(e){let t,r;if("string"===typeof e)r=e;else if(e){const{commitment:n,...i}=e;r=n,t=i}const n=this._buildArgs([],r,"base64",t),i=await this._rpcRequest("getBlockProduction",n),s=Object(b["create"])(i,vt);if("error"in s)throw new Ke(s.error,"failed to get block production information");return s.result}async getTransaction(e,t){const{commitment:r,config:n}=it(t),i=this._buildArgsAtLeastConfirmed([e],r,void 0,n),s=await this._rpcRequest("getTransaction",i),o=Object(b["create"])(s,Pr);if("error"in o)throw new Ke(o.error,"failed to get transaction");const a=o.result;return a?{...a,transaction:{...a.transaction,message:lt(a.version,a.transaction.message)}}:a}async getParsedTransaction(e,t){const{commitment:r,config:n}=it(t),i=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),s=await this._rpcRequest("getTransaction",i),o=Object(b["create"])(s,Rr);if("error"in o)throw new Ke(o.error,"failed to get transaction");return o.result}async getParsedTransactions(e,t){const{commitment:r,config:n}=it(t),i=e.map(e=>{const t=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n);return{methodName:"getTransaction",args:t}}),s=await this._rpcBatchRequest(i),o=s.map(e=>{const t=Object(b["create"])(e,Rr);if("error"in t)throw new Ke(t.error,"failed to get transactions");return t.result});return o}async getTransactions(e,t){const{commitment:r,config:n}=it(t),i=e.map(e=>{const t=this._buildArgsAtLeastConfirmed([e],r,void 0,n);return{methodName:"getTransaction",args:t}}),s=await this._rpcBatchRequest(i),o=s.map(e=>{const t=Object(b["create"])(e,Pr);if("error"in t)throw new Ke(t.error,"failed to get transactions");const r=t.result;return r?{...r,transaction:{...r.transaction,message:lt(r.version,r.transaction.message)}}:r});return o}async getConfirmedBlock(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedBlock",r),i=Object(b["create"])(n,xr);if("error"in i)throw new Ke(i.error,"failed to get confirmed block");const s=i.result;if(!s)throw new Error("Confirmed block "+e+" not found");const o={...s,transactions:s.transactions.map(({transaction:e,meta:t})=>{const r=new re(e.message);return{meta:t,transaction:{...e,message:r}}})};return{...o,transactions:o.transactions.map(({transaction:e,meta:t})=>({meta:t,transaction:ce.populate(e.message,e.signatures)}))}}async getBlocks(e,t,r){const n=this._buildArgsAtLeastConfirmed(void 0!==t?[e,t]:[e],r),i=await this._rpcRequest("getBlocks",n),s=Object(b["create"])(i,at(Object(b["array"])(Object(b["number"])())));if("error"in s)throw new Ke(s.error,"failed to get blocks");return s.result}async getBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getBlock",r),i=Object(b["create"])(n,Lr);if("error"in i)throw new Ke(i.error,"failed to get block");const s=i.result;if(!s)throw new Error("Block "+e+" not found");return s}async getConfirmedBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getConfirmedBlock",r),i=Object(b["create"])(n,Lr);if("error"in i)throw new Ke(i.error,"failed to get confirmed block");const s=i.result;if(!s)throw new Error("Confirmed block "+e+" not found");return s}async getConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedTransaction",r),i=Object(b["create"])(n,Pr);if("error"in i)throw new Ke(i.error,"failed to get transaction");const s=i.result;if(!s)return s;const o=new re(s.transaction.message),a=s.transaction.signatures;return{...s,transaction:ce.populate(o,a)}}async getParsedConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),n=await this._rpcRequest("getConfirmedTransaction",r),i=Object(b["create"])(n,Rr);if("error"in i)throw new Ke(i.error,"failed to get confirmed transaction");return i.result}async getParsedConfirmedTransactions(e,t){const r=e.map(e=>{const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed");return{methodName:"getConfirmedTransaction",args:r}}),n=await this._rpcBatchRequest(r),i=n.map(e=>{const t=Object(b["create"])(e,Rr);if("error"in t)throw new Ke(t.error,"failed to get confirmed transactions");return t.result});return i}async getConfirmedSignaturesForAddress(e,t,r){let n={},i=await this.getFirstAvailableBlock();while(!("until"in n)){if(t--,t<=0||t<i)break;try{const e=await this.getConfirmedBlockSignatures(t,"finalized");e.signatures.length>0&&(n.until=e.signatures[e.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}}let s=await this.getSlot("finalized");while(!("before"in n)){if(r++,r>s)break;try{const e=await this.getConfirmedBlockSignatures(r);e.signatures.length>0&&(n.before=e.signatures[e.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}}const o=await this.getConfirmedSignaturesForAddress2(e,n);return o.map(e=>e.signature)}async getConfirmedSignaturesForAddress2(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),i=await this._rpcRequest("getConfirmedSignaturesForAddress2",n),s=Object(b["create"])(i,Zt);if("error"in s)throw new Ke(s.error,"failed to get confirmed signatures for address");return s.result}async getSignaturesForAddress(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),i=await this._rpcRequest("getSignaturesForAddress",n),s=Object(b["create"])(i,qt);if("error"in s)throw new Ke(s.error,"failed to get signatures for address");return s.result}async getAddressLookupTable(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let i=null;return null!==n&&(i=new Ye({key:e,state:Ye.deserialize(n.data)})),{context:r,value:i}}async getNonceAndContext(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let i=null;return null!==n&&(i=_e.fromAccountData(n.data)),{context:r,value:i}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(e=>e.value).catch(t=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+t)})}async requestAirdrop(e,t){const r=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),n=Object(b["create"])(r,Vr);if("error"in n)throw new Ke(n.error,`airdrop to ${e.toBase58()} failed`);return n.result}async _blockhashWithExpiryBlockHeight(e){if(!e){while(this._pollingBlockhash)await we(100);const e=Date.now()-this._blockhashInfo.lastFetch,t=e>=rt;if(null!==this._blockhashInfo.latestBlockhash&&!t)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,r=t?t.blockhash:null;for(let n=0;n<50;n++){const e=await this.getLatestBlockhash("finalized");if(r!==e.blockhash)return this._blockhashInfo={latestBlockhash:e,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},e;await we(pe/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:r}=it(e),n=this._buildArgs([],t,"base64",r),i=await this._rpcRequest("getStakeMinimumDelegation",n),s=Object(b["create"])(i,ct(Object(b["number"])()));if("error"in s)throw new Ke(s.error,"failed to get stake minimum delegation");return s.result}async simulateTransaction(e,t,r){if("message"in e){const i=e,s=i.serialize(),o=n["Buffer"].from(s).toString("base64");if(Array.isArray(t)||void 0!==r)throw new Error("Invalid arguments");const a=t||{};a.encoding="base64","commitment"in a||(a.commitment=this.commitment);const c=[o,a],u=await this._rpcRequest("simulateTransaction",c),l=Object(b["create"])(u,It);if("error"in l)throw new Error("failed to simulate transaction: "+l.error.message);return l.result}let i;if(e instanceof ce){let t=e;i=new ce,i.feePayer=t.feePayer,i.instructions=e.instructions,i.nonceInfo=t.nonceInfo,i.signatures=t.signatures}else i=ce.populate(e),i._message=i._json=void 0;if(void 0!==t&&!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(i.nonceInfo&&s)i.sign(...s);else{let e=this._disableBlockhashCaching;for(;;){const t=await this._blockhashWithExpiryBlockHeight(e);if(i.lastValidBlockHeight=t.lastValidBlockHeight,i.recentBlockhash=t.blockhash,!s)break;if(i.sign(...s),!i.signature)throw new Error("!signature");const r=i.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(r)&&!this._blockhashInfo.transactionSignatures.includes(r)){this._blockhashInfo.simulatedSignatures.push(r);break}e=!0}}const o=i._compile(),a=o.serialize(),c=i._serialize(a),u=c.toString("base64"),l={encoding:"base64",commitment:this.commitment};if(r){const e=(Array.isArray(r)?r:o.nonProgramIds()).map(e=>e.toBase58());l["accounts"]={encoding:"base64",addresses:e}}s&&(l.sigVerify=!0);const d=[u,l],h=await this._rpcRequest("simulateTransaction",d),p=Object(b["create"])(h,It);if("error"in p){let e;if("data"in p.error&&(e=p.error.data.logs,e&&Array.isArray(e))){const t="\n    ";e.join(t)}throw new Ve("failed to simulate transaction: "+p.error.message,e)}return p.result}async sendTransaction(e,t,r){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const r=e.serialize();return await this.sendRawTransaction(r,t)}if(void 0===t||!Array.isArray(t))throw new Error("Invalid arguments");const n=t;if(e.nonceInfo)e.sign(...n);else{let t=this._disableBlockhashCaching;for(;;){const r=await this._blockhashWithExpiryBlockHeight(t);if(e.lastValidBlockHeight=r.lastValidBlockHeight,e.recentBlockhash=r.blockhash,e.sign(...n),!e.signature)throw new Error("!signature");const i=e.signature.toString("base64");if(!this._blockhashInfo.transactionSignatures.includes(i)){this._blockhashInfo.transactionSignatures.push(i);break}t=!0}}const i=e.serialize();return await this.sendRawTransaction(i,r)}async sendRawTransaction(e,t){const r=O(e).toString("base64"),n=await this.sendEncodedTransaction(r,t);return n}async sendEncodedTransaction(e,t){const r={encoding:"base64"},n=t&&t.skipPreflight,i=t&&t.preflightCommitment||this.commitment;t&&null!=t.maxRetries&&(r.maxRetries=t.maxRetries),t&&null!=t.minContextSlot&&(r.minContextSlot=t.minContextSlot),n&&(r.skipPreflight=n),i&&(r.preflightCommitment=i);const s=[e,r],o=await this._rpcRequest("sendTransaction",s),a=Object(b["create"])(o,Kr);if("error"in a){let e;throw"data"in a.error&&(e=a.error.data.logs),new Ve("failed to send transaction: "+a.error.message,e)}return a.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1}_wsOnClose(e){this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),1e3!==e?(this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([e,t])=>{this._setSubscription(e,{...t,state:"pending"})})):this._updateSubscriptions()}_setSubscription(e,t){var r;const n=null===(r=this._subscriptionsByHash[e])||void 0===r?void 0:r.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const r=this._subscriptionStateChangeCallbacksByHash[e];r&&r.forEach(e=>{try{e(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var r;const n=this._subscriptionHashByClientSubscriptionId[e];if(null==n)return()=>{};const i=(r=this._subscriptionStateChangeCallbacksByHash)[n]||(r[n]=new Set);return i.add(t),()=>{i.delete(t),0===i.size&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(0===Object.keys(this._subscriptionsByHash).length)return void(this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(e){Error}},500)));if(null!==this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected)return void this._rpcWebSocket.connect();const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async e=>{const r=this._subscriptionsByHash[e];if(void 0!==r)switch(r.state){case"pending":case"unsubscribed":if(0===r.callbacks.size)return delete this._subscriptionsByHash[e],"unsubscribed"===r.state&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],void await this._updateSubscriptions();await(async()=>{const{args:n,method:i}=r;try{this._setSubscription(e,{...r,state:"subscribing"});const t=await this._rpcWebSocket.call(i,n);this._setSubscription(e,{...r,serverSubscriptionId:t,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[t]=r.callbacks,await this._updateSubscriptions()}catch(s){if(Error,!t())return;this._setSubscription(e,{...r,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":0===r.callbacks.size&&await(async()=>{const{serverSubscriptionId:n,unsubscribeMethod:i}=r;if(this._subscriptionsAutoDisposedByRpc.has(n))this._subscriptionsAutoDisposedByRpc.delete(n);else{this._setSubscription(e,{...r,state:"unsubscribing"}),this._setSubscription(e,{...r,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[n])}catch(s){if(Error,!t())return;return this._setSubscription(e,{...r,state:"subscribed"}),void await this._updateSubscriptions()}}this._setSubscription(e,{...r,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const r=this._subscriptionCallbacksByServerSubscriptionId[e];void 0!==r&&r.forEach(e=>{try{e(...t)}catch(r){}})}_wsOnAccountNotification(e){const{result:t,subscription:r}=Object(b["create"])(e,Yt);this._handleServerNotification(r,[t.value,t.context])}_makeSubscription(e,t){const r=this._nextClientSubscriptionId++,n=ze([e.method,t],!0),i=this._subscriptionsByHash[n];return void 0===i?this._subscriptionsByHash[n]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:i.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[r]=n,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const t=this._subscriptionsByHash[n];ee(void 0!==t,"Could not find a `Subscription` when tearing down client subscription #"+r),t.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(e,t,r){const n=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},n)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:r}=Object(b["create"])(e,Jt);this._handleServerNotification(r,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,r,n){const i=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",n?{filters:n}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},i)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,r){const n=this._buildArgs(["object"===typeof e?{mentions:[e.toString()]}:e],r||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},n)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:r}=Object(b["create"])(e,Hr);this._handleServerNotification(r,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:r}=Object(b["create"])(e,$t);this._handleServerNotification(r,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:r}=Object(b["create"])(e,tr);this._handleServerNotification(r,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];r&&await r()}_buildArgs(e,t,r,n){const i=t||this._commitment;if(i||r||n){let t={};r&&(t.encoding=r),i&&(t.commitment=i),n&&(t=Object.assign(t,n)),e.push(t)}return e}_buildArgsAtLeastConfirmed(e,t,r,n){const i=t||this._commitment;if(i&&!["confirmed","finalized"].includes(i))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,r,n)}_wsOnSignatureNotification(e){const{result:t,subscription:r}=Object(b["create"])(e,rr);"receivedSignature"!==t.value&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,"receivedSignature"===t.value?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,r){const n=this._buildArgs([e],r||this._commitment||"finalized"),i=this._makeSubscription({callback:(e,r)=>{if("status"===e.type){t(e.result,r);try{this.removeSignatureListener(i)}catch(n){}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},n);return i}onSignatureWithOptions(e,t,r){const{commitment:n,...i}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},s=this._buildArgs([e],n,void 0,i),o=this._makeSubscription({callback:(e,r)=>{t(e,r);try{this.removeSignatureListener(o)}catch(n){}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:r}=Object(b["create"])(e,nr);this._handleServerNotification(r,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Yr{constructor(e){this._keypair=void 0,this._keypair=null!==e&&void 0!==e?e:I()}static generate(){return new Yr(I())}static fromSecretKey(e,t){if(64!==e.byteLength)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const t=e.slice(0,32),n=v(t);for(let e=0;e<32;e++)if(r[e]!==n[e])throw new Error("provided secretKey is invalid")}return new Yr({publicKey:r,secretKey:e})}static fromSeed(e){const t=v(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new Yr({publicKey:t,secretKey:r})}get publicKey(){return new R(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const Gr=Object.freeze({CreateLookupTable:{index:0,layout:d["struct"]([d["u32"]("instruction"),Te("recentSlot"),d["u8"]("bumpSeed")])},FreezeLookupTable:{index:1,layout:d["struct"]([d["u32"]("instruction")])},ExtendLookupTable:{index:2,layout:d["struct"]([d["u32"]("instruction"),Te(),d["seq"](K(),d["offset"](d["u32"](),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:d["struct"]([d["u32"]("instruction")])},CloseLookupTable:{index:4,layout:d["struct"]([d["u32"]("instruction")])}});class Jr{constructor(){}static createLookupTable(e){const[t,r]=R.findProgramAddressSync([e.authority.toBuffer(),Object(h["toBufferLE"])(BigInt(e.recentSlot),8)],this.programId),n=Gr.CreateLookupTable,i=Se(n,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),s=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Be.programId,isSigner:!1,isWritable:!1}];return[new ae({programId:this.programId,keys:s,data:i}),t]}static freezeLookupTable(e){const t=Gr.FreezeLookupTable,r=Se(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new ae({programId:this.programId,keys:n,data:r})}static extendLookupTable(e){const t=Gr.ExtendLookupTable,r=Se(t,{addresses:e.addresses.map(e=>e.toBytes())}),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&n.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Be.programId,isSigner:!1,isWritable:!1}),new ae({programId:this.programId,keys:n,data:r})}static deactivateLookupTable(e){const t=Gr.DeactivateLookupTable,r=Se(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new ae({programId:this.programId,keys:n,data:r})}static closeLookupTable(e){const t=Gr.CloseLookupTable,r=Se(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new ae({programId:this.programId,keys:n,data:r})}}Jr.programId=new R("AddressLookupTab1e1111111111111111111111111");const Xr=Object.freeze({RequestUnits:{index:0,layout:d["struct"]([d["u8"]("instruction"),d["u32"]("units"),d["u32"]("additionalFee")])},RequestHeapFrame:{index:1,layout:d["struct"]([d["u8"]("instruction"),d["u32"]("bytes")])},SetComputeUnitLimit:{index:2,layout:d["struct"]([d["u8"]("instruction"),d["u32"]("units")])},SetComputeUnitPrice:{index:3,layout:d["struct"]([d["u8"]("instruction"),Te("microLamports")])}});class $r{constructor(){}static requestUnits(e){const t=Xr.RequestUnits,r=Se(t,e);return new ae({keys:[],programId:this.programId,data:r})}static requestHeapFrame(e){const t=Xr.RequestHeapFrame,r=Se(t,e);return new ae({keys:[],programId:this.programId,data:r})}static setComputeUnitLimit(e){const t=Xr.SetComputeUnitLimit,r=Se(t,e);return new ae({keys:[],programId:this.programId,data:r})}static setComputeUnitPrice(e){const t=Xr.SetComputeUnitPrice,r=Se(t,{microLamports:BigInt(e.microLamports)});return new ae({keys:[],programId:this.programId,data:r})}}$r.programId=new R("ComputeBudget111111111111111111111111111111");const en=64,tn=32,rn=64,nn=d["struct"]([d["u8"]("numSignatures"),d["u8"]("padding"),d["u16"]("signatureOffset"),d["u16"]("signatureInstructionIndex"),d["u16"]("publicKeyOffset"),d["u16"]("publicKeyInstructionIndex"),d["u16"]("messageDataOffset"),d["u16"]("messageDataSize"),d["u16"]("messageInstructionIndex")]);class sn{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:i,instructionIndex:s}=e;ee(t.length===tn,`Public Key must be ${tn} bytes but received ${t.length} bytes`),ee(i.length===rn,`Signature must be ${rn} bytes but received ${i.length} bytes`);const o=nn.span,a=o+t.length,c=a+i.length,u=1,l=n["Buffer"].alloc(c+r.length),d=null==s?65535:s;return nn.encode({numSignatures:u,padding:0,signatureOffset:a,signatureInstructionIndex:d,publicKeyOffset:o,publicKeyInstructionIndex:d,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:d},l),l.fill(t,o),l.fill(i,a),l.fill(r,c),new ae({keys:[],programId:sn.programId,data:l})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;ee(t.length===en,`Private key must be ${en} bytes but received ${t.length} bytes`);try{const e=Yr.fromSecretKey(t),i=e.publicKey.toBytes(),s=_(r,e.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:s,instructionIndex:n})}catch(i){throw new Error("Error creating instruction; "+i)}}}sn.programId=new R("Ed25519SigVerify111111111111111111111111111");const on=(e,t)=>{const r=S["secp256k1"].sign(e,t);return[r.toCompactRawBytes(),r.recovery]};S["secp256k1"].utils.isValidPrivateKey;const an=S["secp256k1"].getPublicKey,cn=32,un=20,ln=64,dn=11,hn=d["struct"]([d["u8"]("numSignatures"),d["u16"]("signatureOffset"),d["u8"]("signatureInstructionIndex"),d["u16"]("ethAddressOffset"),d["u8"]("ethAddressInstructionIndex"),d["u16"]("messageDataOffset"),d["u16"]("messageDataSize"),d["u8"]("messageInstructionIndex"),d["blob"](20,"ethAddress"),d["blob"](64,"signature"),d["u8"]("recoveryId")]);class bn{constructor(){}static publicKeyToEthAddress(e){ee(e.length===ln,`Public key must be ${ln} bytes but received ${e.length} bytes`);try{return n["Buffer"].from(Object(w["keccak_256"])(O(e))).slice(-un)}catch(t){throw new Error("Error constructing Ethereum address: "+t)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,recoveryId:i,instructionIndex:s}=e;return bn.createInstructionWithEthAddress({ethAddress:bn.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:i,instructionIndex:s})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:i,recoveryId:s,instructionIndex:o=0}=e;let a;a="string"===typeof t?t.startsWith("0x")?n["Buffer"].from(t.substr(2),"hex"):n["Buffer"].from(t,"hex"):t,ee(a.length===un,`Address must be ${un} bytes but received ${a.length} bytes`);const c=1+dn,u=c,l=c+a.length,d=l+i.length+1,h=1,b=n["Buffer"].alloc(hn.span+r.length);return hn.encode({numSignatures:h,signatureOffset:l,signatureInstructionIndex:o,ethAddressOffset:u,ethAddressInstructionIndex:o,messageDataOffset:d,messageDataSize:r.length,messageInstructionIndex:o,signature:O(i),ethAddress:O(a),recoveryId:s},b),b.fill(O(r),hn.span),new ae({keys:[],programId:bn.programId,data:b})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:i}=e;ee(t.length===cn,`Private key must be ${cn} bytes but received ${t.length} bytes`);try{const e=O(t),s=an(e,!1).slice(1),o=n["Buffer"].from(Object(w["keccak_256"])(O(r))),[a,c]=on(o,e);return this.createInstructionWithPublicKey({publicKey:s,message:r,signature:a,recoveryId:c,instructionIndex:i})}catch(s){throw new Error("Error creating instruction; "+s)}}}var pn;bn.programId=new R("KeccakSecp256k11111111111111111111111111111");const gn=new R("StakeConfig11111111111111111111111111111111");class yn{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}pn=yn,yn.default=new pn(0,0,R.default);const mn=Object.freeze({Initialize:{index:0,layout:d["struct"]([d["u32"]("instruction"),Z(),q()])},Authorize:{index:1,layout:d["struct"]([d["u32"]("instruction"),K("newAuthorized"),d["u32"]("stakeAuthorizationType")])},Delegate:{index:2,layout:d["struct"]([d["u32"]("instruction")])},Split:{index:3,layout:d["struct"]([d["u32"]("instruction"),d["ns64"]("lamports")])},Withdraw:{index:4,layout:d["struct"]([d["u32"]("instruction"),d["ns64"]("lamports")])},Deactivate:{index:5,layout:d["struct"]([d["u32"]("instruction")])},Merge:{index:7,layout:d["struct"]([d["u32"]("instruction")])},AuthorizeWithSeed:{index:8,layout:d["struct"]([d["u32"]("instruction"),K("newAuthorized"),d["u32"]("stakeAuthorizationType"),H("authoritySeed"),K("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class fn{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:n}=e,i=n||yn.default,s=mn.Initialize,o=Se(s,{authorized:{staker:O(r.staker.toBuffer()),withdrawer:O(r.withdrawer.toBuffer())},lockup:{unixTimestamp:i.unixTimestamp,epoch:i.epoch,custodian:O(i.custodian.toBuffer())}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:me,isSigner:!1,isWritable:!1}],programId:this.programId,data:o};return new ae(a)}static createAccountWithSeed(e){const t=new ce;t.add(Be.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:i}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:i}))}static createAccount(e){const t=new ce;t.add(Be.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:i}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:i}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,i=mn.Delegate,s=Se(i);return(new ce).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:ge,isSigner:!1,isWritable:!1},{pubkey:fe,isSigner:!1,isWritable:!1},{pubkey:gn,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:i,custodianPubkey:s}=e,o=mn.Authorize,a=Se(o,{newAuthorized:O(n.toBuffer()),stakeAuthorizationType:i.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:ge,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return s&&c.push({pubkey:s,isSigner:!0,isWritable:!1}),(new ce).add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:i,newAuthorizedPubkey:s,stakeAuthorizationType:o,custodianPubkey:a}=e,c=mn.AuthorizeWithSeed,u=Se(c,{newAuthorized:O(s.toBuffer()),stakeAuthorizationType:o.index,authoritySeed:n,authorityOwner:O(i.toBuffer())}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:ge,isSigner:!1,isWritable:!1}];return a&&l.push({pubkey:a,isSigner:!0,isWritable:!1}),(new ce).add({keys:l,programId:this.programId,data:u})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:i}=e,s=mn.Split,o=Se(s,{lamports:i});return new ae({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static split(e,t){const r=new ce;return r.add(Be.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),r.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:i,basePubkey:s,seed:o,lamports:a}=e,c=new ce;return c.add(Be.allocate({accountPubkey:i,basePubkey:s,seed:o,space:this.space,programId:this.programId})),t&&t>0&&c.add(Be.transfer({fromPubkey:e.authorizedPubkey,toPubkey:i,lamports:t})),c.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:n,splitStakePubkey:i,lamports:a}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,i=mn.Merge,s=Se(i);return(new ce).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:ge,isSigner:!1,isWritable:!1},{pubkey:fe,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:i,custodianPubkey:s}=e,o=mn.Withdraw,a=Se(o,{lamports:i}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:ge,isSigner:!1,isWritable:!1},{pubkey:fe,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return s&&c.push({pubkey:s,isSigner:!0,isWritable:!1}),(new ce).add({keys:c,programId:this.programId,data:a})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,n=mn.Deactivate,i=Se(n);return(new ce).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:ge,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}}fn.programId=new R("Stake11111111111111111111111111111111111111"),fn.space=200;const kn=Object.freeze({InitializeAccount:{index:0,layout:d["struct"]([d["u32"]("instruction"),Y()])},Authorize:{index:1,layout:d["struct"]([d["u32"]("instruction"),K("newAuthorized"),d["u32"]("voteAuthorizationType")])},Withdraw:{index:3,layout:d["struct"]([d["u32"]("instruction"),d["ns64"]("lamports")])},UpdateValidatorIdentity:{index:4,layout:d["struct"]([d["u32"]("instruction")])},AuthorizeWithSeed:{index:10,layout:d["struct"]([d["u32"]("instruction"),G()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class wn{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:n}=e,i=kn.InitializeAccount,s=Se(i,{voteInit:{nodePubkey:O(n.nodePubkey.toBuffer()),authorizedVoter:O(n.authorizedVoter.toBuffer()),authorizedWithdrawer:O(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),o={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:ge,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s};return new ae(o)}static createAccount(e){const t=new ce;return t.add(Be.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:i}=e,s=kn.Authorize,o=Se(s,{newAuthorized:O(n.toBuffer()),voteAuthorizationType:i.index}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:ge,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ce).add({keys:a,programId:this.programId,data:o})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:i,voteAuthorizationType:s,votePubkey:o}=e,a=kn.AuthorizeWithSeed,c=Se(a,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:O(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:O(i.toBuffer()),voteAuthorizationType:s.index}}),u=[{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:ge,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return(new ce).add({keys:u,programId:this.programId,data:c})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:i}=e,s=kn.Withdraw,o=Se(s,{lamports:n}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ce).add({keys:a,programId:this.programId,data:o})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return wn.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,nodePubkey:n}=e,i=kn.UpdateValidatorIdentity,s=Se(i),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ce).add({keys:o,programId:this.programId,data:s})}}wn.programId=new R("Vote111111111111111111111111111111111111111"),wn.space=3762;new R("Va1idator1nfo111111111111111111111111111111"),Object(b["type"])({name:Object(b["string"])(),website:Object(b["optional"])(Object(b["string"])()),details:Object(b["optional"])(Object(b["string"])()),keybaseUsername:Object(b["optional"])(Object(b["string"])())});new R("Vote111111111111111111111111111111111111111"),d["struct"]([K("nodePubkey"),K("authorizedWithdrawer"),d["u8"]("commission"),d["nu64"](),d["seq"](d["struct"]([d["nu64"]("slot"),d["u32"]("confirmationCount")]),d["offset"](d["u32"](),-8),"votes"),d["u8"]("rootSlotValid"),d["nu64"]("rootSlot"),d["nu64"](),d["seq"](d["struct"]([d["nu64"]("epoch"),K("authorizedVoter")]),d["offset"](d["u32"](),-8),"authorizedVoters"),d["struct"]([d["seq"](d["struct"]([K("authorizedPubkey"),d["nu64"]("epochOfLastAuthorizedSwitch"),d["nu64"]("targetEpoch")]),32,"buf"),d["nu64"]("idx"),d["u8"]("isEmpty")],"priorVoters"),d["nu64"](),d["seq"](d["struct"]([d["nu64"]("epoch"),d["nu64"]("credits"),d["nu64"]("prevCredits")]),d["offset"](d["u32"](),-8),"epochCredits"),d["struct"]([d["nu64"]("slot"),d["nu64"]("timestamp")],"lastTimestamp")])},"6d7f":function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WalletAdapterNetwork=void 0,function(e){e["Mainnet"]="mainnet-beta",e["Testnet"]="testnet",e["Devnet"]="devnet"}(t.WalletAdapterNetwork||(t.WalletAdapterNetwork={}))},"6f02":function(e,t,r){"use strict";function n(e){return"version"in e}r.d(t,"a",(function(){return n}))},"74a3":function(e,t,r){"use strict";r.r(t),r.d(t,"SolanaSignAndSendTransaction",(function(){return n["a"]})),r.d(t,"SolanaSignIn",(function(){return i})),r.d(t,"SolanaSignMessage",(function(){return s["a"]})),r.d(t,"SolanaSignTransaction",(function(){return o["a"]}));var n=r("7695");const i="solana:signIn";var s=r("e729"),o=r("1b1b")},"753b":function(e,t,r){"use strict";r.d(t,"a",(function(){return i})),r.d(t,"b",(function(){return s})),r.d(t,"c",(function(){return o})),r.d(t,"d",(function(){return a})),r.d(t,"i",(function(){return c})),r.d(t,"j",(function(){return u})),r.d(t,"g",(function(){return l})),r.d(t,"f",(function(){return d})),r.d(t,"e",(function(){return h})),r.d(t,"h",(function(){return b})),r.d(t,"l",(function(){return p})),r.d(t,"m",(function(){return g})),r.d(t,"k",(function(){return y}));r("d9e2");class n extends Error{constructor(e){super(e)}}class i extends n{constructor(){super(...arguments),this.name="TokenAccountNotFoundError"}}class s extends n{constructor(){super(...arguments),this.name="TokenInvalidAccountError"}}class o extends n{constructor(){super(...arguments),this.name="TokenInvalidAccountOwnerError"}}class a extends n{constructor(){super(...arguments),this.name="TokenInvalidAccountSizeError"}}class c extends n{constructor(){super(...arguments),this.name="TokenInvalidMintError"}}class u extends n{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}class l extends n{constructor(){super(...arguments),this.name="TokenInvalidInstructionProgramError"}}class d extends n{constructor(){super(...arguments),this.name="TokenInvalidInstructionKeysError"}}class h extends n{constructor(){super(...arguments),this.name="TokenInvalidInstructionDataError"}}class b extends n{constructor(){super(...arguments),this.name="TokenInvalidInstructionTypeError"}}class p extends n{constructor(){super(...arguments),this.name="TokenTransferHookAccountNotFound"}}class g extends n{constructor(){super(...arguments),this.name="TokenTransferHookInvalidSeed"}}class y extends n{constructor(){super(...arguments),this.name="TokenTransferHookAccountDataNotFound"}}},7635:function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r("3583"),i=r("5621"),s=r("ff6a"),o=r("290c"),a=r("47c4");t.KEY_LENGTH=32,t.NONCE_LENGTH=12,t.TAG_LENGTH=16;var c=new Uint8Array(16),u=function(){function e(e){if(this.nonceLength=t.NONCE_LENGTH,this.tagLength=t.TAG_LENGTH,e.length!==t.KEY_LENGTH)throw new Error("ChaCha20Poly1305 needs 32-byte key");this._key=new Uint8Array(e)}return e.prototype.seal=function(e,t,r,i){if(e.length>16)throw new Error("ChaCha20Poly1305: incorrect nonce length");var o=new Uint8Array(16);o.set(e,o.length-e.length);var a=new Uint8Array(32);n.stream(this._key,o,a,4);var c,u=t.length+this.tagLength;if(i){if(i.length!==u)throw new Error("ChaCha20Poly1305: incorrect destination length");c=i}else c=new Uint8Array(u);return n.streamXOR(this._key,o,t,c,4),this._authenticate(c.subarray(c.length-this.tagLength,c.length),a,c.subarray(0,c.length-this.tagLength),r),s.wipe(o),c},e.prototype.open=function(e,t,r,i){if(e.length>16)throw new Error("ChaCha20Poly1305: incorrect nonce length");if(t.length<this.tagLength)return null;var o=new Uint8Array(16);o.set(e,o.length-e.length);var c=new Uint8Array(32);n.stream(this._key,o,c,4);var u=new Uint8Array(this.tagLength);if(this._authenticate(u,c,t.subarray(0,t.length-this.tagLength),r),!a.equal(u,t.subarray(t.length-this.tagLength,t.length)))return null;var l,d=t.length-this.tagLength;if(i){if(i.length!==d)throw new Error("ChaCha20Poly1305: incorrect destination length");l=i}else l=new Uint8Array(d);return n.streamXOR(this._key,o,t.subarray(0,t.length-this.tagLength),l,4),s.wipe(o),l},e.prototype.clean=function(){return s.wipe(this._key),this},e.prototype._authenticate=function(e,t,r,n){var a=new i.Poly1305(t);n&&(a.update(n),n.length%16>0&&a.update(c.subarray(n.length%16))),a.update(r),r.length%16>0&&a.update(c.subarray(r.length%16));var u=new Uint8Array(8);n&&o.writeUint64LE(n.length,u),a.update(u),o.writeUint64LE(r.length,u),a.update(u);for(var l=a.digest(),d=0;d<l.length;d++)e[d]=l[d];a.clean(),s.wipe(l),s.wipe(u)},e}();t.ChaCha20Poly1305=u},7695:function(e,t,r){"use strict";r.d(t,"a",(function(){return n}));const n="solana:signAndSendTransaction"},"7b05":function(e,t,r){"use strict";(function(e){r.d(t,"a",(function(){return m}));r("14d9"),r("907a"),r("986a"),r("1d02"),r("3c5d"),r("6ce5"),r("2834"),r("4ea1"),r("669d"),r("109c"),r("b2c1");var n=r("753b");const i=1,s=1,o=1,a=1,c=1,u=1,l=1,d=1;function h(t){if(t.length<1)throw new n["m"];const[r,...o]=t;if(o.length<r)throw new n["m"];return{data:e.from(o.slice(0,r)),packedLength:i+s+r}}function b(e,t){if(e.length<2)throw new n["m"];const[r,s]=e;if(t.length<s+r)throw new n["m"];return{data:t.subarray(r,r+s),packedLength:i+o+a}}function p(e,t){if(e.length<1)throw new n["m"];const[r]=e;if(t.length<=r)throw new n["m"];return{data:t[r].pubkey.toBuffer(),packedLength:i+c}}async function g(e,t,r){if(e.length<3)throw new n["m"];const[s,o,a]=e;if(t.length<=s)throw new n["m"];const c=await r.getAccountInfo(t[s].pubkey);if(null==c)throw new n["k"];if(c.data.length<o+a)throw new n["m"];return{data:c.data.subarray(o,o+a),packedLength:i+u+l+d}}async function y(e,t,r,i){const[s,...o]=e,a=new Uint8Array(o);switch(s){case 0:return null;case 1:return h(a);case 2:return b(a,r);case 3:return p(a,t);case 4:return g(a,t,i);default:throw new n["m"]}}async function m(e,t,r,n){const i=[];let s=0;while(s<32){const o=await y(e.slice(s),t,r,n);if(null==o)break;i.push(o.data),s+=o.packedLength}return i}}).call(this,r("1c35").Buffer)},"7dcf":function(e,t,r){"use strict";function n(e){return"undefined"!==typeof e.saveState&&"undefined"!==typeof e.restoreState&&"undefined"!==typeof e.cleanSavedState}Object.defineProperty(t,"__esModule",{value:!0}),t.isSerializableHash=n},"7ee5":function(e,t,r){"use strict";r.d(t,"a",(function(){return a}));r("14d9");var n=r("b675"),i=r("52c3"),s=r("6f02");class o extends n["a"]{async sendTransaction(e,t,r={}){let n=!0;try{if(Object(s["a"])(e)){if(!this.supportedTransactionVersions)throw new i["k"]("Sending versioned transactions isn't supported by this wallet");if(!this.supportedTransactionVersions.has(e.version))throw new i["k"](`Sending transaction version ${e.version} isn't supported by this wallet`);try{e=await this.signTransaction(e);const n=e.serialize();return await t.sendRawTransaction(n,r)}catch(o){if(o instanceof i["m"])throw n=!1,o;throw new i["k"](null===o||void 0===o?void 0:o.message,o)}}else try{const{signers:n,...i}=r;e=await this.prepareTransaction(e,t,i),(null===n||void 0===n?void 0:n.length)&&e.partialSign(...n),e=await this.signTransaction(e);const s=e.serialize();return await t.sendRawTransaction(s,i)}catch(o){if(o instanceof i["m"])throw n=!1,o;throw new i["k"](null===o||void 0===o?void 0:o.message,o)}}catch(o){throw n&&this.emit("error",o),o}}async signAllTransactions(e){for(const r of e)if(Object(s["a"])(r)){if(!this.supportedTransactionVersions)throw new i["m"]("Signing versioned transactions isn't supported by this wallet");if(!this.supportedTransactionVersions.has(r.version))throw new i["m"](`Signing transaction version ${r.version} isn't supported by this wallet`)}const t=[];for(const r of e)t.push(await this.signTransaction(r));return t}}class a extends o{}},"7f6a":function(e,t,r){"use strict";r.d(t,"a",(function(){return z})),r.d(t,"d",(function(){return H})),r.d(t,"b",(function(){return Z})),r.d(t,"c",(function(){return q}));r("d9e2"),r("14d9"),r("13d5"),r("0643"),r("2382"),r("a573"),r("9d4a");var n=r("0f06"),i=r("b9be"),s=r("f7f2"),o=r("d99e"),a=r("8df2"),c=r("633a");const u=Object(a["struct"])([Object(c["a"])("lockCpi")]),l=u.span;const d=Object(a["struct"])([Object(a["u8"])("state")]),h=d.span;r("64b9");const b=Object(a["struct"])([Object(c["b"])("authority"),Object(c["b"])("memberAddress")]),p=b.span;const g=Object(a["struct"])([Object(c["b"])("authority"),Object(c["b"])("groupAddress")]),y=g.span;const m=Object(a["struct"])([]),f=m.span;const k=Object(a["struct"])([Object(c["b"])("rateAuthority"),Object(a["ns64"])("initializationTimestamp"),Object(a["s16"])("preUpdateAverageRate"),Object(a["ns64"])("lastUpdateTimestamp"),Object(a["s16"])("currentRate")]),w=k.span;const S=Object(a["struct"])([Object(c["a"])("requireIncomingTransferMemos")]),I=S.span;const v=Object(a["struct"])([Object(c["b"])("authority"),Object(c["b"])("metadataAddress")]),A=v.span;const _=Object(a["struct"])([Object(c["b"])("closeAuthority")]),E=_.span;const O=Object(a["struct"])([]),T=O.span,j=O.span;const B=Object(a["struct"])([Object(c["b"])("delegate")]),N=B.span;const M=1e4;BigInt(M);function x(e){return Object(a["struct"])([Object(c["c"])("epoch"),Object(c["c"])("maximumFee"),Object(a["u16"])("transferFeeBasisPoints")],e)}const L=Object(a["struct"])([Object(c["b"])("transferFeeConfigAuthority"),Object(c["b"])("withdrawWithheldAuthority"),Object(c["c"])("withheldAmount"),x("olderTransferFee"),x("newerTransferFee")]),P=L.span;const R=Object(a["struct"])([Object(c["c"])("withheldAmount")]),U=R.span;var z,W=r("17fd");r("d6e3");(function(e){e[e["Uninitialized"]=0]="Uninitialized",e[e["TransferFeeConfig"]=1]="TransferFeeConfig",e[e["TransferFeeAmount"]=2]="TransferFeeAmount",e[e["MintCloseAuthority"]=3]="MintCloseAuthority",e[e["ConfidentialTransferMint"]=4]="ConfidentialTransferMint",e[e["ConfidentialTransferAccount"]=5]="ConfidentialTransferAccount",e[e["DefaultAccountState"]=6]="DefaultAccountState",e[e["ImmutableOwner"]=7]="ImmutableOwner",e[e["MemoTransfer"]=8]="MemoTransfer",e[e["NonTransferable"]=9]="NonTransferable",e[e["InterestBearingConfig"]=10]="InterestBearingConfig",e[e["CpiGuard"]=11]="CpiGuard",e[e["PermanentDelegate"]=12]="PermanentDelegate",e[e["NonTransferableAccount"]=13]="NonTransferableAccount",e[e["TransferHook"]=14]="TransferHook",e[e["TransferHookAccount"]=15]="TransferHookAccount",e[e["MetadataPointer"]=18]="MetadataPointer",e[e["TokenMetadata"]=19]="TokenMetadata",e[e["GroupPointer"]=20]="GroupPointer",e[e["GroupMemberPointer"]=22]="GroupMemberPointer"})(z||(z={}));const C=2,D=2;function F(e){return e+C+D}function V(e){switch(e){case z.TokenMetadata:return!0;default:return!1}}function K(e){switch(e){case z.Uninitialized:return 0;case z.TransferFeeConfig:return P;case z.TransferFeeAmount:return U;case z.MintCloseAuthority:return E;case z.ConfidentialTransferMint:return 97;case z.ConfidentialTransferAccount:return 286;case z.CpiGuard:return l;case z.DefaultAccountState:return h;case z.ImmutableOwner:return f;case z.MemoTransfer:return I;case z.MetadataPointer:return A;case z.NonTransferable:return T;case z.InterestBearingConfig:return w;case z.PermanentDelegate:return N;case z.NonTransferableAccount:return j;case z.TransferHook:return W["b"];case z.TransferHookAccount:return W["a"];case z.GroupPointer:return y;case z.GroupMemberPointer:return p;case z.TokenMetadata:throw Error("Cannot get type length for variable extension type: "+e);default:throw Error("Unknown extension type: "+e)}}function Q(e,t,r={}){if(0===e.length&&0===Object.keys(r).length)return t;{const t=n["a"]+o["a"]+e.filter((t,r)=>r===e.indexOf(t)).map(e=>F(K(e))).reduce((e,t)=>e+t,0)+Object.entries(r).map(([e,t])=>{if(!V(Number(e)))throw Error(`Extension ${e} is not variable length`);return F(t)}).reduce((e,t)=>e+t,0);return t===s["a"]?t+C:t}}function H(e,t={}){return Q(e,i["a"],t)}function Z(e){return Q(e,n["a"])}function q(e,t){let r=0;while(F(r)<=t.length){const n=t.readUInt16LE(r),i=t.readUInt16LE(r+C),s=F(r);if(n==e)return t.slice(s,s+i);r=s+i}return null}},8217:function(e,t,r){"use strict";r("d9e2"),Object.defineProperty(t,"__esModule",{value:!0}),t.WalletWindowClosedError=t.WalletWindowBlockedError=t.WalletTimeoutError=t.WalletSignInError=t.WalletSignMessageError=t.WalletSignTransactionError=t.WalletSendTransactionError=t.WalletNotConnectedError=t.WalletKeypairError=t.WalletPublicKeyError=t.WalletAccountError=t.WalletDisconnectionError=t.WalletDisconnectedError=t.WalletConnectionError=t.WalletConfigError=t.WalletLoadError=t.WalletNotReadyError=t.WalletError=void 0;class n extends Error{constructor(e,t){super(e),this.error=t}}t.WalletError=n;class i extends n{constructor(){super(...arguments),this.name="WalletNotReadyError"}}t.WalletNotReadyError=i;class s extends n{constructor(){super(...arguments),this.name="WalletLoadError"}}t.WalletLoadError=s;class o extends n{constructor(){super(...arguments),this.name="WalletConfigError"}}t.WalletConfigError=o;class a extends n{constructor(){super(...arguments),this.name="WalletConnectionError"}}t.WalletConnectionError=a;class c extends n{constructor(){super(...arguments),this.name="WalletDisconnectedError"}}t.WalletDisconnectedError=c;class u extends n{constructor(){super(...arguments),this.name="WalletDisconnectionError"}}t.WalletDisconnectionError=u;class l extends n{constructor(){super(...arguments),this.name="WalletAccountError"}}t.WalletAccountError=l;class d extends n{constructor(){super(...arguments),this.name="WalletPublicKeyError"}}t.WalletPublicKeyError=d;class h extends n{constructor(){super(...arguments),this.name="WalletKeypairError"}}t.WalletKeypairError=h;class b extends n{constructor(){super(...arguments),this.name="WalletNotConnectedError"}}t.WalletNotConnectedError=b;class p extends n{constructor(){super(...arguments),this.name="WalletSendTransactionError"}}t.WalletSendTransactionError=p;class g extends n{constructor(){super(...arguments),this.name="WalletSignTransactionError"}}t.WalletSignTransactionError=g;class y extends n{constructor(){super(...arguments),this.name="WalletSignMessageError"}}t.WalletSignMessageError=y;class m extends n{constructor(){super(...arguments),this.name="WalletSignInError"}}t.WalletSignInError=m;class f extends n{constructor(){super(...arguments),this.name="WalletTimeoutError"}}t.WalletTimeoutError=f;class k extends n{constructor(){super(...arguments),this.name="WalletWindowBlockedError"}}t.WalletWindowBlockedError=k;class w extends n{constructor(){super(...arguments),this.name="WalletWindowClosedError"}}t.WalletWindowClosedError=w},"834f":function(e,t,r){"use strict";r("14d9");var n=this&&this.__awaiter||function(e,t,r,n){function i(e){return e instanceof r?e:new r((function(t){t(e)}))}return new(r||(r=Promise))((function(r,s){function o(e){try{c(n.next(e))}catch(t){s(t)}}function a(e){try{c(n["throw"](e))}catch(t){s(t)}}function c(e){e.done?r(e.value):i(e.value).then(o,a)}c((n=n.apply(e,t||[])).next())}))},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.isIosAndRedirectable=t.scopePollingDetectionStrategy=t.BaseWalletAdapter=t.WalletReadyState=t.EventEmitter=void 0;const s=i(r("ba10"));t.EventEmitter=s.default;const o=r("8217");(function(e){e["Installed"]="Installed",e["NotDetected"]="NotDetected",e["Loadable"]="Loadable",e["Unsupported"]="Unsupported"})(t.WalletReadyState||(t.WalletReadyState={}));class a extends s.default{get connected(){return!!this.publicKey}autoConnect(){return n(this,void 0,void 0,(function*(){yield this.connect()}))}prepareTransaction(e,t,r={}){return n(this,void 0,void 0,(function*(){const n=this.publicKey;if(!n)throw new o.WalletNotConnectedError;return e.feePayer=e.feePayer||n,e.recentBlockhash=e.recentBlockhash||(yield t.getLatestBlockhash({commitment:r.preflightCommitment,minContextSlot:r.minContextSlot})).blockhash,e}))}}function c(e){if("undefined"===typeof window||"undefined"===typeof document)return;const t=[];function r(){const r=e();if(r)for(const e of t)e()}const n=setInterval(r,1e3);t.push(()=>clearInterval(n)),"loading"===document.readyState&&(document.addEventListener("DOMContentLoaded",r,{once:!0}),t.push(()=>document.removeEventListener("DOMContentLoaded",r))),"complete"!==document.readyState&&(window.addEventListener("load",r,{once:!0}),t.push(()=>window.removeEventListener("load",r))),r()}function u(){if(!navigator)return!1;const e=navigator.userAgent.toLowerCase(),t=e.includes("iphone")||e.includes("ipad"),r=e.includes("safari");return t&&r}t.BaseWalletAdapter=a,t.scopePollingDetectionStrategy=c,t.isIosAndRedirectable=u},"843f":function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BrowserRandomSource=void 0;const n=65536;class i{constructor(){this.isAvailable=!1,this.isInstantiated=!1;const e="undefined"!==typeof self?self.crypto||self.msCrypto:null;e&&void 0!==e.getRandomValues&&(this._crypto=e,this.isAvailable=!0,this.isInstantiated=!0)}randomBytes(e){if(!this.isAvailable||!this._crypto)throw new Error("Browser random byte generator is not available.");const t=new Uint8Array(e);for(let r=0;r<t.length;r+=n)this._crypto.getRandomValues(t.subarray(r,r+Math.min(t.length-r,n)));return t}}t.BrowserRandomSource=i},"86b6":function(e,t,r){"use strict";r.d(t,"a",(function(){return C}));r("88e6"),r("70cc"),r("eb03"),r("22e5"),r("c01e"),r("fa76"),r("8306");var n=r("7ee5"),i=r("b675"),s=r("52c3"),o=r("6f02"),a=r("64b9"),c=r("253c9");r("d9e2"),r("14d9"),r("0643"),r("2382"),r("4e3e");const u="solana:mainnet",l="solana:devnet",d="solana:testnet";var h=r("7695"),b=r("1b1b"),p=r("e729"),g=r("e6a8"),y=r("7ce3"),m=r("e3a8");const f="data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMxIiB2aWV3Qm94PSIwIDAgMzEgMzEiIHdpZHRoPSIzMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIwLjI1IiB4Mj0iMjYuNTcxIiB5MT0iMjcuMTczIiB5Mj0iMTkuODU4Ij48c3RvcCBvZmZzZXQ9Ii4wOCIgc3RvcC1jb2xvcj0iIzk5NDVmZiIvPjxzdG9wIG9mZnNldD0iLjMiIHN0b3AtY29sb3I9IiM4NzUyZjMiLz48c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjNTQ5N2Q1Ii8+PHN0b3Agb2Zmc2V0PSIuNiIgc3RvcC1jb2xvcj0iIzQzYjRjYSIvPjxzdG9wIG9mZnNldD0iLjcyIiBzdG9wLWNvbG9yPSIjMjhlMGI5Ii8+PHN0b3Agb2Zmc2V0PSIuOTciIHN0b3AtY29sb3I9IiMxOWZiOWIiLz48L2xpbmVhckdyYWRpZW50PjxnIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iLjA5NCI+PHBhdGggZD0ibTI2LjEwOSAzLjY0My05LjM2OSA2Ljk1OSAxLjczMy00LjEwNSA3LjYzNy0yLjg1M3oiIGZpbGw9IiNlMjc2MWIiIHN0cm9rZT0iI2UyNzYxYiIvPjxnIGZpbGw9IiNlNDc2MWIiIHN0cm9rZT0iI2U0NzYxYiI+PHBhdGggZD0ibTQuNDgxIDMuNjQzIDkuMjk0IDcuMDI0LTEuNjQ4LTQuMTcxem0xOC4yNTggMTYuMTMtMi40OTUgMy44MjMgNS4zMzkgMS40NjkgMS41MzUtNS4yMDctNC4zNzgtLjA4NXptLTE5LjI0Ny4wODUgMS41MjUgNS4yMDcgNS4zMzktMS40NjktMi40OTUtMy44MjN6Ii8+PHBhdGggZD0ibTEwLjA1NSAxMy4zMTMtMS40ODggMi4yNTEgNS4zMDEuMjM1LS4xODgtNS42OTd6bTEwLjQ4IDAtMy42NzItMy4yNzctLjEyMiA1Ljc2MyA1LjI5Mi0uMjM1LTEuNDk3LTIuMjUxem0tMTAuMTc4IDEwLjI4MyAzLjE4My0xLjU1NC0yLjc0OS0yLjE0Ny0uNDMzIDMuNzAxem02LjY5NS0xLjU1NCAzLjE5MiAxLjU1NC0uNDQzLTMuNzAxeiIvPjwvZz48cGF0aCBkPSJtMjAuMjQ0IDIzLjU5Ni0zLjE5Mi0xLjU1NC4yNTQgMi4wODEtLjAyOC44NzZ6bS05Ljg4NyAwIDIuOTY2IDEuNDAzLS4wMTktLjg3Ni4yMzUtMi4wODEtMy4xODMgMS41NTR6IiBmaWxsPSIjZDdjMWIzIiBzdHJva2U9IiNkN2MxYjMiLz48cGF0aCBkPSJtMTMuMzY5IDE4LjUyMS0yLjY1NS0uNzgxIDEuODc0LS44NTd6bTMuODUxIDAgLjc4MS0xLjYzOCAxLjg4My44NTctMi42NjUuNzgxeiIgZmlsbD0iIzIzMzQ0NyIgc3Ryb2tlPSIjMjMzNDQ3Ii8+PHBhdGggZD0ibTEwLjM1NyAyMy41OTYuNDUyLTMuODIzLTIuOTQ3LjA4NXptOS40MzUtMy44MjMuNDUyIDMuODIzIDIuNDk1LTMuNzM4em0yLjI0MS00LjIwOS01LjI5Mi4yMzUuNDkgMi43MjEuNzgyLTEuNjM4IDEuODgzLjg1N3ptLTExLjMxOCAyLjE3NSAxLjg4My0uODU3Ljc3MiAxLjYzOC40OTktMi43MjEtNS4zMDEtLjIzNXoiIGZpbGw9IiNjZDYxMTYiIHN0cm9rZT0iI2NkNjExNiIvPjxwYXRoIGQ9Im04LjU2NyAxNS41NjQgMi4yMjIgNC4zMzEtLjA3NS0yLjE1NnptMTEuMzI4IDIuMTc1LS4wOTQgMi4xNTYgMi4yMzItNC4zMzEtMi4xMzcgMi4xNzV6bS02LjAyNi0xLjk0LS40OTkgMi43MjEuNjIxIDMuMjExLjE0MS00LjIyOC0uMjY0LTEuNzA0em0yLjg3MiAwLS4yNTQgMS42OTUuMTEzIDQuMjM3LjYzMS0zLjIxMXoiIGZpbGw9IiNlNDc1MWYiIHN0cm9rZT0iI2U0NzUxZiIvPjxwYXRoIGQ9Im0xNy4yMyAxOC41Mi0uNjMxIDMuMjExLjQ1Mi4zMTEgMi43NS0yLjE0Ny4wOTQtMi4xNTZ6bS02LjUxNi0uNzgxLjA3NSAyLjE1NiAyLjc1IDIuMTQ3LjQ1Mi0uMzExLS42MjItMy4yMTF6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48cGF0aCBkPSJtMTcuMjc3IDI0Ljk5OS4wMjgtLjg3Ni0uMjM1LS4yMDdoLTMuNTVsLS4yMTcuMjA3LjAxOS44NzYtMi45NjYtMS40MDMgMS4wMzYuODQ4IDIuMSAxLjQ1OWgzLjYwNmwyLjEwOS0xLjQ1OSAxLjAzNi0uODQ4eiIgZmlsbD0iI2MwYWQ5ZSIgc3Ryb2tlPSIjYzBhZDllIi8+PHBhdGggZD0ibTE3LjA1MSAyMi4wNDItLjQ1Mi0uMzExaC0yLjYwOGwtLjQ1Mi4zMTEtLjIzNSAyLjA4MS4yMTctLjIwN2gzLjU1bC4yMzUuMjA3LS4yNTQtMi4wODF6IiBmaWxsPSIjMTYxNjE2IiBzdHJva2U9IiMxNjE2MTYiLz48cGF0aCBkPSJtMjYuNTA1IDExLjA1My44LTMuODQyLTEuMTk2LTMuNTY5LTkuMDU4IDYuNzIzIDMuNDg0IDIuOTQ3IDQuOTI1IDEuNDQxIDEuMDkyLTEuMjcxLS40NzEtLjMzOS43NTMtLjY4Ny0uNTg0LS40NTIuNzUzLS41NzQtLjQ5OS0uMzc3em0tMjMuMjExLTMuODQxLjggMy44NDItLjUwOC4zNzcuNzUzLjU3NC0uNTc0LjQ1Mi43NTMuNjg3LS40NzEuMzM5IDEuMDgzIDEuMjcxIDQuOTI1LTEuNDQxIDMuNDg0LTIuOTQ3LTkuMDU5LTYuNzIzeiIgZmlsbD0iIzc2M2QxNiIgc3Ryb2tlPSIjNzYzZDE2Ii8+PHBhdGggZD0ibTI1LjQ2IDE0Ljc1NC00LjkyNS0xLjQ0MSAxLjQ5NyAyLjI1MS0yLjIzMiA0LjMzMSAyLjkzOC0uMDM4aDQuMzc4bC0xLjY1Ny01LjEwNHptLTE1LjQwNS0xLjQ0MS00LjkyNSAxLjQ0MS0xLjYzOCA1LjEwNGg0LjM2OWwyLjkyOC4wMzgtMi4yMjItNC4zMzEgMS40ODgtMi4yNTF6bTYuNjg1IDIuNDg2LjMxMS01LjQzMyAxLjQzMS0zLjg3aC02LjM1NmwxLjQxMyAzLjg3LjMyOSA1LjQzMy4xMTMgMS43MTQuMDA5IDQuMjE5aDIuNjFsLjAxOS00LjIxOS4xMjItMS43MTR6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48L2c+PGNpcmNsZSBjeD0iMjMuNSIgY3k9IjIzLjUiIGZpbGw9IiMwMDAiIHI9IjYuNSIvPjxwYXRoIGQ9Im0yNy40NzMgMjUuNTQ1LTEuMzEgMS4zNjhjLS4wMjkuMDMtLjA2My4wNTMtLjEwMS4wN2EuMzEuMzEgMCAwIDEgLS4xMjEuMDI0aC02LjIwOWMtLjAzIDAtLjA1OS0uMDA4LS4wODMtLjAyNGEuMTUuMTUgMCAwIDEgLS4wNTYtLjA2NWMtLjAxMi0uMDI2LS4wMTUtLjA1Ni0uMDEtLjA4NHMuMDE4LS4wNTUuMDM5LS4wNzZsMS4zMTEtMS4zNjhjLjAyOC0uMDMuMDYzLS4wNTMuMTAxLS4wNjlhLjMxLjMxIDAgMCAxIC4xMjEtLjAyNWg2LjIwOGMuMDMgMCAuMDU5LjAwOC4wODMuMDI0YS4xNS4xNSAwIDAgMSAuMDU2LjA2NWMuMDEyLjAyNi4wMTUuMDU2LjAxLjA4NHMtLjAxOC4wNTUtLjAzOS4wNzZ6bS0xLjMxLTIuNzU2Yy0uMDI5LS4wMy0uMDYzLS4wNTMtLjEwMS0uMDdhLjMxLjMxIDAgMCAwIC0uMTIxLS4wMjRoLTYuMjA5Yy0uMDMgMC0uMDU5LjAwOC0uMDgzLjAyNHMtLjA0NC4wMzgtLjA1Ni4wNjUtLjAxNS4wNTYtLjAxLjA4NC4wMTguMDU1LjAzOS4wNzZsMS4zMTEgMS4zNjhjLjAyOC4wMy4wNjMuMDUzLjEwMS4wNjlhLjMxLjMxIDAgMCAwIC4xMjEuMDI1aDYuMjA4Yy4wMyAwIC4wNTktLjAwOC4wODMtLjAyNGEuMTUuMTUgMCAwIDAgLjA1Ni0uMDY1Yy4wMTItLjAyNi4wMTUtLjA1Ni4wMS0uMDg0cy0uMDE4LS4wNTUtLjAzOS0uMDc2em0tNi40MzEtLjk4M2g2LjIwOWEuMzEuMzEgMCAwIDAgLjEyMS0uMDI0Yy4wMzgtLjAxNi4wNzMtLjA0LjEwMS0uMDdsMS4zMS0xLjM2OGMuMDItLjAyMS4wMzQtLjA0Ny4wMzktLjA3NnMuMDAxLS4wNTgtLjAxLS4wODRhLjE1LjE1IDAgMCAwIC0uMDU2LS4wNjVjLS4wMjUtLjAxNi0uMDU0LS4wMjQtLjA4My0uMDI0aC02LjIwOGEuMzEuMzEgMCAwIDAgLS4xMjEuMDI1Yy0uMDM4LjAxNi0uMDcyLjA0LS4xMDEuMDY5bC0xLjMxIDEuMzY4Yy0uMDIuMDIxLS4wMzQuMDQ3LS4wMzkuMDc2cy0uMDAxLjA1OC4wMS4wODQuMDMxLjA0OS4wNTYuMDY1LjA1NC4wMjQuMDgzLjAyNHoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=";var k,w,S,I,v,A,_,E,O,T,j,B,N,M,x=function(e,t,r,n){if("a"===r&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"===typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===r?n:"a"===r?n.call(e):n?n.value:t.get(e)},L=function(e,t,r,n,i){if("m"===n)throw new TypeError("Private method is not writable");if("a"===n&&!i)throw new TypeError("Private accessor was defined without a setter");if("function"===typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===n?i.call(e,r):i?i.value=r:t.set(e,r),r};class P{constructor(){k.add(this),w.set(this,{}),S.set(this,"1.0.0"),I.set(this,"MetaMask"),v.set(this,f),A.set(this,null),_.set(this,(e,t)=>{var r;return(null===(r=x(this,w,"f")[e])||void 0===r?void 0:r.push(t))||(x(this,w,"f")[e]=[t]),()=>x(this,k,"m",O).call(this,e,t)}),T.set(this,async()=>{if(!x(this,A,"f")){let t;try{t=(await r.e("chunk-b8e63c3c").then(r.bind(null,"99ab"))).default}catch(e){throw new Error("Unable to load Solflare MetaMask SDK")}L(this,A,new t,"f"),x(this,A,"f").on("standard_change",e=>x(this,k,"m",E).call(this,"change",e))}return this.accounts.length||await x(this,A,"f").connect(),{accounts:this.accounts}}),j.set(this,async()=>{x(this,A,"f")&&await x(this,A,"f").disconnect()}),B.set(this,async(...e)=>{if(!x(this,A,"f"))throw new s["h"];return await x(this,A,"f").standardSignAndSendTransaction(...e)}),N.set(this,async(...e)=>{if(!x(this,A,"f"))throw new s["h"];return await x(this,A,"f").standardSignTransaction(...e)}),M.set(this,async(...e)=>{if(!x(this,A,"f"))throw new s["h"];return await x(this,A,"f").standardSignMessage(...e)})}get version(){return x(this,S,"f")}get name(){return x(this,I,"f")}get icon(){return x(this,v,"f")}get chains(){return[u,l,d]}get features(){return{[g["b"]]:{version:"1.0.0",connect:x(this,T,"f")},[y["b"]]:{version:"1.0.0",disconnect:x(this,j,"f")},[m["b"]]:{version:"1.0.0",on:x(this,_,"f")},[h["a"]]:{version:"1.0.0",supportedTransactionVersions:["legacy",0],signAndSendTransaction:x(this,B,"f")},[b["a"]]:{version:"1.0.0",supportedTransactionVersions:["legacy",0],signTransaction:x(this,N,"f")},[p["a"]]:{version:"1.0.0",signMessage:x(this,M,"f")}}}get accounts(){return x(this,A,"f")?x(this,A,"f").standardAccounts:[]}}w=new WeakMap,S=new WeakMap,I=new WeakMap,v=new WeakMap,A=new WeakMap,_=new WeakMap,T=new WeakMap,j=new WeakMap,B=new WeakMap,N=new WeakMap,M=new WeakMap,k=new WeakSet,E=function(e,...t){var r;null===(r=x(this,w,"f")[e])||void 0===r||r.forEach(e=>e.apply(null,t))},O=function(e,t){var r;x(this,w,"f")[e]=null===(r=x(this,w,"f")[e])||void 0===r?void 0:r.filter(e=>t!==e)};let R=!1;function U(){R||(Object(c["a"])(new P),R=!0)}async function z(){const e="solflare-detect-metamask";function t(){window.postMessage({target:"metamask-contentscript",data:{name:"metamask-provider",data:{id:e,jsonrpc:"2.0",method:"wallet_getSnaps"}}},window.location.origin)}function r(n){var i;const s=n.data;var o;"metamask-inpage"===(null===s||void 0===s?void 0:s.target)&&"metamask-provider"===(null===(i=s.data)||void 0===i?void 0:i.name)&&((null===(o=s.data.data)||void 0===o?void 0:o.id)===e?(window.removeEventListener("message",r),s.data.data.error||U()):t())}window.addEventListener("message",r),window.setTimeout(()=>window.removeEventListener("message",r),5e3),t()}const W="Solflare";class C extends n["a"]{constructor(e={}){super(),this.name=W,this.url="https://solflare.com",this.icon="data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgNTAgNTAiIHdpZHRoPSI1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmMxMGIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmYjNmMmUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2LjQ3ODM1IiB4Mj0iMzQuOTEwNyIgeGxpbms6aHJlZj0iI2EiIHkxPSI3LjkyIiB5Mj0iMzMuNjU5MyIvPjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjAiIGN5PSIwIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQuOTkyMTg4MzIgMTIuMDYzODc5NjMgLTEyLjE4MTEzNjU1IDUuMDQwNzEwNzQgMjIuNTIwMiAyMC42MTgzKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHI9IjEiIHhsaW5rOmhyZWY9IiNhIi8+PHBhdGggZD0ibTI1LjE3MDggNDcuOTEwNGMuNTI1IDAgLjk1MDcuNDIxLjk1MDcuOTQwM3MtLjQyNTcuOTQwMi0uOTUwNy45NDAyLS45NTA3LS40MjA5LS45NTA3LS45NDAyLjQyNTctLjk0MDMuOTUwNy0uOTQwM3ptLTEuMDMyOC00NC45MTU2NWMuNDY0Ni4wMzgzNi44Mzk4LjM5MDQuOTAyNy44NDY4MWwxLjEzMDcgOC4yMTU3NGMuMzc5OCAyLjcxNDMgMy42NTM1IDMuODkwNCA1LjY3NDMgMi4wNDU5bDExLjMyOTEtMTAuMzExNThjLjI3MzMtLjI0ODczLjY5ODktLjIzMTQ5Ljk1MDcuMDM4NTEuMjMwOS4yNDc3Mi4yMzc5LjYyNjk3LjAxNjEuODgyNzdsLTkuODc5MSAxMS4zOTU4Yy0xLjgxODcgMi4wOTQyLS40NzY4IDUuMzY0MyAyLjI5NTYgNS41OTc4bDguNzE2OC44NDAzYy40MzQxLjA0MTguNzUxNy40MjM0LjcwOTMuODUyNC0uMDM0OS4zNTM3LS4zMDc0LjYzOTUtLjY2MjguNjk0OWwtOS4xNTk0IDEuNDMwMmMtMi42NTkzLjM2MjUtMy44NjM2IDMuNTExNy0yLjEzMzkgNS41NTc2bDMuMjIgMy43OTYxYy4yNTk0LjMwNTguMjE4OC43NjE1LS4wOTA4IDEuMDE3OC0uMjYyMi4yMTcyLS42NDE5LjIyNTYtLjkxMzguMDIwM2wtMy45Njk0LTIuOTk3OGMtMi4xNDIxLTEuNjEwOS01LjIyOTctLjI0MTctNS40NTYxIDIuNDI0M2wtLjg3NDcgMTAuMzk3NmMtLjAzNjIuNDI5NS0uNDE3OC43NDg3LS44NTI1LjcxMy0uMzY5LS4wMzAzLS42NjcxLS4zMDk3LS43MTcxLS42NzIxbC0xLjM4NzEtMTAuMDQzN2MtLjM3MTctMi43MTQ0LTMuNjQ1NC0zLjg5MDQtNS42NzQzLTIuMDQ1OWwtMTIuMDUxOTUgMTAuOTc0Yy0uMjQ5NDcuMjI3MS0uNjM4MDkuMjExNC0uODY4LS4wMzUtLjIxMDk0LS4yMjYyLS4yMTczNS0uNTcyNC0uMDE0OTMtLjgwNmwxMC41MTgxOC0xMi4xMzg1YzEuODE4Ny0yLjA5NDIuNDg0OS01LjM2NDQtMi4yODc2LTUuNTk3OGwtOC43MTg3Mi0uODQwNWMtLjQzNDEzLS4wNDE4LS43NTE3Mi0uNDIzNS0uNzA5MzYtLjg1MjQuMDM0OTMtLjM1MzcuMzA3MzktLjYzOTQuNjYyNy0uNjk1bDkuMTUzMzgtMS40Mjk5YzIuNjU5NC0uMzYyNSAzLjg3MTgtMy41MTE3IDIuMTQyMS01LjU1NzZsLTIuMTkyLTIuNTg0MWMtLjMyMTctLjM3OTItLjI3MTMtLjk0NDMuMTEyNi0xLjI2MjEuMzI1My0uMjY5NC43OTYzLS4yNzk3IDEuMTMzNC0uMDI0OWwyLjY5MTggMi4wMzQ3YzIuMTQyMSAxLjYxMDkgNS4yMjk3LjI0MTcgNS40NTYxLTIuNDI0M2wuNzI0MS04LjU1OTk4Yy4wNDU3LS41NDA4LjUyNjUtLjk0MjU3IDEuMDczOS0uODk3Mzd6bS0yMy4xODczMyAyMC40Mzk2NWMuNTI1MDQgMCAuOTUwNjcuNDIxLjk1MDY3Ljk0MDNzLS40MjU2My45NDAzLS45NTA2Ny45NDAzYy0uNTI1MDQxIDAtLjk1MDY3LS40MjEtLjk1MDY3LS45NDAzcy40MjU2MjktLjk0MDMuOTUwNjctLjk0MDN6bTQ3LjY3OTczLS45NTQ3Yy41MjUgMCAuOTUwNy40MjEuOTUwNy45NDAzcy0uNDI1Ny45NDAyLS45NTA3Ljk0MDItLjk1MDctLjQyMDktLjk1MDctLjk0MDIuNDI1Ny0uOTQwMy45NTA3LS45NDAzem0tMjQuNjI5Ni0yMi40Nzk3Yy41MjUgMCAuOTUwNi40MjA5NzMuOTUwNi45NDAyNyAwIC41MTkzLS40MjU2Ljk0MDI3LS45NTA2Ljk0MDI3LS41MjUxIDAtLjk1MDctLjQyMDk3LS45NTA3LS45NDAyNyAwLS41MTkyOTcuNDI1Ni0uOTQwMjcuOTUwNy0uOTQwMjd6IiBmaWxsPSJ1cmwoI2IpIi8+PHBhdGggZD0ibTI0LjU3MSAzMi43NzkyYzQuOTU5NiAwIDguOTgwMi0zLjk3NjUgOC45ODAyLTguODgxOSAwLTQuOTA1My00LjAyMDYtOC44ODE5LTguOTgwMi04Ljg4MTlzLTguOTgwMiAzLjk3NjYtOC45ODAyIDguODgxOWMwIDQuOTA1NCA0LjAyMDYgOC44ODE5IDguOTgwMiA4Ljg4MTl6IiBmaWxsPSJ1cmwoI2MpIi8+PC9zdmc+",this.supportedTransactionVersions=new Set(["legacy",0]),this._readyState="undefined"===typeof window||"undefined"===typeof document?i["b"].Unsupported:i["b"].Loadable,this._disconnected=()=>{const e=this._wallet;e&&(e.off("disconnect",this._disconnected),this._wallet=null,this._publicKey=null,this.emit("error",new s["d"]),this.emit("disconnect"))},this._accountChanged=e=>{if(!e)return;const t=this._publicKey;if(t){try{e=new a["e"](e.toBytes())}catch(r){return void this.emit("error",new s["j"](null===r||void 0===r?void 0:r.message,r))}t.equals(e)||(this._publicKey=e,this.emit("connect",e))}},this._connecting=!1,this._publicKey=null,this._wallet=null,this._config=e,this._readyState!==i["b"].Unsupported&&(Object(i["d"])(()=>{var e;return!!(null!==(e=window.solflare)&&void 0!==e&&e.isSolflare||window.SolflareApp)&&(this._readyState=i["b"].Installed,this.emit("readyStateChange",this._readyState),!0)}),z())}get publicKey(){return this._publicKey}get connecting(){return this._connecting}get connected(){var e;return!(null===(e=this._wallet)||void 0===e||!e.connected)}get readyState(){return this._readyState}async autoConnect(){this.readyState===i["b"].Loadable&&Object(i["c"])()||await this.connect()}async connect(){try{if(this.connected||this.connecting)return;if(this._readyState!==i["b"].Loadable&&this._readyState!==i["b"].Installed)throw new s["i"];if(this.readyState===i["b"].Loadable&&Object(i["c"])()){const e=encodeURIComponent(window.location.href),t=encodeURIComponent(window.location.origin);return void(window.location.href=`https://solflare.com/ul/v1/browse/${e}?ref=${t}`)}let t,n,o;try{t=(await r.e("chunk-4a0bb5d6").then(r.bind(null,"f97b"))).default}catch(e){throw new s["g"](null===e||void 0===e?void 0:e.message,e)}try{n=new t({network:this._config.network})}catch(e){throw new s["b"](null===e||void 0===e?void 0:e.message,e)}if(this._connecting=!0,!n.connected)try{await n.connect()}catch(e){throw new s["c"](null===e||void 0===e?void 0:e.message,e)}if(!n.publicKey)throw new s["c"];try{o=new a["e"](n.publicKey.toBytes())}catch(e){throw new s["j"](null===e||void 0===e?void 0:e.message,e)}n.on("disconnect",this._disconnected),n.on("accountChanged",this._accountChanged),this._wallet=n,this._publicKey=o,this.emit("connect",o)}catch(e){throw this.emit("error",e),e}finally{this._connecting=!1}}async disconnect(){const e=this._wallet;if(e){e.off("disconnect",this._disconnected),e.off("accountChanged",this._accountChanged),this._wallet=null,this._publicKey=null;try{await e.disconnect()}catch(t){this.emit("error",new s["e"](null===t||void 0===t?void 0:t.message,t))}}this.emit("disconnect")}async sendTransaction(e,t,r={}){try{const i=this._wallet;if(!i)throw new s["h"];try{const{signers:n,...s}=r;return Object(o["a"])(e)?(null===n||void 0===n?void 0:n.length)&&e.sign(n):(e=await this.prepareTransaction(e,t,s),(null===n||void 0===n?void 0:n.length)&&e.partialSign(...n)),s.preflightCommitment=s.preflightCommitment||t.commitment,await i.signAndSendTransaction(e,s)}catch(n){if(n instanceof s["f"])throw n;throw new s["k"](null===n||void 0===n?void 0:n.message,n)}}catch(n){throw this.emit("error",n),n}}async signTransaction(e){try{const r=this._wallet;if(!r)throw new s["h"];try{return await r.signTransaction(e)||e}catch(t){throw new s["m"](null===t||void 0===t?void 0:t.message,t)}}catch(t){throw this.emit("error",t),t}}async signAllTransactions(e){try{const r=this._wallet;if(!r)throw new s["h"];try{return await r.signAllTransactions(e)||e}catch(t){throw new s["m"](null===t||void 0===t?void 0:t.message,t)}}catch(t){throw this.emit("error",t),t}}async signMessage(e){try{const r=this._wallet;if(!r)throw new s["h"];try{return await r.signMessage(e,"utf8")}catch(t){throw new s["l"](null===t||void 0===t?void 0:t.message,t)}}catch(t){throw this.emit("error",t),t}}}},"8ab6":function(e,t,r){var n=r("42a7"),i="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";e.exports=n(i)},"8bad":function(e,t,r){"use strict";r.d(t,"a",(function(){return c}));var n=r("7ee5"),i=r("b675"),s=r("52c3"),o=r("64b9");const a="Torus";class c extends n["a"]{constructor({params:e={showTorusButton:!1}}={params:{showTorusButton:!1}}){super(),this.name=a,this.url="https://tor.us",this.icon="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzMiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMyAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYuNSIgY3k9IjE2IiByPSIxNiIgZmlsbD0iIzAzNjRGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjIxODYgOS40OTIxOUMxMC40NTM5IDkuNDkyMTkgOS44MzM5OCAxMC4xMTIxIDkuODMzOTggMTAuODc2OFYxMi40ODk4QzkuODMzOTggMTMuMjU0NSAxMC40NTM5IDEzLjg3NDQgMTEuMjE4NiAxMy44NzQ0SDEzLjY2ODRWMjIuODk3NkMxMy42Njg0IDIzLjY2MjMgMTQuMjg4MyAyNC4yODIyIDE1LjA1MyAyNC4yODIySDE2LjY2NkMxNy40MzA3IDI0LjI4MjIgMTguMDUwNiAyMy42NjIzIDE4LjA1MDYgMjIuODk3NlYxMi41MDE1QzE4LjA1MDYgMTIuNDk3NiAxOC4wNTA2IDEyLjQ5MzcgMTguMDUwNiAxMi40ODk4VjEwLjg3NjhDMTguMDUwNiAxMC4xMTIxIDE3LjQzMDcgOS40OTIxOSAxNi42NjYgOS40OTIxOUgxNS4wNTNIMTEuMjE4NloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yMS4zMzc2IDEzLjg3NDRDMjIuNTQ3NyAxMy44NzQ0IDIzLjUyODcgMTIuODkzNCAyMy41Mjg3IDExLjY4MzNDMjMuNTI4NyAxMC40NzMyIDIyLjU0NzcgOS40OTIxOSAyMS4zMzc2IDkuNDkyMTlDMjAuMTI3NSA5LjQ5MjE5IDE5LjE0NjUgMTAuNDczMiAxOS4xNDY1IDExLjY4MzNDMTkuMTQ2NSAxMi44OTM0IDIwLjEyNzUgMTMuODc0NCAyMS4zMzc2IDEzLjg3NDRaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K",this.supportedTransactionVersions=null,this._readyState="undefined"===typeof window||"undefined"===typeof document?i["b"].Unsupported:i["b"].Loadable,this._connecting=!1,this._wallet=null,this._publicKey=null,this._params=e}get publicKey(){return this._publicKey}get connecting(){return this._connecting}get connected(){var e;return!(null===(e=this._wallet)||void 0===e||!e.isLoggedIn)}get readyState(){return this._readyState}async connect(){try{if(this.connected||this.connecting)return;if(this._readyState!==i["b"].Loadable)throw new s["i"];let t,n,a,c;this._connecting=!0;try{t=(await r.e("chunk-791cb72f").then(r.bind(null,"b5dd"))).default}catch(e){throw new s["g"](null===e||void 0===e?void 0:e.message,e)}try{n=window.torus||new t}catch(e){throw new s["b"](null===e||void 0===e?void 0:e.message,e)}if(!n.isInitialized)try{await n.init(this._params)}catch(e){throw new s["c"](null===e||void 0===e?void 0:e.message,e)}try{a=await n.login()}catch(e){throw new s["a"](null===e||void 0===e?void 0:e.message,e)}try{c=new o["e"](a[0])}catch(e){throw new s["j"](null===e||void 0===e?void 0:e.message,e)}this._wallet=n,this._publicKey=c,this.emit("connect",c)}catch(e){throw this.emit("error",e),e}finally{this._connecting=!1}}async disconnect(){const e=this._wallet;if(e){this._wallet=null,this._publicKey=null;try{e.isLoggedIn&&await e.cleanUp()}catch(t){this.emit("error",new s["e"](null===t||void 0===t?void 0:t.message,t))}}this.emit("disconnect")}async sendTransaction(e,t,r={}){try{const i=this._wallet;if(!i)throw new s["h"];try{const{signers:n,...s}=r;e=await this.prepareTransaction(e,t,s),(null===n||void 0===n?void 0:n.length)&&e.partialSign(...n),s.preflightCommitment=s.preflightCommitment||t.commitment;const{signature:o}=await i.signAndSendTransaction(e,s);return o}catch(n){if(n instanceof s["f"])throw n;throw new s["k"](null===n||void 0===n?void 0:n.message,n)}}catch(n){throw this.emit("error",n),n}}async signTransaction(e){try{const r=this._wallet;if(!r)throw new s["h"];try{return await r.signTransaction(e)||e}catch(t){throw new s["m"](null===t||void 0===t?void 0:t.message,t)}}catch(t){throw this.emit("error",t),t}}async signAllTransactions(e){try{const r=this._wallet;if(!r)throw new s["h"];try{return await r.signAllTransactions(e)||e}catch(t){throw new s["m"](null===t||void 0===t?void 0:t.message,t)}}catch(t){throw this.emit("error",t),t}}async signMessage(e){try{const r=this._wallet;if(!r)throw new s["h"];try{return await r.signMessage(e)}catch(t){throw new s["l"](null===t||void 0===t?void 0:t.message,t)}}catch(t){throw this.emit("error",t),t}}}},"8df2":function(e,t,r){"use strict";
/**
 * Support for translating between Uint8Array instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */r("d9e2"),r("14d9"),r("13d5"),r("907a"),r("986a"),r("1d02"),r("3c5d"),r("6ce5"),r("2834"),r("4ea1"),r("669d"),r("109c"),r("b2c1"),r("0643"),r("9d4a"),Object.defineProperty(t,"__esModule",{value:!0}),t.s16=t.s8=t.nu64be=t.u48be=t.u40be=t.u32be=t.u24be=t.u16be=t.nu64=t.u48=t.u40=t.u32=t.u24=t.u16=t.u8=t.offset=t.greedy=t.Constant=t.UTF8=t.CString=t.Blob=t.Boolean=t.BitField=t.BitStructure=t.VariantLayout=t.Union=t.UnionLayoutDiscriminator=t.UnionDiscriminator=t.Structure=t.Sequence=t.DoubleBE=t.Double=t.FloatBE=t.Float=t.NearInt64BE=t.NearInt64=t.NearUInt64BE=t.NearUInt64=t.IntBE=t.Int=t.UIntBE=t.UInt=t.OffsetLayout=t.GreedyCount=t.ExternalLayout=t.bindConstructorLayout=t.nameWithProperty=t.Layout=t.uint8ArrayToBuffer=t.checkUint8Array=void 0,t.constant=t.utf8=t.cstr=t.blob=t.unionLayoutDiscriminator=t.union=t.seq=t.bits=t.struct=t.f64be=t.f64=t.f32be=t.f32=t.ns64be=t.s48be=t.s40be=t.s32be=t.s24be=t.s16be=t.ns64=t.s48=t.s40=t.s32=t.s24=void 0;const n=r("1c35");function i(e){if(!(e instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}function s(e){return i(e),n.Buffer.from(e.buffer,e.byteOffset,e.length)}t.checkUint8Array=i,t.uint8ArrayToBuffer=s;class o{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}function a(e,t){return t.property?e+"["+t.property+"]":e}function c(e,t){if("function"!==typeof e)throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(e,"layout_"))throw new Error("Class is already bound to a layout");if(!(t&&t instanceof o))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(t,"boundConstructor_"))throw new Error("layout is already bound to a constructor");e.layout_=t,t.boundConstructor_=e,t.makeDestinationObject=()=>new e,Object.defineProperty(e.prototype,"encode",{value(e,r){return t.encode(this,e,r)},writable:!0}),Object.defineProperty(e,"decode",{value(e,r){return t.decode(e,r)},writable:!0})}t.Layout=o,t.nameWithProperty=a,t.bindConstructorLayout=c;class u extends o{isCount(){throw new Error("ExternalLayout is abstract")}}t.ExternalLayout=u;class l extends u{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){i(e);const r=e.length-t;return Math.floor(r/this.elementSpan)}encode(e,t,r){return 0}}t.GreedyCount=l;class d extends u{constructor(e,t=0,r){if(!(e instanceof o))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,r||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof h||this.layout instanceof b}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,r=0){return this.layout.encode(e,t,r+this.offset)}}t.OffsetLayout=d;class h extends o{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return s(e).readUIntLE(t,this.span)}encode(e,t,r=0){return s(t).writeUIntLE(e,r,this.span),this.span}}t.UInt=h;class b extends o{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return s(e).readUIntBE(t,this.span)}encode(e,t,r=0){return s(t).writeUIntBE(e,r,this.span),this.span}}t.UIntBE=b;class p extends o{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return s(e).readIntLE(t,this.span)}encode(e,t,r=0){return s(t).writeIntLE(e,r,this.span),this.span}}t.Int=p;class g extends o{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return s(e).readIntBE(t,this.span)}encode(e,t,r=0){return s(t).writeIntBE(e,r,this.span),this.span}}t.IntBE=g;const y=Math.pow(2,32);function m(e){const t=Math.floor(e/y),r=e-t*y;return{hi32:t,lo32:r}}function f(e,t){return e*y+t}class k extends o{constructor(e){super(8,e)}decode(e,t=0){const r=s(e),n=r.readUInt32LE(t),i=r.readUInt32LE(t+4);return f(i,n)}encode(e,t,r=0){const n=m(e),i=s(t);return i.writeUInt32LE(n.lo32,r),i.writeUInt32LE(n.hi32,r+4),8}}t.NearUInt64=k;class w extends o{constructor(e){super(8,e)}decode(e,t=0){const r=s(e),n=r.readUInt32BE(t),i=r.readUInt32BE(t+4);return f(n,i)}encode(e,t,r=0){const n=m(e),i=s(t);return i.writeUInt32BE(n.hi32,r),i.writeUInt32BE(n.lo32,r+4),8}}t.NearUInt64BE=w;class S extends o{constructor(e){super(8,e)}decode(e,t=0){const r=s(e),n=r.readUInt32LE(t),i=r.readInt32LE(t+4);return f(i,n)}encode(e,t,r=0){const n=m(e),i=s(t);return i.writeUInt32LE(n.lo32,r),i.writeInt32LE(n.hi32,r+4),8}}t.NearInt64=S;class I extends o{constructor(e){super(8,e)}decode(e,t=0){const r=s(e),n=r.readInt32BE(t),i=r.readUInt32BE(t+4);return f(n,i)}encode(e,t,r=0){const n=m(e),i=s(t);return i.writeInt32BE(n.hi32,r),i.writeUInt32BE(n.lo32,r+4),8}}t.NearInt64BE=I;class v extends o{constructor(e){super(4,e)}decode(e,t=0){return s(e).readFloatLE(t)}encode(e,t,r=0){return s(t).writeFloatLE(e,r),4}}t.Float=v;class A extends o{constructor(e){super(4,e)}decode(e,t=0){return s(e).readFloatBE(t)}encode(e,t,r=0){return s(t).writeFloatBE(e,r),4}}t.FloatBE=A;class _ extends o{constructor(e){super(8,e)}decode(e,t=0){return s(e).readDoubleLE(t)}encode(e,t,r=0){return s(t).writeDoubleLE(e,r),8}}t.Double=_;class E extends o{constructor(e){super(8,e)}decode(e,t=0){return s(e).readDoubleBE(t)}encode(e,t,r=0){return s(t).writeDoubleBE(e,r),8}}t.DoubleBE=E;class O extends o{constructor(e,t,r){if(!(e instanceof o))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof u&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let n=-1;!(t instanceof u)&&0<e.span&&(n=t*e.span),super(n,r),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0,n=this.count;if(n instanceof u&&(n=n.decode(e,t)),0<this.elementLayout.span)r=n*this.elementLayout.span;else{let i=0;while(i<n)r+=this.elementLayout.getSpan(e,t+r),++i}return r}decode(e,t=0){const r=[];let n=0,i=this.count;i instanceof u&&(i=i.decode(e,t));while(n<i)r.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),n+=1;return r}encode(e,t,r=0){const n=this.elementLayout,i=e.reduce((e,i)=>e+n.encode(i,t,r+e),0);return this.count instanceof u&&this.count.encode(e.length,t,r),i}}t.Sequence=O;class T extends o{constructor(e,t,r){if(!Array.isArray(e)||!e.reduce((e,t)=>e&&t instanceof o,!0))throw new TypeError("fields must be array of Layout instances");"boolean"===typeof t&&void 0===r&&(r=t,t=void 0);for(const s of e)if(0>s.span&&void 0===s.property)throw new Error("fields cannot contain unnamed variable-length layout");let n=-1;try{n=e.reduce((e,t)=>e+t.getSpan(),0)}catch(i){}super(n,t),this.fields=e,this.decodePrefixes=!!r}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;try{r=this.fields.reduce((r,n)=>{const i=n.getSpan(e,t);return t+=i,r+i},0)}catch(n){throw new RangeError("indeterminate span")}return r}decode(e,t=0){i(e);const r=this.makeDestinationObject();for(const n of this.fields)if(void 0!==n.property&&(r[n.property]=n.decode(e,t)),t+=n.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return r}encode(e,t,r=0){const n=r;let i=0,s=0;for(const o of this.fields){let n=o.span;if(s=0<n?n:0,void 0!==o.property){const i=e[o.property];void 0!==i&&(s=o.encode(i,t,r),0>n&&(n=o.getSpan(t,r)))}i=r,r+=n}return i+s-n}fromArray(e){const t=this.makeDestinationObject();for(const r of this.fields)void 0!==r.property&&0<e.length&&(t[r.property]=e.shift());return t}layoutFor(e){if("string"!==typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if("string"!==typeof e)throw new TypeError("property must be string");let t=0;for(const r of this.fields){if(r.property===e)return t;0>r.span?t=-1:0<=t&&(t+=r.span)}}}t.Structure=T;class j{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,r){throw new Error("UnionDiscriminator is abstract")}}t.UnionDiscriminator=j;class B extends j{constructor(e,t){if(!(e instanceof u&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,r){return this.layout.encode(e,t,r)}}t.UnionLayoutDiscriminator=B;class N extends o{constructor(e,t,r){let n;if(e instanceof h||e instanceof b)n=new B(new d(e));else if(e instanceof u&&e.isCount())n=new B(e);else{if(!(e instanceof j))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");n=e}if(void 0===t&&(t=null),!(null===t||t instanceof o))throw new TypeError("defaultLayout must be null or a Layout");if(null!==t){if(0>t.span)throw new Error("defaultLayout must have constant span");void 0===t.property&&(t=t.replicate("content"))}let i=-1;t&&(i=t.span,0<=i&&(e instanceof h||e instanceof b)&&(i+=n.layout.span)),super(i,r),this.discriminator=n,this.usesPrefixDiscriminator=e instanceof h||e instanceof b,this.defaultLayout=t,this.registry={};let s=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(e){return s(e)},this.configGetSourceVariant=function(e){s=e.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const r=this.getVariant(e,t);if(!r)throw new Error("unable to determine span for unrecognized variant");return r.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const r=this.registry[t];if(r.property&&Object.prototype.hasOwnProperty.call(e,r.property))return r}throw new Error("unable to infer src variant")}decode(e,t=0){let r;const n=this.discriminator,i=n.decode(e,t),s=this.registry[i];if(void 0===s){const s=this.defaultLayout;let o=0;this.usesPrefixDiscriminator&&(o=n.layout.span),r=this.makeDestinationObject(),r[n.property]=i,r[s.property]=s.decode(e,t+o)}else r=s.decode(e,t);return r}encode(e,t,r=0){const n=this.getSourceVariant(e);if(void 0===n){const n=this.discriminator,i=this.defaultLayout;let s=0;return this.usesPrefixDiscriminator&&(s=n.layout.span),n.encode(e[n.property],t,r),s+i.encode(e[i.property],t,r+s)}return n.encode(e,t,r)}addVariant(e,t,r){const n=new M(this,e,t,r);return this.registry[e]=n,n}getVariant(e,t=0){let r;return r=e instanceof Uint8Array?this.discriminator.decode(e,t):e,this.registry[r]}}t.Union=N;class M extends o{constructor(e,t,r,n){if(!(e instanceof N))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if("string"===typeof r&&void 0===n&&(n=r,r=null),r){if(!(r instanceof o))throw new TypeError("layout must be a Layout");if(null!==e.defaultLayout&&0<=r.span&&r.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if("string"!==typeof n)throw new TypeError("variant must have a String property")}let i=e.span;0>e.span&&(i=r?r.span:0,0<=i&&e.usesPrefixDiscriminator&&(i+=e.discriminator.layout.span)),super(i,n),this.union=e,this.variant=t,this.layout=r||null}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span);let n=0;return this.layout&&(n=this.layout.getSpan(e,t+r)),r+n}decode(e,t=0){const r=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let n=0;return this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout?r[this.property]=this.layout.decode(e,t+n):this.property?r[this.property]=!0:this.union.usesPrefixDiscriminator&&(r[this.union.discriminator.property]=this.variant),r}encode(e,t,r=0){let n=0;if(this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,r);let i=n;if(this.layout&&(this.layout.encode(e[this.property],t,r+n),i+=this.layout.getSpan(t,r+n),0<=this.union.span&&i>this.union.span))throw new Error("encoded variant overruns containing union");return i}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}function x(e){return 0>e&&(e+=4294967296),e}t.VariantLayout=M;class L extends o{constructor(e,t,r){if(!(e instanceof h||e instanceof b))throw new TypeError("word must be a UInt or UIntBE layout");if("string"===typeof t&&void 0===r&&(r=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,r),this.word=e,this.msb=!!t,this.fields=[];let n=0;this._packedSetValue=function(e){return n=x(e),this},this._packedGetValue=function(){return n}}decode(e,t=0){const r=this.makeDestinationObject(),n=this.word.decode(e,t);this._packedSetValue(n);for(const i of this.fields)void 0!==i.property&&(r[i.property]=i.decode(e));return r}encode(e,t,r=0){const n=this.word.decode(t,r);this._packedSetValue(n);for(const i of this.fields)if(void 0!==i.property){const t=e[i.property];void 0!==t&&i.encode(t)}return this.word.encode(this._packedGetValue(),t,r)}addField(e,t){const r=new P(this,e,t);return this.fields.push(r),r}addBoolean(e){const t=new R(this,e);return this.fields.push(t),t}fieldFor(e){if("string"!==typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}t.BitStructure=L;class P{constructor(e,t,r){if(!(e instanceof L))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const n=8*e.span,i=e.fields.reduce((e,t)=>e+t.bits,0);if(t+i>n)throw new Error("bits too long for span remainder ("+(n-i)+" of "+n+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,32===t&&(this.valueMask=4294967295),this.start=i,this.container.msb&&(this.start=n-i-t),this.wordMask=x(this.valueMask<<this.start),this.property=r}decode(e,t){const r=this.container._packedGetValue(),n=x(r&this.wordMask),i=n>>>this.start;return i}encode(e){if("number"!==typeof e||!Number.isInteger(e)||e!==x(e&this.valueMask))throw new TypeError(a("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),r=x(e<<this.start);this.container._packedSetValue(x(t&~this.wordMask)|r)}}t.BitField=P;class R extends P{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){"boolean"===typeof e&&(e=+e),super.encode(e)}}t.Boolean=R;class U extends o{constructor(e,t){if(!(e instanceof u&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let r=-1;e instanceof u||(r=e),super(r,t),this.length=e}getSpan(e,t){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),r}decode(e,t=0){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),s(e).slice(t,t+r)}encode(e,t,r){let n=this.length;if(this.length instanceof u&&(n=e.length),!(e instanceof Uint8Array&&n===e.length))throw new TypeError(a("Blob.encode",this)+" requires (length "+n+") Uint8Array as src");if(r+n>t.length)throw new RangeError("encoding overruns Uint8Array");const i=s(e);return s(t).write(i.toString("hex"),r,n,"hex"),this.length instanceof u&&this.length.encode(n,t,r),n}}t.Blob=U;class z extends o{constructor(e){super(-1,e)}getSpan(e,t=0){i(e);let r=t;while(r<e.length&&0!==e[r])r+=1;return 1+r-t}decode(e,t=0){const r=this.getSpan(e,t);return s(e).slice(t,t+r-1).toString("utf-8")}encode(e,t,r=0){"string"!==typeof e&&(e=String(e));const i=n.Buffer.from(e,"utf8"),o=i.length;if(r+o>t.length)throw new RangeError("encoding overruns Buffer");const a=s(t);return i.copy(a,r),a[r+o]=0,o+1}}t.CString=z;class W extends o{constructor(e,t){if("string"===typeof e&&void 0===t&&(t=e,e=void 0),void 0===e)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return i(e),e.length-t}decode(e,t=0){const r=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<r)throw new RangeError("text length exceeds maxSpan");return s(e).slice(t,t+r).toString("utf-8")}encode(e,t,r=0){"string"!==typeof e&&(e=String(e));const i=n.Buffer.from(e,"utf8"),o=i.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(r+o>t.length)throw new RangeError("encoding overruns Buffer");return i.copy(s(t),r),o}}t.UTF8=W;class C extends o{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,r){return 0}}t.Constant=C,t.greedy=(e,t)=>new l(e,t),t.offset=(e,t,r)=>new d(e,t,r),t.u8=e=>new h(1,e),t.u16=e=>new h(2,e),t.u24=e=>new h(3,e),t.u32=e=>new h(4,e),t.u40=e=>new h(5,e),t.u48=e=>new h(6,e),t.nu64=e=>new k(e),t.u16be=e=>new b(2,e),t.u24be=e=>new b(3,e),t.u32be=e=>new b(4,e),t.u40be=e=>new b(5,e),t.u48be=e=>new b(6,e),t.nu64be=e=>new w(e),t.s8=e=>new p(1,e),t.s16=e=>new p(2,e),t.s24=e=>new p(3,e),t.s32=e=>new p(4,e),t.s40=e=>new p(5,e),t.s48=e=>new p(6,e),t.ns64=e=>new S(e),t.s16be=e=>new g(2,e),t.s24be=e=>new g(3,e),t.s32be=e=>new g(4,e),t.s40be=e=>new g(5,e),t.s48be=e=>new g(6,e),t.ns64be=e=>new I(e),t.f32=e=>new v(e),t.f32be=e=>new A(e),t.f64=e=>new _(e),t.f64be=e=>new E(e),t.struct=(e,t,r)=>new T(e,t,r),t.bits=(e,t,r)=>new L(e,t,r),t.seq=(e,t,r)=>new O(e,t,r),t.union=(e,t,r)=>new N(e,t,r),t.unionLayoutDiscriminator=(e,t)=>new B(e,t),t.blob=(e,t)=>new U(e,t),t.cstr=e=>new z(e),t.utf8=(e,t)=>new W(e,t),t.constant=(e,t)=>new C(e,t)},a5c0:function(e,t,r){"use strict";var n;r.d(t,"a",(function(){return n})),function(e){e["Mainnet"]="mainnet-beta",e["Testnet"]="testnet",e["Devnet"]="devnet"}(n||(n={}))},a81a:function(e,t,r){"use strict";(function(e){r.d(t,"b",(function(){return c})),r.d(t,"a",(function(){return u}));var n=r("8df2"),i=r("9ea2"),s=r("bbae");const o=t=>r=>{const o=Object(n["blob"])(t,r),{encode:a,decode:c}=Object(s["a"])(o),u=o;return u.decode=(t,r)=>{const n=c(t,r);return Object(i["toBigIntLE"])(e.from(n))},u.encode=(e,r,n)=>{const s=Object(i["toBufferLE"])(e,t);return a(s,r,n)},u},a=t=>r=>{const o=Object(n["blob"])(t,r),{encode:a,decode:c}=Object(s["a"])(o),u=o;return u.decode=(t,r)=>{const n=c(t,r);return Object(i["toBigIntBE"])(e.from(n))},u.encode=(e,r,n)=>{const s=Object(i["toBufferBE"])(e,t);return a(s,r,n)},u},c=o(8),u=(a(8),o(16));a(16),o(24),a(24),o(32),a(32)}).call(this,r("1c35").Buffer)},abed:function(e,t,r){"use strict";r.d(t,"a",(function(){return i}));r("14d9");var n=r("64b9");function i(e,t,r){if(r.length){e.push({pubkey:t,isSigner:!1,isWritable:!1});for(const t of r)e.push({pubkey:t instanceof n["e"]?t:t.publicKey,isSigner:!0,isWritable:!1})}else e.push({pubkey:t,isSigner:!0,isWritable:!1});return e}},abed2:function(e,t,r){"use strict";r.d(t,"a",(function(){return c}));var n=r("7ee5"),i=r("b675"),s=r("52c3"),o=r("64b9");const a="Trust";class c extends n["a"]{constructor(e={}){super(),this.name=a,this.url="https://trustwallet.com",this.icon="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAyIiBoZWlnaHQ9IjQwMiIgdmlld0JveD0iMCAwIDQwMiA0MDIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgo8cmVjdCB3aWR0aD0iNDAyIiBoZWlnaHQ9IjQwMiIgZmlsbD0idXJsKCNwYXR0ZXJuMCkiLz4KPGRlZnM+CjxwYXR0ZXJuIGlkPSJwYXR0ZXJuMCIgcGF0dGVybkNvbnRlbnRVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHdpZHRoPSIxIiBoZWlnaHQ9IjEiPgo8dXNlIHhsaW5rOmhyZWY9IiNpbWFnZTBfMTY5NF8xODk2NyIgdHJhbnNmb3JtPSJzY2FsZSgwLjAwMjQ4NzU2KSIvPgo8L3BhdHRlcm4+CjxpbWFnZSBpZD0iaW1hZ2UwXzE2OTRfMTg5NjciIHdpZHRoPSI0MDIiIGhlaWdodD0iNDAyIiB4bGluazpocmVmPSJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0JEQUFjRkJRWUZCQWNHQmdZSUJ3Y0lDeElMQ3dvS0N4WVBFQTBTR2hZYkdoa1dHUmdjSUNnaUhCNG1IaGdaSXpBa0ppb3JMUzR0R3lJeU5URXNOU2dzTFN6LzJ3QkRBUWNJQ0FzSkN4VUxDeFVzSFJrZExDd3NMQ3dzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3ovd2dBUkNBR1NBWklEQVNJQUFoRUJBeEVCLzhRQUd3QUJBQUlEQVFFQUFBQUFBQUFBQUFBQUFBRUdCQVVIQXdML3hBQVpBUUVBQXdFQkFBQUFBQUFBQUFBQUFBQUFBUU1FQlFMLzJnQU1Bd0VBQWhBREVBQUFBZWtBQUFFRXhJaEloSWhJaEloSWhJaEloSWhJaEloSWhJaEloSWhJaElJRWdBQUFBQVFrQUFBQUFBQUFBQUFBQUFBQUFBQWlVRWdBQUFRa0FBQUFBQUFBQUFBQUFBQUFBQUFBQWlVRWdBRUVnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWlZa0FJa0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUk1FZ2lZa0FBQUFBQUFBQUFQT29XVjduWFZWdXg5TXllWTNYTG8zSXo2QUFBQUFBQUFBRVNENUV6RWdBQUFBQUFCR0xNWmJSNmUydTVWK3BlT25QazR4cXpCTUFicTE4NlVYOVZjNzNlVFRhV3J6NmJmVWVmUUFBQUFBQUdPSmozbUppUUFBQUFOTlVQckE2Zk95Zm53WFZ6Qk1BZ0EyOXFvdXJtNjNyRnI1cGk5U3JlbWlvc2pIMVpnbUFQdjF4MFRrN0RUUFBycUhyWGJGeStpSGoyQUFBQmppWTk1aVlrQUFBQURtMkhuWVBZNVFzTVRYbCt5cUx1YzdMb0UxV1ZiZTVpaTRLN0FBSTArNWV2TksxWFNtaWpsVHArSGJYenhlNlpkVmppMnE0V1d1V1BsZElLclFBQUFNY1RIdk1URWdBQUFBYzYxK3kxdlg1YTMxQzIxMldnY3pvQUFBQUFBQUFPYTlLNW5yeTR3MzRycFlkRHZ1VjB3cXNBQUFBeHhNZTh4TVNBQUFBQnovVmJuVGRibUxWVmJONTlXOGN2b2dBQUFBQUFBT1lkUDVac3lmSTNZNzF1OVB1T1Qwd3JzQUFBQXh4TWU4eE1TQUFBQUJSOUZZcTcxZWFzVmQzaGVSeXVrQUFBQUFBQUI4OHM2ZHpIZGpEWms2RnM4SE80L1ZEejZBQUFBeHhNZTh4TVNBQUFBQlVxdmNLZjArYzIycHo3UEhSaHlPb0FBQUFBQUFCaGMzNkJ6L29ZUTFaK201RVR4dXFFU0FBQUJqaVk5NWlZa0FBQUFEUlVmb1hQZWpnZTNpMDBkVmVYcnhlcUNRQUFBQUFBTkRTTFpVK2x6M3Y0Ykc2cm9nNC9WQUFBQUF4eE1lOHhNU0FBQUFCNDh3NnJ6TGJreHh0eDlDMmRic25KNllWMkFBQUFBQUFValE1bUgxK1czMmh0dmoxYUJ5K2tBQUFBQmppWTk1aVlrQUFBQUJSYjFYYjZhWU9uenQzZXVXZE53YmZZWk5RQUFBQUFERnlxdlpYVWgxdVk2QlErbjQ5WDBNTzBBQUFBREhFeDd6RXhJQUFBQUR3OXlPV2ZOaHIzWDVpeTFvZFZWeXg4cm9oNTlnQUFBRHhRNXZtNnZwWUEwVWIrN1lHZnl1a0ZWb0FBQUFHT0pqM21KaVFBQUFBQU1mbkhUOVhvbzU4Ky9qcFlHOTBUelBUTW5sdG13N0xZOC9UTG9CSUJyYWpkVFphZGpOK01MYWxrd2I3azFmUXdiUUFBQUFBTWNUSHZNVEVnQUFBQUFBYTZqZEs4NzZlWExQV3VoaCtSNzhlOXRwYXF6cXJudTZ4Yk4vVWRMNTZzNGFNNHpZbkNzTzgzR0xYOC9SajFnQUFBQUFBWTRtUGVZbUpBQUFBQUFBQVl1VW1LUm9lcTYzWGw1NDJXdDI1UW55UHBQemtiKzFaZEdoc01zT3NQUHNBQUFBQUFBUWZEMElpWWxJQUFBQUFBQUFBRVZ1eXZmamxuejB2QjJaYWxkczM2elhoVGNBQUFBQUFBQUFpWUpBaVlKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFSSUFCRW9KQUFBQUFBQUFBQUFBQUFBQUFBQUFBaVlKQUFBQkVvSkFBQUFBQUFBQUFBQUFBQUFBQUFRRWdBQUFBQkNRUUpSSUFBQUFBQUFBQUFBQUFJSlFKaVFBQUFBQUFBQUErUkhpSkFBQUFBQUFBQUFBQWVub1FCSUFBQUFILzhRQUx4QUFBQVVFQWdFQ0JBVUZBQUFBQUFBQUFBRUNBd1FGRVRBeEVFQVNJRFFURkNGQklpUXpOV0FqTWxCd2dQL2FBQWdCQVFBQkJRTEhZV0lXSVdJV0lXSVdJV0lXSVdJV0lXSVdJV0lXSVdJV0lXSVdJV0lXSVdJV0lXSVdJV0lXSVc1di9OTi81TGYrbC92L0FDVDcvd0FLazFOcGhTYTE5V0pEY2h2ckhvRjFsdUpiUk1xaW5PV1hsc09SS2kzSTY5d1d1bXBTVUprVmR0QWVrT3lGZW1OVTNXQXhPWWtkVTlsclBld1ZLWVFIS3RIU0hhdzZvT1BPUEhoWm55R1EzV2lDS2xGV0V1dHI2SjdMV09mUCtWSmN5UXMvbVh3YnpwZ3pNOEVXbHVQQitsTXVOdnhuWTZ2V1Mxa1BtSGg4eStJOVRmYVUyNGwxdkdleTFqbktOYzdDeFRYM2hHZ014dVZJU3RNaWpwTU94M1dEdzBaUm5HeG5zdFk1ZnZmU2xLbEczVHBMZ2FveEJtSXd4NnpJbEU5UzQ3Z2NvN3lRdUsrMTY2TCtqalBaYXh6ZmZjVTZFMUpiS2x4U0NZY2RBSWlJc3FtVzNBcW54VkE2VEZNU0VFMUk0bzN0OFo3TFdPZjcvaWkvcGRPWDd6aWplMHhuc3RZNmorNGNVWCszcHlQZGNVZjJXTTlsckhVLzNIaWlkUjM2dmNVbjJPTTlsckhWZmY4QUZGL1Y2YXZxcmlsL3QrTTlsckhWeS9POFVZL3pQU1VkazgwNHJVL0dleTFqckpmbWVLUWRwdlNmTzBmbUVWb09NOWxySFdpL0Z4VER0VU9sTk8wTG1PVm8yTTlsckhXaS9wY1FUOFozU3FSMnAvSkZaT005bHJIVnl2QzRhVjR2ZEtzS3RENFlUNVNNaDdMV09vcDhvSExTdk5ubzFwWDA0cDZmS2ZrUFpheHZKODJPYWN2emdkR3JyOHBuRklUZVprUFpheVNFZkRrOFVaeTdIUmxyK0pNNG9xUHdaRDJXc2xXYjhKdkZLZCtITTZFbDM0TWJtbXQvRGdaRDJXc2xZYThtT0VxTkMyWENlWnoxaC84QUR3MmczSEVwSktjaDdMV1I1c25tRkpOS3VLVEs4RlpublVzTlBPcWZlNHBEUG5KeW5zdFphdEg4SHVZRlNKd3NqcnFHVVRacXBhK1lVZjVhTmxQWmF5dnNwZlplYVV3N3pGcWJqSVprTnlFNFpWVGFZRDhoeVF2bWxSUE5lWTlsck5OaEpsTnJRcHRmS0ZxYlZHcTRRNGgxUHBrem1Zd2sxQjZSNllNRlVwYVVraE9ZOWxyUExoTnlreUl6a1pmb2FmY1lWRnF5SE9YcERjZEVtcU9PK3FIVEZPaEtTUW5PZXkxMEZvUzRpVlNESUtTYUZlaUxPZGpCK3NGNExjVTZ2MFI0ajBrNHRPYWo5STlscnBQeG1wQlNhVTYxaFpZY2ZWR3BLRUFpSWk2VnV0SmdzeVJKZ3V4dlNTVFVjV2tHWVEybHRQVCt3Ky9WTXJsTHBSS0NrcVFvUllUc280ME5xS25ybjJIb3pNZ0pwY1ZKa1JKTHJmZi9BSnd2M2I5Y3hjeGN4Y3hjeGN4Y3hjeGN4Y3hjeGN4Y3hjeGN4Y3hjeGN4Y3hjeGN4Y3hjeGN4Y3hjeGN3bkwvQVAvRUFDY1JBQUlCQWdVRkFBSURBQUFBQUFBQUFBRUNBd0FSQkJBd01USVNJQ0ZBUVJSd0lsRlMvOW9BQ0FFREFRRS9BZjBhN2hONk03VkhNRzhIMWIyb3lxS2FjbmF0ODFtWmFXZFRRWUhiMEpKQ1RWejJKQ3pVSWxBdFR3RWNhMnp2UVlpa1BVTDZyYjBxbGpZVitPMUREajdTeHF1M1lWQjNvNGRmbEhEbis2ZU1wdmxGd0dxL0kxRHowc1JzTW8rQTFYNUdvZVkwc1I4eWo0alZsNW1vK1kwc1I4eVhpTldiblNjaHBZamxrTlhFY3RPZm5TK1RyWWdiSEtNM1VhTG03RTFFTHVOYVlYWExEdDR0b08zU3Q4c09QTjlkbDZUYWxicE42Vmd3dU8rV1RxOERLSmVsZGVXUHE4akpXSzdVazRQTHNlVlZwNUMrVU1kLzVIMFpJZzlNaFhmSkpDbTFDZFNQTlBNVzJ5QXZ0U1FmVzlNaTlQQi9taUNOODBnSjNwVkM3ZXN5aHQ2T0hQeWtpQ2ZvL3dEL3hBQWtFUUFDQVFNRUFnTUJBUUFBQUFBQUFBQUJBZ01BQkJFUU1ERXlFaUVnUUVFaWNQL2FBQWdCQWdFQlB3SC9BQTFJeS9GQzNURlNRRmZZK3FBVFN3dWFTMkE3VUJqVjRGYW10M0hGRlNPZm9SUmhWckErRHpxdE5NNU9hUzRCN1VEblhBb29wNUZPdmkyTjFlQlRNRUdUUnVWbzNSL0JUU00zSitDc1Y0b1hMRG1oZEQ5RkpLSDQwbTduZFRxS242YlZyeWRKZTUzWStncWZvZHExL2RKTzUzWXVncVhvZHExL2RIN0hkZzZDbjZuYXR1dWgzYlkveHQyNC9pbU9CbmV0VHlOSlJoenN4akNnVk1jSWQ2QnNQcGNyNzh0aU5mSnNhWFRlZ043aWtieUdhZGZNWU5NaFE0UHpoaThCazZTdjV0bmZobDhEZzhhTW9iMGFlM0k2L0JJV2VraVZOSjVjZnlQb3h6RlBWSTRmalI0bGZtbXQyQndLamdDODZFZ2MxSmNmaWZUQnh4U1hQNDFBZyt4ckpjQWVscG5MYy9XVnluc1VMbGNlNmttTC93Q0gvd0QveEFBM0VBQUJBUVFHQndZR0FnTUFBQUFBQUFBQkFnQURFUklRSUNFaVFGRXhRVkpoY1hLQkV5TXdVR0toQkRJemtaS3hRb0tBa1BELzJnQUlBUUVBQmo4Qy93QkMwcVIyaXR6WG5ObTR0TTdNZkw1bHFDUXhRNXVvejFtbWQyWUZwVlhIbVdmbGtWRUFiMmc1RTV6MU5GNHFOYVZmZUkzNld1cmdySStUM255UHUxMlpmQU4zYVFqM2FMeFpWeDhLeGNSa3ExdTlkZFV0OVNYaTExYVZjRGpwVTJ2RDdORXZsOURCdnJQUHlhMTR2N3RhZkFtZTkyajNMQU8rN1VHZzhURGZxUGdXS0k2dDlWZjVOOVo1K1RYMWRvbmV3V2d4QnhMMG5haDRVU096VG1wb3dtWHRHbVZRQkJ6YUxoVXZwTFFlSUtmQ1duSldKZmN4clFTQ2VEZlRsNXJHNzE1MFMxeDJBYzY4Q0lockIyWjlMWEZKWDdOZmRLSFN1ODVzUzk1cVZLZVJzT3B2a2oxYXh5ajdOWUllTmZkcFZ4RGZSSFJ0Q2gxWjRoT2hKaFN2bXhMM2pTOTQ0Ujl6bWxmUGlYdEwzcGhIdk1hVHo0bDUwL1ZMN3BoRjh4cC9zY1NyZ0tYdkRDRTBvNjRrY3RLeDZjR1RVZGY5cnhLRDZhZUtjRzhQcE5SMXk0bHllTktOOGYxZzMzTFVkREpJeExzNzZYWE5nM25UOTFBTXNUSEpWS0ZaS0J3WUdhcVhhYzFERlBmdlVRck1Sd1RwUEUwdWh2amlscHpTUlVkN3JNRkxzcHBKMlU0dDRqSlZLMFpHT0NlcTMwdlY5TVhOdGlOTXVwWWhnVnZNaFVSNnJjV2w1c0drS0drV3NsNG5Rb1lCTGtjVFNsQTBxTUdDUm9GbUxXN1A4Z3hTZElwN0Jac1Y4dmpsNHMyQmxQRmFUU1hoMEkvZU43WWZLdlR4cUIwK01GNmpuNHBXdFVBMlRzYUJVU2orV2s0MVR0V2dzWGE5SXFCTHkrajNEVE8xUjhLVkhlTDltbWVLalU3ZFl1ajVjZms4R2dzVUxFQ0treUZGSjNNRS9FRCt3YVpDZ29icTBDWmxiSWFFWkVaQ3JFMk9ocExCS1JBRHlDMnhlcFRRZUo2MVpuYWlscFgxeFdlcW1aNHFEU3V1N1Q3MWd0OWRSbHJMQktSQUR5S1ZhUW9NVmZEMmpaTFFVQ0R2cXdqTWpaTGR5bThkclUweTFGUnEzRTJablEweHZyelBrMEhpWTcybWRkNG4zOEdWMmtxYVo4WnpscWFBRUI1VEVpQzlvTkVpS05vVllKRVMwM3hGbnBEU29TRWpkNVpBdFA4QUQzVHN0S29RSW91aUNkb3RkRVZiUjh3N3hFZDdSbEo0bG9KRUIvbkovOFFBS2hBQUFRSUVCQVlEQVFFQkFBQUFBQUFBQVFBUklURmhjUkF3UVZFZ1FJR1JvYkZRNGZEQjhkSC8yZ0FJQVFFQUFUOGh5Q1FFNTI3cGp1bUtnRlFDb0JVQXFBVkFLZ0ZRQ29CVUFxQVZBS2dGUUNvQlVBcUFWQUtnRlFDb0JVQXFBVkFLZ0ZRQ1ltcVZHNlpia0NXVVRPQ0FiNEpta24zaG11OHBib0J2aG9pb1U4cncrSmJVSUY4ancrTEkxRTBJOFJpVzcvR21CZnZ3a3NnR0h4d2hEZ203YjQ4K3NTV0NBWWZJQ0RqQXlmSW1Zd0V6ekI4WUdZSmdPcSsvbFFGV28xRitaSk9XTmhEcVZHWElQNk5pSE1ieW1kamNTczVjQUFGSjVRb0hjeVRCT0Zab2ZaUEg3Um9PbkVPRmlLQ3hUUUJFcG5sWmlrMjVBZ0RrZ0NxbDRwR1U3eE5nZVU1Z2Z1WWs4UjFaVE9Eam9FWkFncVA0SzBtV3drTHduQjVHYmRTYlpnQkRBcnhrRzY4UFFlRi9wRk5GYzBSY2h2a05EMngrR1FnV0xBemU2Y2MyQjREa2VGNUFHUStwZjZSQVFKcWlNOUNtbmpjWmsyNmsyek5FUXV5R1RNcHY3a095WmcvWmh0aVp6YkFFOHZuUjdxOFdhSHJsRkJLRjFHWk51cE5zeUg4VWVKMUYyQjFxME4wQk1YNkg5SzZqQkU5K001Q0pNRUozSnV5N0o2SW51VW9MZUlkK01JOUhyTW0zVW0yWURYV01ieTJITXAwZDVyMzJkN1RLRUd3R2Q0b2txYkJ1STlLUVdpdTFQUWZIOTlNeWJkU2JaZ05peWhVK3VVSi8weHhDSlY2R1pOdXBOc3dHdUQwTVRoMS9ybERjbS91eEJxcGVobVRicVRiTUJxdjhNU2lQN1BsRGQ3K3pFV0d1WVRicVRiTUZxM294S0J1SEtGVkRpTFZEN1prMjZrMnpHaWJpZkp4dlova2NuUVFQd05LaFBsbVRicVRiTXZKdms0d0hjSHJrNkhFOGNEUm9PWk51cE5zeThRSHJHMHdlWEp1YXNjRkRWNHpKdDFKdG1PN2N4NCtzWFRRTzhPVHZ4bmhpQTVZS2xCc3liZFNiWmpmc2o3R1A2NkR5ZEJNZURqUWdlYzJiZFNiWmpHMkE3RHdVWi9Ea3V2eWVNYUVlQVBtemJxVGJNL053T0J5Nmg0bHVTYWRnUDdqWDBQOEFNMmJkU2Jac0FHZUFzK01ZNCtkL25KYThnbUJZUXhZM0pBL3V1Yk51cE5zMXgwQi9qK1l0SkdLNjVqa2Q3b1Y5T0NNSnVQcjlObXpicVRiTmFlYkJzY1Rqc2NBYXJWMEZ1UWFMeFAxNHlDUUNsT0lETm0zVW0yYkxRWXNnSXNSaU1RbGFFY2pvZHM5bVFQdlJUd0Y3WXN5Z3d1L0hPbTNVbTJjY1lmU3hTSzBNUVdYM3pRRWg2bFFDL3dEdHppQVNXRVNuRW03dWROdXBOczZRaXoyTzZEWXhlOWVBYTZHaHFzZFJxTGpLY0dOZ0dDNVZqQU5CYmdza1IxTytmTnVwTnM5NUJoZnFLT2hoaUR3QW9CMUprVVJFZnR3aGtvNmx4T25kcjEyVHZHUDJUcndnSXlSY29FT2dFd0EwejV0MUp0eUdnOUkwVUdRYUJJOEwxWlNSVEdJZDUvNGdRUTRMZzROUmpvTlRaUDdubGY4QUZNOEo0TXpoK2pJZEFaZ0JweUUyNmsyNUUrTU13VTRyVWVqMEtMQlhNQXg0UzREOFNHeVp3ZGlKL0RvME9PcDRlcXJDQk05bklDdzVLYmZsQm5zdEpDT3FlYkNKZW1xSUlMR0J5SE96WFlKbm92Si8xQVFBSkFjbkhIZENaNVVTZTZqN1J1aXBIMXdpNWhwQUJ5VXdtWjF1cFF1QWRBNVF6S1FYdHl3Q0FCQjBLZjJOWFNiYkk3TG5nY0pCT2NqN1U0Uk9ZZVdPZ3drNWdaQ01Ta0k2cDBxV0NoOFFVZ0F3SExpSkhFUWg4ZVN3UURERTc3Zkh6TnVHUnA4YWRoTlNIRE5EWS9Ga3NnTy9HUTZCME0vaVNXUUdwbmtrT25hZmY0ZDlCTkFkOHhtbDJUN3crRGRsRTBVczl0aW5PbzdKbS9PczNUN0JNVE05a0EzS0FBSktvVlVLcUZWQ3FoVlFxb1ZVS3FGVkNxaFZRcW9WVUtxRlZDcWhWUXFvVlVLcUZWQ3FoVlFxb1ZVS2luSE4vOW9BREFNQkFBSUFBd0FBQUJEenp6UlR6enp6enp6enp6enp6enp6VHp6enp6eVJ6enp6enp6enp6enp6enp6enp3elR6enlUenp6enp6enp6enp6enp6enp6enp5anp5aHp6enp6enp6enp6enp6enp6enp6enp4end6enp6enp6enp6enp6enp6enp6enp6enl6enp6enp6enp6enp6OVBmenp6enp6enp6enpEenp6enp6enp6UW9NTU9EN0h6enp6enp6ekx6enp6enl1QUFNTTkrNHNNUE9MM3p6enp3THp6enp6eUVJV1kzenp3MjAwd1A4QTg4ODg4Qzg4ODg4OEtRODg4ODg4ODg4NkQwODg4ODhDODg4ODg4cUU4ODg4ODg4ODhyRGQ4ODg4OEM4ODg4ODhxRzg4ODg4ODg4OGdEVzg4ODg4Qzg4ODg4OGpTODg4ODg4ODg4SkdWODg4ODhDODg4ODg4cEEvODg4ODg4ODhDSDg4ODg4OEM4ODg4ODhNRDE4ODg4ODg4OEpIODg4ODg4Qzg4ODg4OG9EYjg4ODg4ODg1REQ4ODg4ODhDODg4ODg4L0NDLzhBUFBQUFB3UjkvUFBQUFBBdlBQUFBQUE9DQWZ0L1BPOEF5dlBQUFBQUEF2UFBQUFBQUERqUTQwcUF4VDNQUFBQUFBQQXZQUFBQUFBQUExmUUF3RGovQUR6enp6enp6elB6enp6enp6enp6eTJLL3dBODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODhFODhVODg4ODg4ODg4ODg4ODg4ODg4ODg4MGM4OHN3ODg4ODg4ODg4ODg4ODg4ODg4OHM4ODg4ODhjODg4ODg4ODg4ODg4ODg4ODhFODg4ODg4ODg4akJCQkJCQkJCQkJCQkIvOEFQUFBQUFAvRUFDWVJBUUFDQVFNRUFnSURBUUFBQUFBQUFBRUFFU0VRTURGQVFXRnhJS0ZSY0lHUnNmRC8yZ0FJQVFNQkFUOFEvUm8xd2xzYW5ZQjZWSEpuZjc5VEdHb3FyZGNRNUp5V0p5UytnYmw0SjV2aGtPQ1k0dVpUSWlLcDFFY01Xc1pTL251OHZ2U1FkeElMbE9BZkF1aGNaeXFkbkExNzZmWVp4ZFRKajdtZjhQVzF4L2xwOUxkRlFkYlE4ajNvYUR3YnBwUlVuazJuZ2VOQlFHNktMNGcwM0JzdlpWcnhCU2VlZ2l4YlB1amZoZjhBak9saS9IWXVORjYzcUNVeGxVY3g4OUNnV3k3MkRTbUhuZnI5d2lWaGlGcVlUQitvSTVOY0x5emx1UHhvNjdIUTVRd3h1aG9sbGlYREJtT3dORVZDVmY0empvZ0ZNRnovQUVqdEN0Y2ppZmNIbzdWYmg5Q1djc1ROY3Y2UC84UUFKaEVCQUFJQUJRUURBQU1CQUFBQUFBQUFBUUFSRUNFd01WRkJZWEdoSUVDeFlIQ0I4UC9hQUFnQkFnRUJQeEQralg2MmN3bEV1ZFpUNnV3RnpvdGVabVN1QUtESE16Sm5LcHM1UG9ER3JXZHI0WkdOc3BScVpabGZVQVdPS201Q2FoZGNkWDFpZE1VSHNNYjB2aTR0YnFiVUdkU1I5TmZ2V0p2L0FPZnVsNldIdmFydndrRi85ZGRJNXJ4Zzc4anF1L0ZEZmkwaGt2R0N0TzdxdS84QWI5aHN1enBITTk4RmF1cmNqaGlXVkVwclJvTHpMbmdmUUNtZDlIdzVyeXF1K1dGWUhYUXI4RkhKMWhWWkJNOVlLeXFEOGdWb25NRGhjamJwcjh3SU41a0hwdVovbVBjUkduSFBOam1iVHZ6Z1o2N3Y5SFAyWkJyZUJPVFBtYmtEbVp2bmNBYlZFdjhBMG0vMGtWcW1NZnJEYkxNZXJqNmpkdTlLOVJxMk95RzVrZXh4L09qV2ZuLy94QUFxRUFFQUFRSUNDUVVCQVFFQUFBQUFBQUFCRVFBaE1hRVFNRUZSWVhHQmtmRWdRTEhCOEZEUjRmL2FBQWdCQVFBQlB4RFVXUmI3akdwY0ljMVNZdm9SVzhsNXJYaXE4VlhpcThWWGlxOFZYaXE4VlhpcThWWGlxOFZYaXE4VlhpcThWWGlxOFZYaXE4VlhpcThWWGlxOFZYaXE4Vlc0STVNVk13NjE2azRoeVdva2hsYm4yQXFNWGNWR0lodVA5b0JZaitDZ2tKSlU4V09EY292Z1N5ZGJMZGZpMUJnUDRxQ1FralVZTTdqYVVJSkdUVXFCS3dGUTNOdHpmei9rcUhBZHB2b0JicWJ0UVhTNE1PUEgrV2srUlNCSjZ1U0g0ZnpjRndmeDlNUzJMWXF3ZnpyeTlsemw2QzVzV0gzL0FEemFURzRvUkJMam9tVXgyYzZnRGQvUXZibTV5MFhCdXY4QTBiRzMyZEZ6OVAzZjNDUERpWWU1dXZ5R2tTUU51ekE1SmZ1VUV2MkVJWGNObnQ4UjJsKzJqYTcxYy9iWTJvM2c1Y1hoUXEzWE5nNGJtZkxEU2tXeWRvTnliU2pIcXRKZTR2cHZ6OXVSTGNJcktudE1KS2lCMWFMZkd3YUw4NU9kVHFSd2VXTEhxa2dDeFlQNHN6MG9NQlByelk5RjlyTEQydFpWN0JxTllxZ281a1RFRHNGNkhFWmg4aEJ5bzVXNFd2dkJrMWNsTWtxSEl3T21xSi94d2k5em9sRkN2YkRaSHpRUkRPNXZXSXpvc3VtSDBqN0hPcXlyV1JXNkRxVGZ3T0hkS1V1eFE2UUsvYi9kRHdMeFgzVW9EdlUrc0ZZTHRQRmJjUkJjQndjWHRRVVlReU9YdDU0MHpPTEY5eFBveDFHelgzeDhWa3JIOTErMys2ZHgwblFtL0VubkpWMll6OVBFYmF6T3F5cldNVEtUd0xHUnFRUUFWYkFWZkNkZ2lPR042d2NhTWhyWVNqd1lmTGpwTGUwU2cxdkhHUlh5eEhXZVpVMkU0SW5rQ3ozMVN0ek80UUpPNVBYV1oxV1Zhd29IZjV2VURXOXBYWXBzUlBhRU9qZktuRmQrRWZqaFJBbE5sUDFYN2VzSW13TWljUnBGZWJWaTVyZG9wM1laRmw2TnM2ZVlWak4yRW5yNWtEV002ckt0WVFUZjU2UmZaQ2hSQTdxL08zNEpTUXlEQk5uV1ZGaVhBUVphNmF1TzFqTXFSbUg4S0tZZXJuM05PUXBKU3dPM1NTZmF3eTZ6T3F5cldRQ0l2ZTRhWnQwWDg2ZTBCWnVzK21MZkEvZlBXWjFXVmF5RzhidTJtYmQzN24rUGFZM1hkK2ZUTU41eWZyV1oxV1ZheTJON3B1YlJlMDdkWkdNN1dtVWJ4OEgxck02ckt0WktONitIMXBqM3Q5bC8zMmwwcGxjOU1vakhaejYxbWRWbFdzL1djSDFwZzN4N1A5dlo3S3ArdzlIR0R1ays5Wm5WWlZySWZISCsybWQ4bVgxN1B4ano5SEZydkwvZXN6cXNxMWtjVDZaWDNwanV4RHVmWHM3cVJQZEVmZm90NUdUSFdaMVdWYXkwKzJlY3RLNjhUK0p6OW54M0Y2L1JPbERDVllDakp3QWREV1oxV1ZhenlnNTltbTlrWERrSDJkeTd3WEFUNk5OaUp0dk1HdHpxc3Exa0tsek9nL0I2TGd6ZnQ4aCsvWlFCY1F1VUQ1ZE5ucGw3ajZhM09xeXJXUitTa2RVZWlWMlVyaElNZzlsRVRaZzRxL0JOTStscGJpcDhGMXVkVmxXdGUzQVRtUmxHa0c3RVRnSStWMzlrWmpJamZZWkJwbkV4NXlGZmhyYzZyS3RiQVJFejJTWGZCNjZUaHJnQ0grQ2RmWWhKUW5yMnpKU3F5M2RMUVVkOUxaTmF6cXNxMXJuWit6dmNPK25oWXJJTWxZSlFKdmJUb3lkUFlIYzFpTmdXSGVYb2FjMVlCWW9HNENOd0VHdHpxc3ExcmhRc3U5c2VqRDBwTGJ6c1JHRTAzOENCYmE5V3pqejE5eTFFYlZzSEZwRDlqVFlZQWNBZzAzVU1lMnlCMkpkdGRuVlpWcnRpMW9iRSt3bm1Pa1VFVVM0bEFaSFlYQVhaOHVldHhlejRpN2cydkNqb0VMbUw5bnhtNkFRS01BWFZvekppNXY0blFnNmE3T3F5clhCMWdBRjlrT0kxWkVwT3diQndmUWFka0ZiWEJjVGc5eW9LTkd3ZmRpR3FscU8yS2Z4WXlwUzVtSFk5dzJmUG9jcnZzTVA0SHp5MStkVmxXdkpZb0hCUGkrTzhwWU9HdWZ0L293UWdzUjJwelloQmM0N1RtZHF3c3VURGs3bmg2aDRaTFhPcGgxWDRVWTJCVFluYytIRDA3cUZybVptOTJVR2RRMEFOZm5WWlY3QzBrV0RTOENiVGgycVRSSGJ1Vy9XUHBCYlNSZEJNSHJTRFJzSE1tL1ZialFNQUpFWkUwVFlEaXZ1R0xVZmxrS052aS9BNzBxaXFyZFgwOEZCUVAweithZ3ppZUFld3pxc3E5amdxamNsU1EzbFlPRzA1TitMVFRsaFFPWStsMnhOMnNjMjFsd3JFZXdWbnVBeFpjNnhwaHZMeTRIRDB4RjRNWm9iWGdTMDRBSzVlT1J6dSt5MzNhcXdHNjNzNENjUUhaaS9UQ3BTSlhnc2NmbzdVaUJCaEVoSFVRd25FRWN4YkZObURmQWJqdHlIQ2piREFZQTRIc3drNTFXanVaOXJaUjFyZlZzSFB1VS9GTkYzMUdLNTkzMHNkdUZrY0FvcGw3aVhmQnlMOFNzRE9FUS82OGZhT0VNWXRRUUJnV3BzWGNqOW43WU1MUWhJbERHdVZHT2UydUdIS2xHWkE0UjBTT1pRYXpnYjNBNnhVTWpVRW5oRzQ0R2Z0cjNlTTl2eG9HSXhMME1rbUQ3Y1dERUJQSkMvU2pjSFpGUFlSUFdqTzNBd09BZTM0QUxIMys0YWJ6dTRjdjU5NEx1QnpxQU5KYkRITVVJZ2x4L25HUHNzT2ZwTUxhdzRPNythM0V1eU45QUFHQjZVQkRoU1IybXgzL3dBdUJoSzRHK29MdDFpK3NCR0c1M1VrNEh5L2toeExnYjZTY1JaYWtCRFV0K2ZsL3dDTzN3VGtLZ3VzcmJySjduaXcvd0NVR1lFdHp0L2hvc2NkMjJveGJOeGpRQWdJTmNna0pKVXpFT0RjcURhOFZXOWh6dDcxRmhFN3FtNHJ6dFc0QnUvMVFZQ1BhS1VBN3dwdmZOWG1xODFYbXE4MVhtcTgxWG1xODFYbXE4MVhtcTgxWG1xODFYbXE4MVhtcTgxWG1xODFYbXE4MVhtcTgxVjQrYWdHUjFYb0FJQURXZi9aIi8+CjwvZGVmcz4KPC9zdmc+Cg==",this.supportedTransactionVersions=null,this._readyState="undefined"===typeof window||"undefined"===typeof document?i["b"].Unsupported:i["b"].NotDetected,this._disconnected=()=>{const e=this._wallet;e&&(e.off("disconnect",this._disconnected),this._wallet=null,this._publicKey=null,this.emit("error",new s["d"]),this.emit("disconnect"))},this._connecting=!1,this._wallet=null,this._publicKey=null,this._readyState!==i["b"].Unsupported&&Object(i["d"])(()=>{var e;return!(null===(e=window.trustwallet)||void 0===e||null===(e=e.solana)||void 0===e||!e.isTrust)&&(this._readyState=i["b"].Installed,this.emit("readyStateChange",this._readyState),!0)})}get publicKey(){return this._publicKey}get connecting(){return this._connecting}get connected(){var e;return!(null===(e=this._wallet)||void 0===e||!e.isConnected)}get readyState(){return this._readyState}async connect(){try{if(this.connected||this.connecting)return;if(this._readyState!==i["b"].Installed)throw new s["i"];this._connecting=!0;const t=window.trustwallet.solana;if(!t.isConnected)try{await t.connect()}catch(e){throw new s["c"](null===e||void 0===e?void 0:e.message,e)}if(!t.publicKey)throw new s["a"];let r;try{r=new o["e"](t.publicKey.toBytes())}catch(e){throw new s["j"](null===e||void 0===e?void 0:e.message,e)}t.on("disconnect",this._disconnected),this._wallet=t,this._publicKey=r,this.emit("connect",r)}catch(e){throw this.emit("error",e),e}finally{this._connecting=!1}}async disconnect(){const e=this._wallet;if(e){e.off("disconnect",this._disconnected),this._wallet=null,this._publicKey=null;try{await e.disconnect()}catch(t){this.emit("error",new s["e"](null===t||void 0===t?void 0:t.message,t))}}this.emit("disconnect")}async sendTransaction(e,t,r={}){try{const i=this._wallet;if(!i)throw new s["h"];try{const{signers:n,...s}=r;e=await this.prepareTransaction(e,t,s),(null===n||void 0===n?void 0:n.length)&&e.partialSign(...n),s.preflightCommitment=s.preflightCommitment||t.commitment;const{signature:o}=await i.signAndSendTransaction(e,s);return o}catch(n){if(n instanceof s["f"])throw n;throw new s["k"](null===n||void 0===n?void 0:n.message,n)}}catch(n){throw this.emit("error",n),n}}async signTransaction(e){try{const r=this._wallet;if(!r)throw new s["h"];try{return await r.signTransaction(e)||e}catch(t){throw new s["m"](null===t||void 0===t?void 0:t.message,t)}}catch(t){throw this.emit("error",t),t}}async signAllTransactions(e){try{const r=this._wallet;if(!r)throw new s["h"];try{return await r.signAllTransactions(e)||e}catch(t){throw new s["m"](null===t||void 0===t?void 0:t.message,t)}}catch(t){throw this.emit("error",t),t}}async signMessage(e){try{const r=this._wallet;if(!r)throw new s["h"];try{const{signature:t}=await r.signMessage(e);return t}catch(t){throw new s["l"](null===t||void 0===t?void 0:t.message,t)}}catch(t){throw this.emit("error",t),t}}}},b675:function(e,t,r){"use strict";r.d(t,"b",(function(){return n})),r.d(t,"a",(function(){return a})),r.d(t,"d",(function(){return c})),r.d(t,"c",(function(){return u}));r("14d9");var n,i=r("ba10"),s=r.n(i),o=r("52c3");(function(e){e["Installed"]="Installed",e["NotDetected"]="NotDetected",e["Loadable"]="Loadable",e["Unsupported"]="Unsupported"})(n||(n={}));class a extends s.a{get connected(){return!!this.publicKey}async autoConnect(){await this.connect()}async prepareTransaction(e,t,r={}){const n=this.publicKey;if(!n)throw new o["h"];return e.feePayer=e.feePayer||n,e.recentBlockhash=e.recentBlockhash||(await t.getLatestBlockhash({commitment:r.preflightCommitment,minContextSlot:r.minContextSlot})).blockhash,e}}function c(e){if("undefined"===typeof window||"undefined"===typeof document)return;const t=[];function r(){const r=e();if(r)for(const e of t)e()}const n=setInterval(r,1e3);t.push(()=>clearInterval(n)),"loading"===document.readyState&&(document.addEventListener("DOMContentLoaded",r,{once:!0}),t.push(()=>document.removeEventListener("DOMContentLoaded",r))),"complete"!==document.readyState&&(window.addEventListener("load",r,{once:!0}),t.push(()=>window.removeEventListener("load",r))),r()}function u(){if(!navigator)return!1;const e=navigator.userAgent.toLowerCase(),t=e.includes("iphone")||e.includes("ipad"),r=e.includes("safari");return t&&r}},b9be:function(e,t,r){"use strict";(function(e){r.d(t,"a",(function(){return d})),r.d(t,"b",(function(){return h}));var n=r("8df2"),i=r("633a"),s=(r("64b9"),r("d6e3")),o=r("753b"),a=r("d99e"),c=(r("7f6a"),r("0f06")),u=r("f7f2");const l=Object(n["struct"])([Object(n["u32"])("mintAuthorityOption"),Object(i["b"])("mintAuthority"),Object(i["c"])("supply"),Object(n["u8"])("decimals"),Object(i["a"])("isInitialized"),Object(n["u32"])("freezeAuthorityOption"),Object(i["b"])("freezeAuthority")]),d=l.span;function h(t,r,n=s["c"]){if(!r)throw new o["a"];if(!r.owner.equals(n))throw new o["c"];if(r.data.length<d)throw new o["d"];const i=l.decode(r.data.slice(0,d));let h=e.alloc(0);if(r.data.length>d){if(r.data.length<=c["a"])throw new o["d"];if(r.data.length===u["a"])throw new o["d"];if(r.data[c["a"]]!=a["b"].Mint)throw new o["i"];h=r.data.slice(c["a"]+a["a"])}return{address:t,mintAuthority:i.mintAuthorityOption?i.mintAuthority:null,supply:i.supply,decimals:i.decimals,isInitialized:i.isInitialized,freezeAuthority:i.freezeAuthorityOption?i.freezeAuthority:null,tlvData:h}}}).call(this,r("1c35").Buffer)},ba93:function(e,t,r){"use strict";(function(e){r.d(t,"a",(function(){return s}));var n=r("64b9"),i=r("d6e3");function s(t,r,n,s,a=i["c"],c=i["a"]){return o(t,r,n,s,e.alloc(0),a,c)}function o(e,t,r,s,o,a=i["c"],c=i["a"]){const u=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n["h"].programId,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1}];return new n["j"]({keys:u,programId:c,data:o})}}).call(this,r("1c35").Buffer)},bbae:function(e,t,r){"use strict";r.d(t,"a",(function(){return n}));const n=e=>{const t=e.decode.bind(e),r=e.encode.bind(e);return{decode:t,encode:r}}},bfcb:function(e,t,r){"use strict";r.d(t,"a",(function(){return u}));r("88e6"),r("70cc"),r("eb03"),r("22e5"),r("c01e"),r("fa76"),r("8306");var n=r("7ee5"),i=r("b675"),s=r("52c3"),o=r("6f02"),a=r("64b9");const c="Phantom";class u extends n["a"]{constructor(e={}){super(),this.name=c,this.url="https://phantom.app",this.icon="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg==",this.supportedTransactionVersions=new Set(["legacy",0]),this._readyState="undefined"===typeof window||"undefined"===typeof document?i["b"].Unsupported:i["b"].NotDetected,this._disconnected=()=>{const e=this._wallet;e&&(e.off("disconnect",this._disconnected),e.off("accountChanged",this._accountChanged),this._wallet=null,this._publicKey=null,this.emit("error",new s["d"]),this.emit("disconnect"))},this._accountChanged=e=>{const t=this._publicKey;if(t){try{e=new a["e"](e.toBytes())}catch(r){return void this.emit("error",new s["j"](null===r||void 0===r?void 0:r.message,r))}t.equals(e)||(this._publicKey=e,this.emit("connect",e))}},this._connecting=!1,this._wallet=null,this._publicKey=null,this._readyState!==i["b"].Unsupported&&(Object(i["c"])()?(this._readyState=i["b"].Loadable,this.emit("readyStateChange",this._readyState)):Object(i["d"])(()=>{var e,t;return!!(null!==(e=window.phantom)&&void 0!==e&&null!==(e=e.solana)&&void 0!==e&&e.isPhantom||null!==(t=window.solana)&&void 0!==t&&t.isPhantom)&&(this._readyState=i["b"].Installed,this.emit("readyStateChange",this._readyState),!0)}))}get publicKey(){return this._publicKey}get connecting(){return this._connecting}get readyState(){return this._readyState}async autoConnect(){this.readyState===i["b"].Installed&&await this.connect()}async connect(){try{var e;if(this.connected||this.connecting)return;if(this.readyState===i["b"].Loadable){const e=encodeURIComponent(window.location.href),t=encodeURIComponent(window.location.origin);return void(window.location.href=`https://phantom.app/ul/browse/${e}?ref=${t}`)}if(this.readyState!==i["b"].Installed)throw new s["i"];this._connecting=!0;const r=(null===(e=window.phantom)||void 0===e?void 0:e.solana)||window.solana;if(!r.isConnected)try{await r.connect()}catch(t){throw new s["c"](null===t||void 0===t?void 0:t.message,t)}if(!r.publicKey)throw new s["a"];let n;try{n=new a["e"](r.publicKey.toBytes())}catch(t){throw new s["j"](null===t||void 0===t?void 0:t.message,t)}r.on("disconnect",this._disconnected),r.on("accountChanged",this._accountChanged),this._wallet=r,this._publicKey=n,this.emit("connect",n)}catch(t){throw this.emit("error",t),t}finally{this._connecting=!1}}async disconnect(){const e=this._wallet;if(e){e.off("disconnect",this._disconnected),e.off("accountChanged",this._accountChanged),this._wallet=null,this._publicKey=null;try{await e.disconnect()}catch(t){this.emit("error",new s["e"](null===t||void 0===t?void 0:t.message,t))}}this.emit("disconnect")}async sendTransaction(e,t,r={}){try{const i=this._wallet;if(!i)throw new s["h"];try{const{signers:n,...s}=r;Object(o["a"])(e)?(null===n||void 0===n?void 0:n.length)&&e.sign(n):(e=await this.prepareTransaction(e,t,s),(null===n||void 0===n?void 0:n.length)&&e.partialSign(...n)),s.preflightCommitment=s.preflightCommitment||t.commitment;const{signature:a}=await i.signAndSendTransaction(e,s);return a}catch(n){if(n instanceof s["f"])throw n;throw new s["k"](null===n||void 0===n?void 0:n.message,n)}}catch(n){throw this.emit("error",n),n}}async signTransaction(e){try{const r=this._wallet;if(!r)throw new s["h"];try{return await r.signTransaction(e)||e}catch(t){throw new s["m"](null===t||void 0===t?void 0:t.message,t)}}catch(t){throw this.emit("error",t),t}}async signAllTransactions(e){try{const r=this._wallet;if(!r)throw new s["h"];try{return await r.signAllTransactions(e)||e}catch(t){throw new s["m"](null===t||void 0===t?void 0:t.message,t)}}catch(t){throw this.emit("error",t),t}}async signMessage(e){try{const r=this._wallet;if(!r)throw new s["h"];try{const{signature:t}=await r.signMessage(e);return t}catch(t){throw new s["l"](null===t||void 0===t?void 0:t.message,t)}}catch(t){throw this.emit("error",t),t}}}},c162:function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r("290c"),i=r("ff6a");t.DIGEST_LENGTH=64,t.BLOCK_SIZE=128;var s=function(){function e(){this.digestLength=t.DIGEST_LENGTH,this.blockSize=t.BLOCK_SIZE,this._stateHi=new Int32Array(8),this._stateLo=new Int32Array(8),this._tempHi=new Int32Array(16),this._tempLo=new Int32Array(16),this._buffer=new Uint8Array(256),this._bufferLength=0,this._bytesHashed=0,this._finished=!1,this.reset()}return e.prototype._initState=function(){this._stateHi[0]=1779033703,this._stateHi[1]=3144134277,this._stateHi[2]=1013904242,this._stateHi[3]=2773480762,this._stateHi[4]=1359893119,this._stateHi[5]=2600822924,this._stateHi[6]=528734635,this._stateHi[7]=1541459225,this._stateLo[0]=4089235720,this._stateLo[1]=2227873595,this._stateLo[2]=4271175723,this._stateLo[3]=1595750129,this._stateLo[4]=2917565137,this._stateLo[5]=725511199,this._stateLo[6]=4215389547,this._stateLo[7]=327033209},e.prototype.reset=function(){return this._initState(),this._bufferLength=0,this._bytesHashed=0,this._finished=!1,this},e.prototype.clean=function(){i.wipe(this._buffer),i.wipe(this._tempHi),i.wipe(this._tempLo),this.reset()},e.prototype.update=function(e,r){if(void 0===r&&(r=e.length),this._finished)throw new Error("SHA512: can't update because hash was finished.");var n=0;if(this._bytesHashed+=r,this._bufferLength>0){while(this._bufferLength<t.BLOCK_SIZE&&r>0)this._buffer[this._bufferLength++]=e[n++],r--;this._bufferLength===this.blockSize&&(a(this._tempHi,this._tempLo,this._stateHi,this._stateLo,this._buffer,0,this.blockSize),this._bufferLength=0)}r>=this.blockSize&&(n=a(this._tempHi,this._tempLo,this._stateHi,this._stateLo,e,n,r),r%=this.blockSize);while(r>0)this._buffer[this._bufferLength++]=e[n++],r--;return this},e.prototype.finish=function(e){if(!this._finished){var t=this._bytesHashed,r=this._bufferLength,i=t/536870912|0,s=t<<3,o=t%128<112?128:256;this._buffer[r]=128;for(var c=r+1;c<o-8;c++)this._buffer[c]=0;n.writeUint32BE(i,this._buffer,o-8),n.writeUint32BE(s,this._buffer,o-4),a(this._tempHi,this._tempLo,this._stateHi,this._stateLo,this._buffer,0,o),this._finished=!0}for(c=0;c<this.digestLength/8;c++)n.writeUint32BE(this._stateHi[c],e,8*c),n.writeUint32BE(this._stateLo[c],e,8*c+4);return this},e.prototype.digest=function(){var e=new Uint8Array(this.digestLength);return this.finish(e),e},e.prototype.saveState=function(){if(this._finished)throw new Error("SHA256: cannot save finished state");return{stateHi:new Int32Array(this._stateHi),stateLo:new Int32Array(this._stateLo),buffer:this._bufferLength>0?new Uint8Array(this._buffer):void 0,bufferLength:this._bufferLength,bytesHashed:this._bytesHashed}},e.prototype.restoreState=function(e){return this._stateHi.set(e.stateHi),this._stateLo.set(e.stateLo),this._bufferLength=e.bufferLength,e.buffer&&this._buffer.set(e.buffer),this._bytesHashed=e.bytesHashed,this._finished=!1,this},e.prototype.cleanSavedState=function(e){i.wipe(e.stateHi),i.wipe(e.stateLo),e.buffer&&i.wipe(e.buffer),e.bufferLength=0,e.bytesHashed=0},e}();t.SHA512=s;var o=new Int32Array([1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591]);function a(e,t,r,i,s,a,c){var u,l,d,h,b,p,g,y,m=r[0],f=r[1],k=r[2],w=r[3],S=r[4],I=r[5],v=r[6],A=r[7],_=i[0],E=i[1],O=i[2],T=i[3],j=i[4],B=i[5],N=i[6],M=i[7];while(c>=128){for(var x=0;x<16;x++){var L=8*x+a;e[x]=n.readUint32BE(s,L),t[x]=n.readUint32BE(s,L+4)}for(x=0;x<80;x++){var P=m,R=f,U=k,z=w,W=S,C=I,D=v,F=A,V=_,K=E,Q=O,H=T,Z=j,q=B,Y=N,G=M;if(u=A,l=M,b=65535&l,p=l>>>16,g=65535&u,y=u>>>16,u=(S>>>14|j<<18)^(S>>>18|j<<14)^(j>>>9|S<<23),l=(j>>>14|S<<18)^(j>>>18|S<<14)^(S>>>9|j<<23),b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,u=S&I^~S&v,l=j&B^~j&N,b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,u=o[2*x],l=o[2*x+1],b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,u=e[x%16],l=t[x%16],b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,p+=b>>>16,g+=p>>>16,y+=g>>>16,d=65535&g|y<<16,h=65535&b|p<<16,u=d,l=h,b=65535&l,p=l>>>16,g=65535&u,y=u>>>16,u=(m>>>28|_<<4)^(_>>>2|m<<30)^(_>>>7|m<<25),l=(_>>>28|m<<4)^(m>>>2|_<<30)^(m>>>7|_<<25),b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,u=m&f^m&k^f&k,l=_&E^_&O^E&O,b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,p+=b>>>16,g+=p>>>16,y+=g>>>16,F=65535&g|y<<16,G=65535&b|p<<16,u=z,l=H,b=65535&l,p=l>>>16,g=65535&u,y=u>>>16,u=d,l=h,b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,p+=b>>>16,g+=p>>>16,y+=g>>>16,z=65535&g|y<<16,H=65535&b|p<<16,f=P,k=R,w=U,S=z,I=W,v=C,A=D,m=F,E=V,O=K,T=Q,j=H,B=Z,N=q,M=Y,_=G,x%16===15)for(L=0;L<16;L++)u=e[L],l=t[L],b=65535&l,p=l>>>16,g=65535&u,y=u>>>16,u=e[(L+9)%16],l=t[(L+9)%16],b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,d=e[(L+1)%16],h=t[(L+1)%16],u=(d>>>1|h<<31)^(d>>>8|h<<24)^d>>>7,l=(h>>>1|d<<31)^(h>>>8|d<<24)^(h>>>7|d<<25),b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,d=e[(L+14)%16],h=t[(L+14)%16],u=(d>>>19|h<<13)^(h>>>29|d<<3)^d>>>6,l=(h>>>19|d<<13)^(d>>>29|h<<3)^(h>>>6|d<<26),b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,p+=b>>>16,g+=p>>>16,y+=g>>>16,e[L]=65535&g|y<<16,t[L]=65535&b|p<<16}u=m,l=_,b=65535&l,p=l>>>16,g=65535&u,y=u>>>16,u=r[0],l=i[0],b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,p+=b>>>16,g+=p>>>16,y+=g>>>16,r[0]=m=65535&g|y<<16,i[0]=_=65535&b|p<<16,u=f,l=E,b=65535&l,p=l>>>16,g=65535&u,y=u>>>16,u=r[1],l=i[1],b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,p+=b>>>16,g+=p>>>16,y+=g>>>16,r[1]=f=65535&g|y<<16,i[1]=E=65535&b|p<<16,u=k,l=O,b=65535&l,p=l>>>16,g=65535&u,y=u>>>16,u=r[2],l=i[2],b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,p+=b>>>16,g+=p>>>16,y+=g>>>16,r[2]=k=65535&g|y<<16,i[2]=O=65535&b|p<<16,u=w,l=T,b=65535&l,p=l>>>16,g=65535&u,y=u>>>16,u=r[3],l=i[3],b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,p+=b>>>16,g+=p>>>16,y+=g>>>16,r[3]=w=65535&g|y<<16,i[3]=T=65535&b|p<<16,u=S,l=j,b=65535&l,p=l>>>16,g=65535&u,y=u>>>16,u=r[4],l=i[4],b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,p+=b>>>16,g+=p>>>16,y+=g>>>16,r[4]=S=65535&g|y<<16,i[4]=j=65535&b|p<<16,u=I,l=B,b=65535&l,p=l>>>16,g=65535&u,y=u>>>16,u=r[5],l=i[5],b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,p+=b>>>16,g+=p>>>16,y+=g>>>16,r[5]=I=65535&g|y<<16,i[5]=B=65535&b|p<<16,u=v,l=N,b=65535&l,p=l>>>16,g=65535&u,y=u>>>16,u=r[6],l=i[6],b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,p+=b>>>16,g+=p>>>16,y+=g>>>16,r[6]=v=65535&g|y<<16,i[6]=N=65535&b|p<<16,u=A,l=M,b=65535&l,p=l>>>16,g=65535&u,y=u>>>16,u=r[7],l=i[7],b+=65535&l,p+=l>>>16,g+=65535&u,y+=u>>>16,p+=b>>>16,g+=p>>>16,y+=g>>>16,r[7]=A=65535&g|y<<16,i[7]=M=65535&b|p<<16,a+=128,c-=128}return a}function c(e){var t=new s;t.update(e);var r=t.digest();return t.clean(),r}t.hash=c},ca74:function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r("290c"),i=r("ff6a");t.DIGEST_LENGTH=32,t.BLOCK_SIZE=64;var s=function(){function e(){this.digestLength=t.DIGEST_LENGTH,this.blockSize=t.BLOCK_SIZE,this._state=new Int32Array(8),this._temp=new Int32Array(64),this._buffer=new Uint8Array(128),this._bufferLength=0,this._bytesHashed=0,this._finished=!1,this.reset()}return e.prototype._initState=function(){this._state[0]=1779033703,this._state[1]=3144134277,this._state[2]=1013904242,this._state[3]=2773480762,this._state[4]=1359893119,this._state[5]=2600822924,this._state[6]=528734635,this._state[7]=1541459225},e.prototype.reset=function(){return this._initState(),this._bufferLength=0,this._bytesHashed=0,this._finished=!1,this},e.prototype.clean=function(){i.wipe(this._buffer),i.wipe(this._temp),this.reset()},e.prototype.update=function(e,t){if(void 0===t&&(t=e.length),this._finished)throw new Error("SHA256: can't update because hash was finished.");var r=0;if(this._bytesHashed+=t,this._bufferLength>0){while(this._bufferLength<this.blockSize&&t>0)this._buffer[this._bufferLength++]=e[r++],t--;this._bufferLength===this.blockSize&&(a(this._temp,this._state,this._buffer,0,this.blockSize),this._bufferLength=0)}t>=this.blockSize&&(r=a(this._temp,this._state,e,r,t),t%=this.blockSize);while(t>0)this._buffer[this._bufferLength++]=e[r++],t--;return this},e.prototype.finish=function(e){if(!this._finished){var t=this._bytesHashed,r=this._bufferLength,i=t/536870912|0,s=t<<3,o=t%64<56?64:128;this._buffer[r]=128;for(var c=r+1;c<o-8;c++)this._buffer[c]=0;n.writeUint32BE(i,this._buffer,o-8),n.writeUint32BE(s,this._buffer,o-4),a(this._temp,this._state,this._buffer,0,o),this._finished=!0}for(c=0;c<this.digestLength/4;c++)n.writeUint32BE(this._state[c],e,4*c);return this},e.prototype.digest=function(){var e=new Uint8Array(this.digestLength);return this.finish(e),e},e.prototype.saveState=function(){if(this._finished)throw new Error("SHA256: cannot save finished state");return{state:new Int32Array(this._state),buffer:this._bufferLength>0?new Uint8Array(this._buffer):void 0,bufferLength:this._bufferLength,bytesHashed:this._bytesHashed}},e.prototype.restoreState=function(e){return this._state.set(e.state),this._bufferLength=e.bufferLength,e.buffer&&this._buffer.set(e.buffer),this._bytesHashed=e.bytesHashed,this._finished=!1,this},e.prototype.cleanSavedState=function(e){i.wipe(e.state),e.buffer&&i.wipe(e.buffer),e.bufferLength=0,e.bytesHashed=0},e}();t.SHA256=s;var o=new Int32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]);function a(e,t,r,i,s){while(s>=64){for(var a=t[0],c=t[1],u=t[2],l=t[3],d=t[4],h=t[5],b=t[6],p=t[7],g=0;g<16;g++){var y=i+4*g;e[g]=n.readUint32BE(r,y)}for(g=16;g<64;g++){var m=e[g-2],f=(m>>>17|m<<15)^(m>>>19|m<<13)^m>>>10;m=e[g-15];var k=(m>>>7|m<<25)^(m>>>18|m<<14)^m>>>3;e[g]=(f+e[g-7]|0)+(k+e[g-16]|0)}for(g=0;g<64;g++){f=(((d>>>6|d<<26)^(d>>>11|d<<21)^(d>>>25|d<<7))+(d&h^~d&b)|0)+(p+(o[g]+e[g]|0)|0)|0,k=((a>>>2|a<<30)^(a>>>13|a<<19)^(a>>>22|a<<10))+(a&c^a&u^c&u)|0;p=b,b=h,h=d,d=l+f|0,l=u,u=c,c=a,a=f+k|0}t[0]+=a,t[1]+=c,t[2]+=u,t[3]+=l,t[4]+=d,t[5]+=h,t[6]+=b,t[7]+=p,i+=64,s-=64}return i}function c(e){var t=new s;t.update(e);var r=t.digest();return t.clean(),r}t.hash=c},caeb:function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isWalletAdapterCompatibleStandardWallet=void 0;const n=r("74a3"),i=r("10d7");function s(e){return i.StandardConnect in e.features&&i.StandardEvents in e.features&&(n.SolanaSignAndSendTransaction in e.features||n.SolanaSignTransaction in e.features)}t.isWalletAdapterCompatibleStandardWallet=s},d6e3:function(e,t,r){"use strict";r.d(t,"c",(function(){return i})),r.d(t,"b",(function(){return s})),r.d(t,"a",(function(){return o}));var n=r("64b9");const i=new n["e"]("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),s=new n["e"]("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),o=new n["e"]("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new n["e"]("So11111111111111111111111111111111111111112"),new n["e"]("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP")},d99e:function(e,t,r){"use strict";var n;r.d(t,"b",(function(){return n})),r.d(t,"a",(function(){return i})),function(e){e[e["Uninitialized"]=0]="Uninitialized",e[e["Mint"]=1]="Mint",e[e["Account"]=2]="Account"}(n||(n={}));const i=1},e060:function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sharedKey=t.generateKeyPair=t.generateKeyPairFromSeed=t.scalarMultBase=t.scalarMult=t.SHARED_KEY_LENGTH=t.SECRET_KEY_LENGTH=t.PUBLIC_KEY_LENGTH=void 0;const n=r("e5f1"),i=r("ff6a");function s(e){const t=new Float64Array(16);if(e)for(let r=0;r<e.length;r++)t[r]=e[r];return t}t.PUBLIC_KEY_LENGTH=32,t.SECRET_KEY_LENGTH=32,t.SHARED_KEY_LENGTH=32;const o=new Uint8Array(32);o[0]=9;const a=s([56129,1]);function c(e){let t=1;for(let r=0;r<16;r++){let n=e[r]+t+65535;t=Math.floor(n/65536),e[r]=n-65536*t}e[0]+=t-1+37*(t-1)}function u(e,t,r){const n=~(r-1);for(let i=0;i<16;i++){const r=n&(e[i]^t[i]);e[i]^=r,t[i]^=r}}function l(e,t){const r=s(),n=s();for(let i=0;i<16;i++)n[i]=t[i];c(n),c(n),c(n);for(let i=0;i<2;i++){r[0]=n[0]-65517;for(let t=1;t<15;t++)r[t]=n[t]-65535-(r[t-1]>>16&1),r[t-1]&=65535;r[15]=n[15]-32767-(r[14]>>16&1);const e=r[15]>>16&1;r[14]&=65535,u(n,r,1-e)}for(let i=0;i<16;i++)e[2*i]=255&n[i],e[2*i+1]=n[i]>>8}function d(e,t){for(let r=0;r<16;r++)e[r]=t[2*r]+(t[2*r+1]<<8);e[15]&=32767}function h(e,t,r){for(let n=0;n<16;n++)e[n]=t[n]+r[n]}function b(e,t,r){for(let n=0;n<16;n++)e[n]=t[n]-r[n]}function p(e,t,r){let n,i,s=0,o=0,a=0,c=0,u=0,l=0,d=0,h=0,b=0,p=0,g=0,y=0,m=0,f=0,k=0,w=0,S=0,I=0,v=0,A=0,_=0,E=0,O=0,T=0,j=0,B=0,N=0,M=0,x=0,L=0,P=0,R=r[0],U=r[1],z=r[2],W=r[3],C=r[4],D=r[5],F=r[6],V=r[7],K=r[8],Q=r[9],H=r[10],Z=r[11],q=r[12],Y=r[13],G=r[14],J=r[15];n=t[0],s+=n*R,o+=n*U,a+=n*z,c+=n*W,u+=n*C,l+=n*D,d+=n*F,h+=n*V,b+=n*K,p+=n*Q,g+=n*H,y+=n*Z,m+=n*q,f+=n*Y,k+=n*G,w+=n*J,n=t[1],o+=n*R,a+=n*U,c+=n*z,u+=n*W,l+=n*C,d+=n*D,h+=n*F,b+=n*V,p+=n*K,g+=n*Q,y+=n*H,m+=n*Z,f+=n*q,k+=n*Y,w+=n*G,S+=n*J,n=t[2],a+=n*R,c+=n*U,u+=n*z,l+=n*W,d+=n*C,h+=n*D,b+=n*F,p+=n*V,g+=n*K,y+=n*Q,m+=n*H,f+=n*Z,k+=n*q,w+=n*Y,S+=n*G,I+=n*J,n=t[3],c+=n*R,u+=n*U,l+=n*z,d+=n*W,h+=n*C,b+=n*D,p+=n*F,g+=n*V,y+=n*K,m+=n*Q,f+=n*H,k+=n*Z,w+=n*q,S+=n*Y,I+=n*G,v+=n*J,n=t[4],u+=n*R,l+=n*U,d+=n*z,h+=n*W,b+=n*C,p+=n*D,g+=n*F,y+=n*V,m+=n*K,f+=n*Q,k+=n*H,w+=n*Z,S+=n*q,I+=n*Y,v+=n*G,A+=n*J,n=t[5],l+=n*R,d+=n*U,h+=n*z,b+=n*W,p+=n*C,g+=n*D,y+=n*F,m+=n*V,f+=n*K,k+=n*Q,w+=n*H,S+=n*Z,I+=n*q,v+=n*Y,A+=n*G,_+=n*J,n=t[6],d+=n*R,h+=n*U,b+=n*z,p+=n*W,g+=n*C,y+=n*D,m+=n*F,f+=n*V,k+=n*K,w+=n*Q,S+=n*H,I+=n*Z,v+=n*q,A+=n*Y,_+=n*G,E+=n*J,n=t[7],h+=n*R,b+=n*U,p+=n*z,g+=n*W,y+=n*C,m+=n*D,f+=n*F,k+=n*V,w+=n*K,S+=n*Q,I+=n*H,v+=n*Z,A+=n*q,_+=n*Y,E+=n*G,O+=n*J,n=t[8],b+=n*R,p+=n*U,g+=n*z,y+=n*W,m+=n*C,f+=n*D,k+=n*F,w+=n*V,S+=n*K,I+=n*Q,v+=n*H,A+=n*Z,_+=n*q,E+=n*Y,O+=n*G,T+=n*J,n=t[9],p+=n*R,g+=n*U,y+=n*z,m+=n*W,f+=n*C,k+=n*D,w+=n*F,S+=n*V,I+=n*K,v+=n*Q,A+=n*H,_+=n*Z,E+=n*q,O+=n*Y,T+=n*G,j+=n*J,n=t[10],g+=n*R,y+=n*U,m+=n*z,f+=n*W,k+=n*C,w+=n*D,S+=n*F,I+=n*V,v+=n*K,A+=n*Q,_+=n*H,E+=n*Z,O+=n*q,T+=n*Y,j+=n*G,B+=n*J,n=t[11],y+=n*R,m+=n*U,f+=n*z,k+=n*W,w+=n*C,S+=n*D,I+=n*F,v+=n*V,A+=n*K,_+=n*Q,E+=n*H,O+=n*Z,T+=n*q,j+=n*Y,B+=n*G,N+=n*J,n=t[12],m+=n*R,f+=n*U,k+=n*z,w+=n*W,S+=n*C,I+=n*D,v+=n*F,A+=n*V,_+=n*K,E+=n*Q,O+=n*H,T+=n*Z,j+=n*q,B+=n*Y,N+=n*G,M+=n*J,n=t[13],f+=n*R,k+=n*U,w+=n*z,S+=n*W,I+=n*C,v+=n*D,A+=n*F,_+=n*V,E+=n*K,O+=n*Q,T+=n*H,j+=n*Z,B+=n*q,N+=n*Y,M+=n*G,x+=n*J,n=t[14],k+=n*R,w+=n*U,S+=n*z,I+=n*W,v+=n*C,A+=n*D,_+=n*F,E+=n*V,O+=n*K,T+=n*Q,j+=n*H,B+=n*Z,N+=n*q,M+=n*Y,x+=n*G,L+=n*J,n=t[15],w+=n*R,S+=n*U,I+=n*z,v+=n*W,A+=n*C,_+=n*D,E+=n*F,O+=n*V,T+=n*K,j+=n*Q,B+=n*H,N+=n*Z,M+=n*q,x+=n*Y,L+=n*G,P+=n*J,s+=38*S,o+=38*I,a+=38*v,c+=38*A,u+=38*_,l+=38*E,d+=38*O,h+=38*T,b+=38*j,p+=38*B,g+=38*N,y+=38*M,m+=38*x,f+=38*L,k+=38*P,i=1,n=s+i+65535,i=Math.floor(n/65536),s=n-65536*i,n=o+i+65535,i=Math.floor(n/65536),o=n-65536*i,n=a+i+65535,i=Math.floor(n/65536),a=n-65536*i,n=c+i+65535,i=Math.floor(n/65536),c=n-65536*i,n=u+i+65535,i=Math.floor(n/65536),u=n-65536*i,n=l+i+65535,i=Math.floor(n/65536),l=n-65536*i,n=d+i+65535,i=Math.floor(n/65536),d=n-65536*i,n=h+i+65535,i=Math.floor(n/65536),h=n-65536*i,n=b+i+65535,i=Math.floor(n/65536),b=n-65536*i,n=p+i+65535,i=Math.floor(n/65536),p=n-65536*i,n=g+i+65535,i=Math.floor(n/65536),g=n-65536*i,n=y+i+65535,i=Math.floor(n/65536),y=n-65536*i,n=m+i+65535,i=Math.floor(n/65536),m=n-65536*i,n=f+i+65535,i=Math.floor(n/65536),f=n-65536*i,n=k+i+65535,i=Math.floor(n/65536),k=n-65536*i,n=w+i+65535,i=Math.floor(n/65536),w=n-65536*i,s+=i-1+37*(i-1),i=1,n=s+i+65535,i=Math.floor(n/65536),s=n-65536*i,n=o+i+65535,i=Math.floor(n/65536),o=n-65536*i,n=a+i+65535,i=Math.floor(n/65536),a=n-65536*i,n=c+i+65535,i=Math.floor(n/65536),c=n-65536*i,n=u+i+65535,i=Math.floor(n/65536),u=n-65536*i,n=l+i+65535,i=Math.floor(n/65536),l=n-65536*i,n=d+i+65535,i=Math.floor(n/65536),d=n-65536*i,n=h+i+65535,i=Math.floor(n/65536),h=n-65536*i,n=b+i+65535,i=Math.floor(n/65536),b=n-65536*i,n=p+i+65535,i=Math.floor(n/65536),p=n-65536*i,n=g+i+65535,i=Math.floor(n/65536),g=n-65536*i,n=y+i+65535,i=Math.floor(n/65536),y=n-65536*i,n=m+i+65535,i=Math.floor(n/65536),m=n-65536*i,n=f+i+65535,i=Math.floor(n/65536),f=n-65536*i,n=k+i+65535,i=Math.floor(n/65536),k=n-65536*i,n=w+i+65535,i=Math.floor(n/65536),w=n-65536*i,s+=i-1+37*(i-1),e[0]=s,e[1]=o,e[2]=a,e[3]=c,e[4]=u,e[5]=l,e[6]=d,e[7]=h,e[8]=b,e[9]=p,e[10]=g,e[11]=y,e[12]=m,e[13]=f,e[14]=k,e[15]=w}function g(e,t){p(e,t,t)}function y(e,t){const r=s();for(let n=0;n<16;n++)r[n]=t[n];for(let n=253;n>=0;n--)g(r,r),2!==n&&4!==n&&p(r,r,t);for(let n=0;n<16;n++)e[n]=r[n]}function m(e,t){const r=new Uint8Array(32),n=new Float64Array(80),i=s(),o=s(),c=s(),m=s(),f=s(),k=s();for(let s=0;s<31;s++)r[s]=e[s];r[31]=127&e[31]|64,r[0]&=248,d(n,t);for(let s=0;s<16;s++)o[s]=n[s];i[0]=m[0]=1;for(let s=254;s>=0;--s){const e=r[s>>>3]>>>(7&s)&1;u(i,o,e),u(c,m,e),h(f,i,c),b(i,i,c),h(c,o,m),b(o,o,m),g(m,f),g(k,i),p(i,c,i),p(c,o,f),h(f,i,c),b(i,i,c),g(o,i),b(c,m,k),p(i,c,a),h(i,i,m),p(c,c,i),p(i,m,k),p(m,o,n),g(o,f),u(i,o,e),u(c,m,e)}for(let s=0;s<16;s++)n[s+16]=i[s],n[s+32]=c[s],n[s+48]=o[s],n[s+64]=m[s];const w=n.subarray(32),S=n.subarray(16);y(w,w),p(S,S,w);const I=new Uint8Array(32);return l(I,S),I}function f(e){return m(e,o)}function k(e){if(e.length!==t.SECRET_KEY_LENGTH)throw new Error(`x25519: seed must be ${t.SECRET_KEY_LENGTH} bytes`);const r=new Uint8Array(e),n=f(r);return{publicKey:n,secretKey:r}}function w(e){const t=(0,n.randomBytes)(32,e),r=k(t);return(0,i.wipe)(t),r}function S(e,r,n=!1){if(e.length!==t.PUBLIC_KEY_LENGTH)throw new Error("X25519: incorrect secret key length");if(r.length!==t.PUBLIC_KEY_LENGTH)throw new Error("X25519: incorrect public key length");const i=m(e,r);if(n){let e=0;for(let t=0;t<i.length;t++)e|=i[t];if(0===e)throw new Error("X25519: invalid shared key")}return i}t.scalarMult=m,t.scalarMultBase=f,t.generateKeyPairFromSeed=k,t.generateKeyPair=w,t.sharedKey=S},e1c8:function(e,t,r){"use strict";function n(e){return"version"in e}Object.defineProperty(t,"__esModule",{value:!0}),t.isVersionedTransaction=void 0,t.isVersionedTransaction=n},e512:function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.NodeRandomSource=void 0;const n=r("ff6a");class i{constructor(){this.isAvailable=!1,this.isInstantiated=!1;{const e=r(22);e&&e.randomBytes&&(this._crypto=e,this.isAvailable=!0,this.isInstantiated=!0)}}randomBytes(e){if(!this.isAvailable||!this._crypto)throw new Error("Node.js random byte generator is not available.");let t=this._crypto.randomBytes(e);if(t.length!==e)throw new Error("NodeRandomSource: got fewer bytes than requested");const r=new Uint8Array(e);for(let n=0;n<r.length;n++)r[n]=t[n];return(0,n.wipe)(t),r}}t.NodeRandomSource=i},e5f1:function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.randomStringForEntropy=t.randomString=t.randomUint32=t.randomBytes=t.defaultRandomSource=void 0;const n=r("5cc4"),i=r("290c"),s=r("ff6a");function o(e,r=t.defaultRandomSource){return r.randomBytes(e)}function a(e=t.defaultRandomSource){const r=o(4,e),n=(0,i.readUint32LE)(r);return(0,s.wipe)(r),n}t.defaultRandomSource=new n.SystemRandomSource,t.randomBytes=o,t.randomUint32=a;const c="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";function u(e,r=c,n=t.defaultRandomSource){if(r.length<2)throw new Error("randomString charset is too short");if(r.length>256)throw new Error("randomString charset is too long");let i="";const a=r.length,u=256-256%a;while(e>0){const t=o(Math.ceil(256*e/u),n);for(let n=0;n<t.length&&e>0;n++){const s=t[n];s<u&&(i+=r.charAt(s%a),e--)}(0,s.wipe)(t)}return i}function l(e,r=c,n=t.defaultRandomSource){const i=Math.ceil(e/(Math.log(r.length)/Math.LN2));return u(i,r,n)}t.randomString=u,t.randomStringForEntropy=l},e729:function(e,t,r){"use strict";r.d(t,"a",(function(){return n}));const n="solana:signMessage"},ed96:function(e,t,r){"use strict";function n(e,t){var r=e>>>16&65535,n=65535&e,i=t>>>16&65535,s=65535&t;return n*s+(r*s+n*i<<16>>>0)|0}function i(e,t){return e+t|0}function s(e,t){return e-t|0}function o(e,t){return e<<t|e>>>32-t}function a(e,t){return e<<32-t|e>>>t}function c(e){return"number"===typeof e&&isFinite(e)&&Math.floor(e)===e}Object.defineProperty(t,"__esModule",{value:!0}),t.mul=Math.imul||n,t.add=i,t.sub=s,t.rotl=o,t.rotr=a,t.isInteger=Number.isInteger||c,t.MAX_SAFE_INTEGER=9007199254740991,t.isSafeInteger=function(e){return t.isInteger(e)&&e>=-t.MAX_SAFE_INTEGER&&e<=t.MAX_SAFE_INTEGER}},f4f9:function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r("477e"),i=r("ff6a"),s=function(){function e(e,t,r,i){void 0===r&&(r=new Uint8Array(0)),this._counter=new Uint8Array(1),this._hash=e,this._info=i;var s=n.hmac(this._hash,r,t);this._hmac=new n.HMAC(e,s),this._buffer=new Uint8Array(this._hmac.digestLength),this._bufpos=this._buffer.length}return e.prototype._fillBuffer=function(){this._counter[0]++;var e=this._counter[0];if(0===e)throw new Error("hkdf: cannot expand more");this._hmac.reset(),e>1&&this._hmac.update(this._buffer),this._info&&this._hmac.update(this._info),this._hmac.update(this._counter),this._hmac.finish(this._buffer),this._bufpos=0},e.prototype.expand=function(e){for(var t=new Uint8Array(e),r=0;r<t.length;r++)this._bufpos===this._buffer.length&&this._fillBuffer(),t[r]=this._buffer[this._bufpos++];return t},e.prototype.clean=function(){this._hmac.clean(),i.wipe(this._buffer),i.wipe(this._counter),this._bufpos=0},e}();t.HKDF=s},f7f2:function(e,t,r){"use strict";r.d(t,"a",(function(){return o}));var n=r("8df2"),i=r("633a");r("d6e3"),r("753b");const s=Object(n["struct"])([Object(n["u8"])("m"),Object(n["u8"])("n"),Object(i["a"])("isInitialized"),Object(i["b"])("signer1"),Object(i["b"])("signer2"),Object(i["b"])("signer3"),Object(i["b"])("signer4"),Object(i["b"])("signer5"),Object(i["b"])("signer6"),Object(i["b"])("signer7"),Object(i["b"])("signer8"),Object(i["b"])("signer9"),Object(i["b"])("signer10"),Object(i["b"])("signer11")]),o=s.span},fbe3:function(e,t,r){"use strict";var n;r.d(t,"a",(function(){return n})),function(e){e[e["InitializeMint"]=0]="InitializeMint",e[e["InitializeAccount"]=1]="InitializeAccount",e[e["InitializeMultisig"]=2]="InitializeMultisig",e[e["Transfer"]=3]="Transfer",e[e["Approve"]=4]="Approve",e[e["Revoke"]=5]="Revoke",e[e["SetAuthority"]=6]="SetAuthority",e[e["MintTo"]=7]="MintTo",e[e["Burn"]=8]="Burn",e[e["CloseAccount"]=9]="CloseAccount",e[e["FreezeAccount"]=10]="FreezeAccount",e[e["ThawAccount"]=11]="ThawAccount",e[e["TransferChecked"]=12]="TransferChecked",e[e["ApproveChecked"]=13]="ApproveChecked",e[e["MintToChecked"]=14]="MintToChecked",e[e["BurnChecked"]=15]="BurnChecked",e[e["InitializeAccount2"]=16]="InitializeAccount2",e[e["SyncNative"]=17]="SyncNative",e[e["InitializeAccount3"]=18]="InitializeAccount3",e[e["InitializeMultisig2"]=19]="InitializeMultisig2",e[e["InitializeMint2"]=20]="InitializeMint2",e[e["GetAccountDataSize"]=21]="GetAccountDataSize",e[e["InitializeImmutableOwner"]=22]="InitializeImmutableOwner",e[e["AmountToUiAmount"]=23]="AmountToUiAmount",e[e["UiAmountToAmount"]=24]="UiAmountToAmount",e[e["InitializeMintCloseAuthority"]=25]="InitializeMintCloseAuthority",e[e["TransferFeeExtension"]=26]="TransferFeeExtension",e[e["ConfidentialTransferExtension"]=27]="ConfidentialTransferExtension",e[e["DefaultAccountStateExtension"]=28]="DefaultAccountStateExtension",e[e["Reallocate"]=29]="Reallocate",e[e["MemoTransferExtension"]=30]="MemoTransferExtension",e[e["CreateNativeMint"]=31]="CreateNativeMint",e[e["InitializeNonTransferableMint"]=32]="InitializeNonTransferableMint",e[e["InterestBearingMintExtension"]=33]="InterestBearingMintExtension",e[e["CpiGuardExtension"]=34]="CpiGuardExtension",e[e["InitializePermanentDelegate"]=35]="InitializePermanentDelegate",e[e["TransferHookExtension"]=36]="TransferHookExtension",e[e["MetadataPointerExtension"]=39]="MetadataPointerExtension",e[e["GroupPointerExtension"]=40]="GroupPointerExtension",e[e["GroupMemberPointerExtension"]=41]="GroupMemberPointerExtension"}(n||(n={}))},ff6a:function(e,t,r){"use strict";function n(e){for(var t=0;t<e.length;t++)e[t]=0;return e}Object.defineProperty(t,"__esModule",{value:!0}),t.wipe=n}}]);